<?xml version="1.0" encoding="UTF-8"?><script>import nuke
from PySide2 import QtWidgets, QtCore

class MiddleClickInterceptor(QtCore.QObject):
    def __init__(self):
        super().__init__()
        self.start_pos = None  # Guarda la posición inicial del clic

    def eventFilter(self, obj, event):
        if event.type() == QtCore.QEvent.MouseButtonPress:
            if event.button() == QtCore.Qt.MiddleButton:
                self.start_pos = event.pos()  # Guarda la posición inicial del clic
                return False  # Permitimos que el evento continúe (para drag)

        elif event.type() == QtCore.QEvent.MouseButtonRelease:
            if event.button() == QtCore.Qt.MiddleButton and self.start_pos:
                end_pos = event.pos()  # Obtiene la posición donde se soltó el botón
                distance = (end_pos - self.start_pos).manhattanLength()  # Distancia en píxeles

                if distance &lt; 5:  # 🔹 Si fue un clic sin arrastre
                    self.start_pos = None  # Reseteamos la posición inicial
                    
                    # 🔹 DETENEMOS LA PROPAGACIÓN DEL EVENTO 🔹
                    event.accept()  # Evita que el evento siga propagándose en Qt

                    # 🔹 Retrasamos el mensaje para evitar problemas con Qt
                    QtCore.QTimer.singleShot(50, lambda: nuke.message(&quot;Ruedita del mouse apretada&quot;))

                    return True  # 🔹 BLOQUEAMOS la acción original del clic sin arrastre

                # 🔹 Si hubo arrastre, permitimos el evento normalmente
                self.start_pos = None
                return False  

        return False  # Permitimos que otros eventos sigan su curso normal

# Instalar el filtro en la aplicación de Nuke
app = QtWidgets.QApplication.instance()
if app:
    interceptor = MiddleClickInterceptor()
    app.installEventFilter(interceptor)
&quot;&quot;&quot;
   
   Imprime la version en Hiero, version en ShotGrid (SG), estado de la version en SG, 
   descripcion y URLs de las tareas asociadas para los clips seleccionados en el timeline.
   Tambien imprime los comentarios que haya en la version del clip seleccionado
   Esta version nueva imprime la descripcion del shot, de la task, y el tiempo estimado y fecha de inicio y fin de la task
   v08: agrega la fecha de update del shot y de la task
   
&quot;&quot;&quot;


import hiero.core
import os
import re
import shotgun_api3
import sys

class ShotGridManager:
    def __init__(self, url, login, password):
        self.sg = shotgun_api3.Shotgun(url, login=login, password=password)

    def find_shot_and_tasks(self, project_name, shot_code):
        projects = self.sg.find(&quot;Project&quot;, [['name', 'is', project_name]], ['id', 'name'])
        if projects:
            project_id = projects[0]['id']
            filters = [
                ['project', 'is', {'type': 'Project', 'id': project_id}],
                ['code', 'is', shot_code]
            ]
            fields = ['id', 'code', 'description']
            shots = self.sg.find(&quot;Shot&quot;, filters, fields)
            if shots:
                shot_id = shots[0]['id']
                tasks = self.find_tasks_for_shot(shot_id)
                return shots[0], tasks
            else:
                print(&quot;No se encontro el shot.&quot;)
        else:
            print(&quot;No se encontro el proyecto en ShotGrid.&quot;)
        return None, None

    def find_tasks_for_shot(self, shot_id):
        filters = [['entity', 'is', {'type': 'Shot', 'id': shot_id}]]
        fields = [
            'id', 
            'content', 
            'sg_description', 
            'sg_status_list', 
            'sg_estimated_days',
            'start_date',
            'due_date'
        ]
        return self.sg.find(&quot;Task&quot;, filters, fields)

    def find_version_by_code(self, shot_id, version_code):
        filters = [
            ['entity', 'is', {'type': 'Shot', 'id': shot_id}],
            ['code', 'contains', version_code]
        ]
        fields = ['id', 'code', 'created_at', 'user', 'sg_status_list', 'description']
        versions = self.sg.find(&quot;Version&quot;, filters, fields)
        return versions

    def get_task_url(self, task_id):
        return f&quot;{self.sg.base_url}/detail/Task/{task_id}&quot;

    def get_version_notes(self, version_id):
        filters = [['note_links', 'in', {'type': 'Version', 'id': version_id}]]
        fields = ['content', 'user']
        return self.sg.find(&quot;Note&quot;, filters, fields)

class HieroOperations:
    def __init__(self, shotgrid_manager):
        self.sg_manager = shotgrid_manager

    def parse_exr_name(self, file_name):
        base_name = re.sub(r'_%04d\.exr$', '', file_name)
        version_match = re.search(r'_v(\d+)', base_name)
        version_number = version_match.group(1) if version_match else 'Unknown'
        return base_name, version_number

    def process_selected_clips(self):
        seq = hiero.ui.activeSequence()
        if seq:
            te = hiero.ui.getTimelineEditor(seq)
            selected_clips = te.selection()
            if selected_clips:
                for clip in selected_clips:
                    file_path = clip.source().mediaSource().fileinfos()[0].filename()
                    exr_name = os.path.basename(file_path)
                    base_name, hiero_version_number = self.parse_exr_name(exr_name)
                    project_name = base_name.split('_')[0]
                    parts = base_name.split('_')
                    shot_code = '_'.join(parts[:5])

                    shot, tasks = self.sg_manager.find_shot_and_tasks(project_name, shot_code)
                    if shot:
                        # Imprimir la descripcion del shot
                        print(f&quot;- Shot name: {shot['code']}&quot;)
                        print(f&quot;  Description: {shot.get('description', 'No description available')}&quot;)

                        # Mostrar la informacion de la tarea Comp antes de verificar versiones
                        comp_task = next((task for task in tasks if 'Comp' in task['content']), None)
                        if comp_task:
                            estimated_days = comp_task.get('sg_estimated_days', 0)
                            print(f&quot;- Task: {comp_task['content']} (Status: {comp_task['sg_status_list']})&quot;)
                            print(f&quot;  Description: {comp_task.get('sg_description', 'No description available')}&quot;)
                            print(f&quot;  Start Date: {comp_task.get('start_date', 'No start date available')}&quot;)
                            print(f&quot;  Due Date: {comp_task.get('due_date', 'No due date available')}&quot;)
                            print(f&quot;  Estimated Duration: {estimated_days} days&quot;)
                            print(f&quot;  URL: {self.sg_manager.get_task_url(comp_task['id'])}&quot;)

                        # Luego verificar si hay versiones disponibles
                        versions = self.sg_manager.find_version_by_code(shot['id'], f&quot;_v{hiero_version_number}&quot;)
                        if versions:
                            version = versions[0]  # Assuming the first match is the correct version
                            print(f&quot;- Version Hiero: v{hiero_version_number}&quot;)
                            print(f&quot;- Version SG: {version['code']}&quot;)
                            print(f&quot;- Version SG status: {version['sg_status_list']}&quot;)
                            print(f&quot;- Description: {version['description']}&quot;)

                            notes = self.sg_manager.get_version_notes(version['id'])
                            if notes:
                                print(&quot;  - Comments:&quot;)
                                for note in notes:
                                    print(f&quot;    - {note['content']} (User: {note['user']['name']})&quot;)
                            else:
                                print(&quot;  - No comments found.&quot;)
                        else:
                            print(f&quot;No versions found for Hiero version v{hiero_version_number} in ShotGrid.&quot;)
                    else:
                        print(&quot;No se encontro el shot correspondiente en ShotGrid.&quot;)
            else:
                print(&quot;No se han seleccionado clips en el timeline.&quot;)
        else:
            print(&quot;No se encontro una secuencia activa en Hiero.&quot;)

def main():
    global msg_manager
    sg_url = os.getenv('SHOTGRID_URL')
    sg_login = os.getenv('SHOTGRID_LOGIN')
    sg_password = os.getenv('SHOTGRID_PASSWORD')

    if not sg_url or not sg_login or not sg_password:
        print(&quot;Las variables de entorno SHOTGRID_URL, SHOTGRID_LOGIN y SHOTGRID_PASSWORD deben estar configuradas.&quot;)
        return

    sg_manager = ShotGridManager(sg_url, sg_login, sg_password)
    hiero_ops = HieroOperations(sg_manager)
    hiero_ops.process_selected_clips()

if __name__ == &quot;__main__&quot;:
    main()
# Igual que el v02a pero Usando variables de entorno de usuario y pass en vez de script

import os
import shotgun_api3

# Recuperar datos de autenticacion de las variables de entorno
url = os.environ.get(&quot;SHOTGRID_URL&quot;)
login = os.environ.get(&quot;SHOTGRID_LOGIN&quot;)
password = os.environ.get(&quot;SHOTGRID_PASSWORD&quot;)

# Verificar que las variables de entorno se recuperen correctamente
print(f&quot;URL: {url}&quot;)
print(f&quot;Login: {login}&quot;)
print(f&quot;Password: {password}&quot;)

# Crear una instancia de la API de ShotGrid usando login y password
sg = shotgun_api3.Shotgun(url, login=login, password=password)

# Intentar recuperar una lista de proyectos para probar la conexion
try:
    projects = sg.find(&quot;Project&quot;, [], ['id', 'name'])
    print(&quot;Conexion exitosa. Aqui estan algunos de tus proyectos:&quot;)
    for project in projects:
        print(f&quot;{project['id']}: {project['name']}&quot;)
    
    # Obtener informacion del usuario actual
    current_user = sg.find_one(&quot;HumanUser&quot;, [['login', 'is', login]], ['permission_rule_set'])
    
    if current_user and 'permission_rule_set' in current_user:
        # Obtener el nombre del grupo de permisos
        permission_group = sg.find_one(&quot;PermissionRuleSet&quot;, 
                                     [['id', 'is', current_user['permission_rule_set']['id']]], 
                                     ['code'])
        if permission_group:
            print(f&quot;\nTu grupo de permisos es: {permission_group['code']}&quot;)
        else:
            print(&quot;\nNo se pudo determinar tu grupo de permisos&quot;)
    else:
        print(&quot;\nNo se encontraron grupos de permisos para este usuario&quot;)

except Exception as e:
    print(f&quot;Error al conectar con ShotGrid: {e}&quot;)
</script>
