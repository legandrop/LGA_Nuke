<?xml version="1.0" encoding="UTF-8"?><script>import nuke
from PySide2 import QtWidgets, QtCore

class MiddleClickInterceptor(QtCore.QObject):
    def __init__(self):
        super().__init__()
        self.start_pos = None  # Guarda la posición inicial del clic

    def eventFilter(self, obj, event):
        if event.type() == QtCore.QEvent.MouseButtonPress:
            if event.button() == QtCore.Qt.MiddleButton:
                self.start_pos = event.pos()  # Guarda la posición inicial del clic
                return False  # Permitimos que el evento continúe (para drag)

        elif event.type() == QtCore.QEvent.MouseButtonRelease:
            if event.button() == QtCore.Qt.MiddleButton and self.start_pos:
                end_pos = event.pos()  # Obtiene la posición donde se soltó el botón
                distance = (end_pos - self.start_pos).manhattanLength()  # Distancia en píxeles

                if distance &lt; 5:  # 🔹 Si fue un clic sin arrastre
                    self.start_pos = None  # Reseteamos la posición inicial
                    
                    # 🔹 DETENEMOS LA PROPAGACIÓN DEL EVENTO 🔹
                    event.accept()  # Evita que el evento siga propagándose en Qt

                    # 🔹 Retrasamos el mensaje para evitar problemas con Qt
                    QtCore.QTimer.singleShot(50, lambda: nuke.message(&quot;Ruedita del mouse apretada&quot;))

                    return True  # 🔹 BLOQUEAMOS la acción original del clic sin arrastre

                # 🔹 Si hubo arrastre, permitimos el evento normalmente
                self.start_pos = None
                return False  

        return False  # Permitimos que otros eventos sigan su curso normal

# Instalar el filtro en la aplicación de Nuke
app = QtWidgets.QApplication.instance()
if app:
    interceptor = MiddleClickInterceptor()
    app.installEventFilter(interceptor)
&quot;&quot;&quot;
   
   Imprime la version en Hiero, version en ShotGrid (SG), estado de la version en SG, 
   descripcion y URLs de las tareas asociadas para los clips seleccionados en el timeline.
   Tambien imprime los comentarios que haya en la version del clip seleccionado
   Esta version nueva imprime la descripcion del shot, de la task, y el tiempo estimado y fecha de inicio y fin de la task
   v08: agrega la fecha de update del shot y de la task
   
&quot;&quot;&quot;


import hiero.core
import os
import re
import shotgun_api3
import sys

class ShotGridManager:
    def __init__(self, url, login, password):
        self.sg = shotgun_api3.Shotgun(url, login=login, password=password)

    def find_shot_and_tasks(self, project_name, shot_code):
        projects = self.sg.find(&quot;Project&quot;, [['name', 'is', project_name]], ['id', 'name'])
        if projects:
            project_id = projects[0]['id']
            filters = [
                ['project', 'is', {'type': 'Project', 'id': project_id}],
                ['code', 'is', shot_code]
            ]
            fields = ['id', 'code', 'description']
            shots = self.sg.find(&quot;Shot&quot;, filters, fields)
            if shots:
                shot_id = shots[0]['id']
                tasks = self.find_tasks_for_shot(shot_id)
                return shots[0], tasks
            else:
                print(&quot;No se encontro el shot.&quot;)
        else:
            print(&quot;No se encontro el proyecto en ShotGrid.&quot;)
        return None, None

    def find_tasks_for_shot(self, shot_id):
        filters = [['entity', 'is', {'type': 'Shot', 'id': shot_id}]]
        fields = [
            'id', 
            'content', 
            'sg_description', 
            'sg_status_list', 
            'sg_estimated_days',
            'start_date',
            'due_date'
        ]
        return self.sg.find(&quot;Task&quot;, filters, fields)

    def find_version_by_code(self, shot_id, version_code):
        filters = [
            ['entity', 'is', {'type': 'Shot', 'id': shot_id}],
            ['code', 'contains', version_code]
        ]
        fields = ['id', 'code', 'created_at', 'user', 'sg_status_list', 'description']
        versions = self.sg.find(&quot;Version&quot;, filters, fields)
        return versions

    def get_task_url(self, task_id):
        return f&quot;{self.sg.base_url}/detail/Task/{task_id}&quot;

    def get_version_notes(self, version_id):
        filters = [['note_links', 'in', {'type': 'Version', 'id': version_id}]]
        fields = ['content', 'user']
        return self.sg.find(&quot;Note&quot;, filters, fields)

class HieroOperations:
    def __init__(self, shotgrid_manager):
        self.sg_manager = shotgrid_manager

    def parse_exr_name(self, file_name):
        base_name = re.sub(r'_%04d\.exr$', '', file_name)
        version_match = re.search(r'_v(\d+)', base_name)
        version_number = version_match.group(1) if version_match else 'Unknown'
        return base_name, version_number

    def process_selected_clips(self):
        seq = hiero.ui.activeSequence()
        if seq:
            te = hiero.ui.getTimelineEditor(seq)
            selected_clips = te.selection()
            if selected_clips:
                for clip in selected_clips:
                    file_path = clip.source().mediaSource().fileinfos()[0].filename()
                    exr_name = os.path.basename(file_path)
                    base_name, hiero_version_number = self.parse_exr_name(exr_name)
                    project_name = base_name.split('_')[0]
                    parts = base_name.split('_')
                    shot_code = '_'.join(parts[:5])

                    shot, tasks = self.sg_manager.find_shot_and_tasks(project_name, shot_code)
                    if shot:
                        # Imprimir la descripcion del shot
                        print(f&quot;- Shot name: {shot['code']}&quot;)
                        print(f&quot;  Description: {shot.get('description', 'No description available')}&quot;)

                        # Mostrar la informacion de la tarea Comp antes de verificar versiones
                        comp_task = next((task for task in tasks if 'Comp' in task['content']), None)
                        if comp_task:
                            estimated_days = comp_task.get('sg_estimated_days', 0)
                            print(f&quot;- Task: {comp_task['content']} (Status: {comp_task['sg_status_list']})&quot;)
                            print(f&quot;  Description: {comp_task.get('sg_description', 'No description available')}&quot;)
                            print(f&quot;  Start Date: {comp_task.get('start_date', 'No start date available')}&quot;)
                            print(f&quot;  Due Date: {comp_task.get('due_date', 'No due date available')}&quot;)
                            print(f&quot;  Estimated Duration: {estimated_days} days&quot;)
                            print(f&quot;  URL: {self.sg_manager.get_task_url(comp_task['id'])}&quot;)

                        # Luego verificar si hay versiones disponibles
                        versions = self.sg_manager.find_version_by_code(shot['id'], f&quot;_v{hiero_version_number}&quot;)
                        if versions:
                            version = versions[0]  # Assuming the first match is the correct version
                            print(f&quot;- Version Hiero: v{hiero_version_number}&quot;)
                            print(f&quot;- Version SG: {version['code']}&quot;)
                            print(f&quot;- Version SG status: {version['sg_status_list']}&quot;)
                            print(f&quot;- Description: {version['description']}&quot;)

                            notes = self.sg_manager.get_version_notes(version['id'])
                            if notes:
                                print(&quot;  - Comments:&quot;)
                                for note in notes:
                                    print(f&quot;    - {note['content']} (User: {note['user']['name']})&quot;)
                            else:
                                print(&quot;  - No comments found.&quot;)
                        else:
                            print(f&quot;No versions found for Hiero version v{hiero_version_number} in ShotGrid.&quot;)
                    else:
                        print(&quot;No se encontro el shot correspondiente en ShotGrid.&quot;)
            else:
                print(&quot;No se han seleccionado clips en el timeline.&quot;)
        else:
            print(&quot;No se encontro una secuencia activa en Hiero.&quot;)

def main():
    global msg_manager
    sg_url = os.getenv('SHOTGRID_URL')
    sg_login = os.getenv('SHOTGRID_LOGIN')
    sg_password = os.getenv('SHOTGRID_PASSWORD')

    if not sg_url or not sg_login or not sg_password:
        print(&quot;Las variables de entorno SHOTGRID_URL, SHOTGRID_LOGIN y SHOTGRID_PASSWORD deben estar configuradas.&quot;)
        return

    sg_manager = ShotGridManager(sg_url, sg_login, sg_password)
    hiero_ops = HieroOperations(sg_manager)
    hiero_ops.process_selected_clips()

if __name__ == &quot;__main__&quot;:
    main()
&quot;&quot;&quot;
______________________________________________________

  LGA_NKS_CreateNewTrack v1.0 - 2024 - Lega
  Crea un nuevo track de video encima del track actualmente seleccionado
______________________________________________________

&quot;&quot;&quot;

import hiero.core
import hiero.ui

def print_tracks(seq, message):
    &quot;&quot;&quot;Imprime los tracks en orden&quot;&quot;&quot;
    print(f&quot;\n{message}&quot;)
    print(&quot;Tracks (de abajo hacia arriba):&quot;)
    for i, track in enumerate(seq.videoTracks()):
        print(f&quot;{i}: {track.name()}&quot;)

def get_selected_track_index(seq):
    &quot;&quot;&quot;Obtiene el indice del track actualmente seleccionado&quot;&quot;&quot;
    te = hiero.ui.getTimelineEditor(seq)
    selected_items = te.selection()
    
    if not selected_items:
        print(&quot;No hay items seleccionados en la linea de tiempo.&quot;)
        return None
        
    # Obtener el track del primer item seleccionado
    selected_track = selected_items[0].parentTrack()
    if not selected_track:
        print(&quot;No se pudo obtener el track seleccionado.&quot;)
        return None
        
    # Encontrar el indice del track en la secuencia
    for index, track in enumerate(seq.videoTracks()):
        if track == selected_track:
            return index
            
    return None

def create_new_track(seq, track_index):
    &quot;&quot;&quot;Crea un nuevo track y lo inserta en la posicion especificada&quot;&quot;&quot;
    if track_index is None:
        print(&quot;No se pudo determinar la posicion del nuevo track.&quot;)
        return None
        
    # Crear el nuevo track
    new_track = hiero.core.VideoTrack(&quot;New&quot;)
    
    # Obtener todos los tracks de video
    video_tracks = list(seq.videoTracks())
    
    # Imprimir tracks antes de la operación
    print_tracks(seq, &quot;ANTES DE LA OPERACIÓN&quot;)
    
    # Remover todos los tracks existentes
    for track in video_tracks:
        seq.removeTrack(track)
    
    # Insertar el nuevo track en la posicion deseada (encima del track seleccionado)
    # Insertamos en track_index + 1 para que aparezca encima del track seleccionado
    new_tracks = video_tracks[:track_index+1] + [new_track] + video_tracks[track_index+1:]
    
    # Imprimir el orden que vamos a insertar
    print(&quot;\nORDEN DE INSERCIÓN:&quot;)
    for i, track in enumerate(new_tracks):
        print(f&quot;{i}: {track.name()}&quot;)
    
    # Reinsertar todos los tracks en el orden correcto
    for track in new_tracks:
        seq.addTrack(track)
    
    # Imprimir tracks después de la operación
    print_tracks(seq, &quot;DESPUÉS DE LA OPERACIÓN&quot;)
        
    print(f&quot;Nuevo track creado encima del track en la posicion {track_index}&quot;)
    return new_track

def main():
    try:
        # Obtener la secuencia activa
        seq = hiero.ui.activeSequence()
        if not seq:
            print(&quot;No se encontro una secuencia activa en Hiero.&quot;)
            return
            
        # Iniciar una accion de undo
        project = seq.project()
        project.beginUndo(&quot;Crear Nuevo Track&quot;)
        
        try:
            # Obtener el indice del track seleccionado
            track_index = get_selected_track_index(seq)
            
            # Crear el nuevo track
            new_track = create_new_track(seq, track_index)
            
            if new_track:
                print(&quot;Operacion completada exitosamente.&quot;)
            else:
                print(&quot;No se pudo crear el nuevo track.&quot;)
                
        except Exception as e:
            print(f&quot;Error durante la operacion: {e}&quot;)
        finally:
            # Finalizar la accion de undo
            project.endUndo()
            
    except Exception as e:
        print(f&quot;Error general: {e}&quot;)

if __name__ == &quot;__main__&quot;:
    main() </script>
