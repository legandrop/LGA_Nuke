<?xml version="1.0" encoding="UTF-8"?><script>import os

def check_environment_variables():
    from_email = os.getenv('Nuke_Write_Mail_From')
    password = os.getenv('Nuke_Write_Mail_Pass')
    to_email = os.getenv('Nuke_Write_Mail_To')

    print(f&quot;Nuke_Write_Mail_From: {from_email}&quot;)
    print(f&quot;Nuke_Write_Mail_Pass: {password}&quot;)
    print(f&quot;Nuke_Write_Mail_To: {to_email}&quot;)

check_environment_variables()
import hiero.core
import hiero.ui

def add_custom_tag_to_selected_clips():
    # Obtiene la selección actual en el editor de timeline
    selection = hiero.ui.getTimelineEditor(hiero.ui.activeSequence()).getSelection()
    if not selection:
        print(&quot;No clips selected.&quot;)
        return

    # Define el tag con sus propiedades
    tag_name = &quot;Magenta&quot;
    tag_note = &quot;Esto es una Note&quot;
    tag_assignee = &quot;Persona&quot;
    tag_icon = &quot;icons:TagRed.png&quot;

    # Recorre cada clip seleccionado y añade el tag
    for clip in selection:
        # Crea el tag
        new_tag = hiero.core.Tag(tag_name)
        new_tag.setIcon(tag_icon)
        new_tag.setNote(tag_note)
        
        # Añadir el assignee en los metadatos
        new_tag.metadata().setValue(&quot;tag.assignee&quot;, tag_assignee)
        
        # Añade el tag al clip
        clip.addTag(new_tag)
        print(f&quot;Added tag '{tag_name}' with note '{tag_note}' and assignee '{tag_assignee}' to clip: {clip.name()}&quot;)

add_custom_tag_to_selected_clips()
import hiero.core
import hiero.ui

def add_custom_tag_to_selected_clips():
    # Obtiene la selección actual en el editor de timeline
    selection = hiero.ui.getTimelineEditor(hiero.ui.activeSequence()).getSelection()
    if not selection:
        print(&quot;No clips selected.&quot;)
        return

    # Define el tag con sus propiedades
    tag_name = &quot;Magenta&quot;
    tag_note = &quot;Esto es una Note&quot;
    tag_assignee = &quot;Persona&quot;
    tag_icon = &quot;icons:TagRed.png&quot;

    # Recorre cada clip seleccionado y añade el tag
    for clip in selection:
        # Crea el tag
        new_tag = hiero.core.Tag(tag_name)
        new_tag.setIcon(tag_icon)
        new_tag.setNote(tag_note)
        
        # Añadir el assignee en los metadatos con la clave &quot;Assignee&quot; y espacio adicional
        formatted_assignee = tag_assignee + &quot; &quot;
        new_tag.metadata().setValue(&quot;tag.Assignee&quot;, formatted_assignee)
        
        # Añade el tag al clip
        clip.addTag(new_tag)
        print(f&quot;Added tag '{tag_name}' with note '{tag_note}' and assignee '{formatted_assignee}' to clip: {clip.name()}&quot;)

add_custom_tag_to_selected_clips()
import nuke
import os
import sys

# Obtiene la ruta del directorio donde se encuentra el script actual.
script_dir = os.path.dirname(__file__)

# Construye la ruta hacia la carpeta 'oz_backdrop' asumiendo que esta en el mismo directorio que el script actual.
oz_backdrop_path = os.path.join(script_dir, &quot;oz_backdrop&quot;)

# Agrega la ruta construida al sys.path
sys.path.append(oz_backdrop_path)

import oz_backdrop

def create_oz_backdrop():
    new_bd = oz_backdrop.autoBackdrop()
    new_bd[&quot;label&quot;].setValue(&quot;&quot;)
    new_bd[&quot;note_font_size&quot;].setValue(42)

# Asigna el atajo de teclado 'Shift+B' para crear un oz_backdrop
nuke.menu('Nuke').addCommand('Edit/oz_Backdrop', create_oz_backdrop, 'Shift+b')
&quot;&quot;&quot;
________________________________________________________________________________

  LGA_dissable_AB v1.0 - 2024 - Lega Pugliese
  Displays selected nodes in a table with checkboxes
________________________________________________________________________________

&quot;&quot;&quot;

from PySide2.QtWidgets import QApplication, QWidget, QVBoxLayout, QTableWidget, QTableWidgetItem, QHeaderView, QCheckBox, QStyledItemDelegate
from PySide2.QtWidgets import QPushButton, QHBoxLayout, QStyle
from PySide2.QtGui import QColor, QBrush, QScreen, QFont, QPalette, QKeyEvent
from PySide2.QtCore import Qt
import nuke


class CenteredCheckbox(QCheckBox):
    def __init__(self, parent=None):
        super(CenteredCheckbox, self).__init__(parent)
        self.setStyleSheet(&quot;QCheckBox { margin-left: 50%; margin-right: 50%; }&quot;)

class ColorMixDelegate(QStyledItemDelegate):
    def __init__(self, table_widget, background_colors, mix_color=(88, 88, 88), parent=None):
        super(ColorMixDelegate, self).__init__(parent)
        self.table_widget = table_widget
        self.background_colors = background_colors
        self.mix_color = mix_color

    def mix_colors(self, color1, color2):
        mixed_color = tuple((c1 + c2) // 2 for c1, c2 in zip(color1, color2))
        return mixed_color

    def paint(self, painter, option, index):
        row = index.row()
        column = index.column()
        if option.state &amp; QStyle.State_Selected:
            original_color = QColor(self.background_colors[row][column])
            mixed_color = self.mix_colors((original_color.red(), original_color.green(), original_color.blue()), self.mix_color)
            option.palette.setColor(QPalette.Highlight, QColor(*mixed_color))
        else:
            original_color = QColor(self.background_colors[row][column])
            option.palette.setColor(QPalette.Base, original_color)
        
        super(ColorMixDelegate, self).paint(painter, option, index)

def convert_color(value):
    r = int((value &amp; 0xff000000) &gt;&gt; 24)
    g = int((value &amp; 0x00ff0000) &gt;&gt; 16)
    b = int((value &amp; 0x0000ff00) &gt;&gt; 8)
    return r, g, b

def get_node_color(node):
    # Verificar si el nodo tiene un valor de color
    if 'tile_color' in node.knobs():
        # Obtener el valor del color
        color_value = node['tile_color'].value()
        
        # Si el color es 0, significa que usa el color por defecto
        if color_value == 0:
            # Obtener el tipo de nodo
            node_class = node.Class()
            
            # Obtener el color por defecto desde las preferencias de Nuke
            default_color_value = nuke.defaultNodeColor(node_class)
            return convert_color(default_color_value)
        else:
            # Convertir el valor del color en RGB
            return convert_color(color_value)
    else:
        # Color por defecto si no hay valor de color
        return 255, 255, 255  # Blanco

def is_color_light(r, g, b):
    # Calcular el brillo del color
    brightness = (r * 0.299 + g * 0.587 + b * 0.114)
    return brightness &gt; 126

def generate_unique_name(base_name):
    existing_names = [node.name() for node in nuke.allNodes()]
    if base_name not in existing_names:
        return base_name

    i = 1
    while f&quot;{base_name}{i}&quot; in existing_names:
        i += 1

    return f&quot;{base_name}{i}&quot;


class SelectedNodeInfo(QWidget):
    def __init__(self, nodes, initial_connections=None, disable_ab_node=None, parent=None):
        super(SelectedNodeInfo, self).__init__(parent)
        
        # Inicializar initial_connections como una lista vacía si es None
        if initial_connections is None:
            initial_connections = [&quot;&quot;] * len(nodes)
        
        # Ordenar los nodos según la posición Y y mantener las conexiones iniciales sincronizadas
        sorted_nodes_with_connections = sorted(zip(nodes, initial_connections), key=lambda item: item[0]['ypos'].value())
        self.nodes = [item[0] for item in sorted_nodes_with_connections]
        self.initial_connections = [item[1] for item in sorted_nodes_with_connections]
        self.disable_ab_node = disable_ab_node

        self.initUI()


    def initUI(self):
        self.setWindowTitle(&quot;Selected Nodes Info&quot;)
        layout = QVBoxLayout(self)

        # Create the table with 4 columns
        self.table = QTableWidget(len(self.nodes), 4, self)
        self.table.setHorizontalHeaderLabels(['A', 'B', 'Node Name', 'Label'])
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        
        # Eliminar números de las filas
        self.table.verticalHeader().setVisible(False)
        
        # Centrar los títulos de las tres primeras columnas
        for i in range(3):
            self.table.horizontalHeaderItem(i).setTextAlignment(Qt.AlignCenter)

        # Set the style for the table
        self.table.setStyleSheet(&quot;&quot;&quot;
            QTableView::item:selected {
                color: black;
                background-color: transparent;  // Hacer transparente el fondo de los ítems seleccionados
            }
        &quot;&quot;&quot;)

        # Set selection behavior to select entire rows
        self.table.setSelectionBehavior(QTableWidget.SelectRows)
        
        # Disable selection
        self.table.setSelectionMode(QTableWidget.NoSelection)

        # Load data into the table
        self.load_data()

        layout.addWidget(self.table)

        # Create a horizontal layout for buttons
        button_layout = QHBoxLayout()
        
        # Create Connect button
        self.connect_button = QPushButton('Connect')
        button_layout.addWidget(self.connect_button)
        
        # Create Disconnect button (only if a Disable_AB node is selected)
        if self.disable_ab_node:
            self.disconnect_button = QPushButton('Disconnect')
            button_layout.addWidget(self.disconnect_button)
            self.disconnect_button.clicked.connect(self.disconnect_nodes)

        # Add the button layout to the main layout
        layout.addLayout(button_layout)

        self.setLayout(layout)
        
        # Connect the Connect button to the connect_nodes method
        self.connect_button.clicked.connect(self.connect_nodes)
        
        # Adjust window size and position to be centered
        self.adjust_window_size()
        
        # Set the delegate for color mixing
        background_colors = [['#ffffff' for _ in range(4)] for _ in range(len(self.nodes))]  # Example background colors
        self.table.setItemDelegate(ColorMixDelegate(self.table, background_colors))

    def disconnect_nodes(self):
        # Abrir un UNDO
        nuke.Undo.begin(&quot;Disconnect nodes and delete Disable_AB&quot;)

        try:
            # Eliminar las expresiones de los nodos
            for row in range(self.table.rowCount()):
                node = self.nodes[row]
                node['disable'].clearAnimated()

            # Eliminar el nodo Disable_AB
            if self.disable_ab_node:
                nuke.delete(self.disable_ab_node)

            # Cerrar la ventana después de desconectar y eliminar el nodo
            self.close()
        
        finally:
            # Cerrar el UNDO
            nuke.Undo.end()

    def load_data(self):
        for row, node in enumerate(self.nodes):
            r, g, b = get_node_color(node)
            node_qcolor = QColor(r, g, b)  # Convertir los valores RGB a QColor

            # Ajustar el color del texto en función del brillo del fondo
            if is_color_light(r, g, b):
                text_color = QColor(0, 0, 0)  # Texto negro para fondos claros
            else:
                text_color = QColor(255, 255, 255)  # Texto blanco para fondos oscuros

            for col in range(4):
                if col &lt; 2:  # Las primeras dos columnas son checkboxes
                    checkbox = CenteredCheckbox()
                    checkbox.setStyleSheet(&quot;QCheckBox { margin-left: 50%; margin-right: 50%; }&quot;)
                    item = QTableWidgetItem()
                    item.setBackground(node_qcolor)
                    item.setForeground(QBrush(text_color))
                    self.table.setItem(row, col, item)
                    self.table.setCellWidget(row, col, checkbox)
                    
                    # Set checkbox state based on initial connections
                    if self.initial_connections:
                        if col == 0 and self.initial_connections[row] == &quot;A&quot;:
                            checkbox.setChecked(True)
                            print(f&quot;Row {row} - Column A - Node {node.name()} is checked&quot;)
                        elif col == 1 and self.initial_connections[row] == &quot;B&quot;:
                            checkbox.setChecked(True)
                            print(f&quot;Row {row} - Column B - Node {node.name()} is checked&quot;)

                    # Conectar la señal stateChanged al método handle_checkbox_change
                    checkbox.stateChanged.connect(lambda state, row=row, col=col: self.handle_checkbox_change(row, col))
                elif col == 2:  # La tercera columna es el nombre del nodo
                    node_item = QTableWidgetItem(node.name())
                    node_item.setBackground(node_qcolor)
                    node_item.setForeground(QBrush(text_color))
                    self.table.setItem(row, col, node_item)
                else:  # La cuarta columna es el label del nodo, limitado a 30 caracteres
                    label_text = node['label'].value() if 'label' in node.knobs() else &quot;&quot;
                    truncated_label = (label_text[:30] + '...') if len(label_text) &gt; 30 else label_text
                    label_item = QTableWidgetItem(truncated_label)
                    label_item.setBackground(node_qcolor)
                    label_item.setForeground(QBrush(text_color))
                    self.table.setItem(row, col, label_item)
    
        self.table.resizeColumnsToContents()





    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Escape:
            self.close()
        else:
            super(SelectedNodeInfo, self).keyPressEvent(event)


    def handle_checkbox_change(self, row, col):
        if col == 0:  # Checkbox de la columna A
            if self.table.cellWidget(row, 0).isChecked():
                self.table.cellWidget(row, 1).setChecked(False)
        elif col == 1:  # Checkbox de la columna B
            if self.table.cellWidget(row, 1).isChecked():
                self.table.cellWidget(row, 0).setChecked(False)



    def adjust_window_size(self):
        # Desactivar temporalmente el estiramiento de la última columna
        self.table.horizontalHeader().setStretchLastSection(False)

        # Ajustar las columnas al contenido
        self.table.resizeColumnsToContents()

        # Calcular el ancho de la ventana basado en el ancho de las columnas
        width = self.table.verticalHeader().width() - 30  # Un poco de relleno para estética
        for i in range(self.table.columnCount()):
            width += self.table.columnWidth(i) + 20  # Un poco de relleno entre columnas

        # Asegurarse de que el ancho no supera el 80% del ancho de pantalla
        screen = QApplication.primaryScreen()
        screen_rect = screen.availableGeometry()
        max_width = screen_rect.width() * 0.8
        final_width = min(width, max_width)

        # Calcular la altura basada en la altura de los headers y las filas
        height = self.table.horizontalHeader().height() + 20
        for i in range(self.table.rowCount()):
            height += self.table.rowHeight(i) + 4  # Un pequeño relleno por fila

        # Agregar la altura de los botones (solo una vez)
        button_height = self.connect_button.sizeHint().height()
        height += button_height

        # Asegurarse de que la altura no supera el 80% del alto de pantalla
        max_height = screen_rect.height() * 0.8
        final_height = min(height, max_height)

        # Reactivar el estiramiento de la última columna
        self.table.horizontalHeader().setStretchLastSection(True)

        # Ajustar el tamaño de la ventana y centrarla
        self.resize(final_width, final_height)
        self.move((screen_rect.width() - final_width) // 2, (screen_rect.height() - final_height) // 2)


    def connect_nodes(self):
        # Abrir un UNDO
        nuke.Undo.begin(&quot;Create Disable_AB and link nodes&quot;)

        try:
            # Deseleccionar todos los nodos
            for node in nuke.allNodes():
                node['selected'].setValue(False)

            # Obtener la posición del primer nodo
            first_node = self.nodes[0]
            first_node_xpos = int(first_node['xpos'].value())
            first_node_ypos = int(first_node['ypos'].value())

            # Generar un nombre único para el nodo Disable_AB
            unique_name = generate_unique_name(&quot;Disable_AB&quot;)

            # Crear el nodo noOp llamado Disable_AB
            disable_ab_node = nuke.createNode(&quot;NoOp&quot;)
            disable_ab_node.setName(unique_name)
            
            # Posicionar el nodo Disable_AB
            disable_ab_node.setXYpos(first_node_xpos + 150, first_node_ypos)

            # Agregar el checkbox de Disable al nodo Disable_AB
            disable_checkbox = nuke.Boolean_Knob(&quot;disable&quot;, &quot;Disable&quot;)
            disable_ab_node.addKnob(disable_checkbox)
            
            # Agregar knobs ocultos para almacenar la información de conexiones
            disable_ab_node.addKnob(nuke.String_Knob(&quot;groupA_connections&quot;, &quot;&quot;))
            disable_ab_node['groupA_connections'].setVisible(False)
            disable_ab_node.addKnob(nuke.String_Knob(&quot;groupB_connections&quot;, &quot;&quot;))
            disable_ab_node['groupB_connections'].setVisible(False)

            groupA_connections = []
            groupB_connections = []

            for row in range(self.table.rowCount()):
                node = self.nodes[row]
                node_name = node.name()
                
                if self.table.cellWidget(row, 0).isChecked():  # Nodo del grupo A
                    node['disable'].setExpression(f&quot;parent.{unique_name}.disable&quot;)
                    groupA_connections.append(node_name)
                
                if self.table.cellWidget(row, 1).isChecked():  # Nodo del grupo B
                    node['disable'].setExpression(f&quot;!parent.{unique_name}.disable&quot;)
                    groupB_connections.append(node_name)

            # Almacenar la información de conexiones en los knobs ocultos
            disable_ab_node['groupA_connections'].setValue(&quot;,&quot;.join(groupA_connections))
            disable_ab_node['groupB_connections'].setValue(&quot;,&quot;.join(groupB_connections))

            # Cerrar la ventana después de crear el nodo
            self.close()
        
        finally:
            # Cerrar el UNDO
            nuke.Undo.end()



app = None
window = None

def main():
    global app, window
    # Obtener los nodos seleccionados
    selected_nodes = nuke.selectedNodes()
    disable_ab_selected = False
    
    # Verificar si hay un solo nodo seleccionado
    if len(selected_nodes) == 1:
        single_node = selected_nodes[0]
        if single_node.Class() == &quot;NoOp&quot; and single_node.name().startswith(&quot;Disable_AB&quot;):
            disable_ab_selected = True
            # Obtener la información de conexiones de los knobs ocultos
            groupA_connections = single_node['groupA_connections'].value().split(&quot;,&quot;)
            groupB_connections = single_node['groupB_connections'].value().split(&quot;,&quot;)
            
            connected_nodes = []
            initial_connections = []

            for node_name in groupA_connections:
                node = nuke.toNode(node_name)
                if node:
                    connected_nodes.append(node)
                    initial_connections.append(&quot;A&quot;)
                    print(f&quot;Node {node_name} is connected as A&quot;)  # Depuración

            for node_name in groupB_connections:
                node = nuke.toNode(node_name)
                if node:
                    connected_nodes.append(node)
                    initial_connections.append(&quot;B&quot;)
                    print(f&quot;Node {node_name} is connected as B&quot;)  # Depuración

            # Check if there's already an instance of QApplication
            app = QApplication.instance() or QApplication([])
            window = SelectedNodeInfo(connected_nodes, initial_connections=initial_connections, disable_ab_node=single_node)
            window.show()
            return
        else:
            return  # No hacer nada si el único nodo seleccionado no es un Disable_AB
    
    # Verificar si algún nodo tiene el knob disable linkeado por expresión o animado por keyframes
    for node in selected_nodes:
        if 'disable' in node.knobs():
            knob = node['disable']
            if knob.hasExpression() or knob.isAnimated():
                nuke.message(f&quot;Node {node.name()} has the 'disable' knob linked by expression or animated. The script cannot be executed.&quot;)
                return

    # Check if there's already an instance of QApplication
    app = QApplication.instance() or QApplication([])
    window = SelectedNodeInfo(selected_nodes, disable_ab_node=None)
    window.show()




# Llamar a main() para iniciar la aplicación
main()
&quot;&quot;&quot;
__________________________________________________________________________________________________

  LGA_selectConnectedNodes v1.3 - 2024 - Lega Pugliese
  Select connected or unconnected nodes in any direction ignoring flow, including backdrops
__________________________________________________________________________________________________

&quot;&quot;&quot;

import nuke

def selectNodes(direction):
    # Comenzar con el nodo seleccionado actualmente
    selected_nodes = nuke.selectedNodes()
    if not selected_nodes:
        nuke.message('Please select at least one node to proceed.')
        return

    # Obtener el nodo seleccionado actualmente
    current_node = selected_nodes[0]

    # Asegurarse de que el nodo actual no sea el nodo raiz
    if current_node.Class() == 'Root':
        nuke.message('The operation cannot be performed on the root node. Please select a different node.')
        return

    # Calcular el centro del nodo actual
    current_node_center_x = current_node.xpos() + (current_node.screenWidth() / 2)
    current_node_center_y = current_node.ypos() + (current_node.screenHeight() / 2)

    # Obtener todos los nodos que no sean el nodo raiz ni el nodo seleccionado actualmente
    all_nodes = [n for n in nuke.allNodes() if n != current_node and n.Class() != 'Root']

    for node in all_nodes:
        # Calcular el centro del nodo
        node_center_x = node.xpos() + (node.screenWidth() / 2)
        node_center_y = node.ypos() + (node.screenHeight() / 2)

        # Verificar la posicion del nodo en relacion al nodo seleccionado
        if direction == 'l' and node_center_x &lt; current_node_center_x:
            node['selected'].setValue(True)
        elif direction == 'r' and node_center_x &gt; current_node_center_x:
            node['selected'].setValue(True)
        elif direction == 't' and node_center_y &lt; current_node_center_y:
            node['selected'].setValue(True)
        elif direction == 'b' and node_center_y &gt; current_node_center_y:
            node['selected'].setValue(True)

# Ejecutar la función con la dirección deseada, por ejemplo 'b' para seleccionar todos los nodos más abajo
selectNodes('b')
import importlib
import LGA_disable_AB
importlib.reload(LGA_disable_AB)

import importlib
import LGA_disable_A_B
importlib.reload(LGA_disable_A_B)

import nuke

# Crear un nodo Write
write_node = nuke.createNode('Write')

# Agregar un checkbox al nodo Write
knob = nuke.Boolean_Knob('checkbox', 'Checkbox')
write_node.addKnob(knob)
import nuke

# Establecer valores por defecto para knobs específicos en nodos Write
nuke.knobDefault(&quot;Render.continue_on_error&quot;, &quot;False&quot;)
nuke.knobDefault(&quot;Render.frame_range&quot;, &quot;global&quot;)

# Crear un nodo Write para probar
#nuke.createNode('Write')
import hiero.core
import hiero.ui

def create_and_move_new_track():
    # Obtener la secuencia activa en el timeline
    seq = hiero.ui.activeSequence()
    if not seq:
        print(&quot;No active sequence found.&quot;)
        return
    
    # Encontrar el índice del track llamado &quot;EXR&quot;
    exr_index = -1
    for index, track in enumerate(seq.videoTracks()):
        if track.name() == &quot;EXR&quot;:
            exr_index = index
            break
    
    if exr_index == -1:
        print(&quot;No se encontró un track llamado 'EXR'.&quot;)
        return
    
    # Obtener la lista de todos los tracks de video
    video_tracks = list(seq.videoTracks())
    print(f&quot;Current video tracks: {[track.name() for track in video_tracks]}&quot;)

    # Iniciar una acción de undo
    project = seq.project()
    project.beginUndo(&quot;Move New Track Below EXR&quot;)

    try:
        # Primero remover todos los tracks
        for track in video_tracks:
            seq.removeTrack(track)
        
        # Crear el nuevo track
        new_track = hiero.core.VideoTrack(&quot;New Video Track&quot;)
        
        # Reinsertar los tracks en el orden deseado, incluyendo el nuevo track
        reordered_tracks = video_tracks[:exr_index + 1] + [new_track] + video_tracks[exr_index + 1:]
        for track in reordered_tracks:
            seq.addTrack(track)
        
        print(f&quot;New track '{new_track.name()}' moved to index {exr_index + 1}.&quot;)
        print(f&quot;Reordered video tracks: {[track.name() for track in reordered_tracks]}&quot;)
    except Exception as e:
        print(f&quot;Error while reordering tracks: {e}&quot;)
    finally:
        # Finalizar la acción de undo
        project.endUndo()

# Llamar a la función para crear y mover el nuevo track
create_and_move_new_track()
import hiero.core
import hiero.ui
import os

def copy_clip():
    # Obtener la secuencia activa en el timeline
    seq = hiero.ui.activeSequence()
    if not seq:
        print(&quot;No active sequence found.&quot;)
        return None

    # Obtener el timeline editor
    te = hiero.ui.getTimelineEditor(seq)
    selected_clips = te.selection()

    if len(selected_clips) == 0:
        print(&quot;*** No clips selected on the track ***&quot;)
        return None

    # Copiar el primer clip seleccionado (suponiendo que solo se selecciona uno)
    clip = selected_clips[0]
    if isinstance(clip, hiero.core.EffectTrackItem):
        print(f&quot;Ignored effect item: {clip.name()}&quot;)
        return None

    copied_clip = clip.copy()
    print(f&quot;Copied clip: {clip.name()}&quot;)
    return copied_clip, clip.timelineIn(), clip.timelineOut() - clip.timelineIn() + 1

def reorder_tracks_and_add_compare(seq):
    # Encontrar el índice del track llamado &quot;EXR&quot;
    exr_index = -1
    for index, track in enumerate(seq.videoTracks()):
        if track.name() == &quot;EXR&quot;:
            exr_index = index
            break

    if exr_index == -1:
        print(&quot;No se encontró un track llamado 'EXR'.&quot;)
        return None

    # Obtener la lista de todos los tracks de video
    video_tracks = list(seq.videoTracks())
    print(f&quot;Current video tracks: {[track.name() for track in video_tracks]}&quot;)

    # Remover todos los tracks
    for track in video_tracks:
        seq.removeTrack(track)

    # Crear el nuevo track llamado &quot;COMPARE&quot;
    compare_track = hiero.core.VideoTrack(&quot;COMPARE&quot;)

    # Reinsertar los tracks en el orden deseado, incluyendo el nuevo track antes de &quot;EXR&quot;
    reordered_tracks = video_tracks[:exr_index] + [compare_track] + video_tracks[exr_index:]
    for track in reordered_tracks:
        seq.addTrack(track)

    print(f&quot;Track 'COMPARE' added and moved to index {exr_index}.&quot;)
    print(f&quot;Reordered video tracks: {[track.name() for track in reordered_tracks]}&quot;)
    return compare_track

def paste_clip_to_compare(compare_track, copied_clip, start_time, duration):
    if not compare_track or not copied_clip:
        return

    # Pegar el clip en el track COMPARE
    compare_track.addItem(copied_clip)
    copied_clip.setTimelineIn(start_time)
    copied_clip.setTimelineOut(start_time + duration - 1)
    print(f&quot;Pasted clip '{copied_clip.name()}' to track COMPARE at start time {start_time}&quot;)

def toggle_blend_mode_for_exr(seq):
    # Volver a encontrar el track llamado &quot;EXR&quot; después de agregar el track &quot;COMPARE&quot;
    for track in seq.videoTracks():
        if track.name() == &quot;EXR&quot;:
            exr_track = track
            break
    else:
        print(&quot;No se encontró un track llamado 'EXR'.&quot;)
        return

    # Verificar si el blend mode ya está activado
    if exr_track.isBlendEnabled():
        # Si está activado, lo desactiva
        exr_track.setBlendEnabled(False)
        print(f&quot;Blend mode desactivado para el track 'EXR'.&quot;)
    else:
        # Si no está activado, lo activa y cambia el modo a &quot;Difference&quot;
        exr_track.setBlendEnabled(True)
        exr_track.setBlendMode(&quot;difference&quot;)
        print(f&quot;Blend mode 'Difference' activado para el track 'EXR'.&quot;)

def self_replace_clip(copied_clip):
    try:
        if isinstance(copied_clip, hiero.core.EffectTrackItem):
            print(f&quot;Ignored effect item: {copied_clip.name()}&quot;)
            return

        # Obtener el archivo original del clip copiado
        file_path = copied_clip.source().mediaSource().fileinfos()[0].filename()
        print(f&quot;Replacing clip with file: {file_path}&quot;)

        # Reemplazar el clip copiado con el archivo original
        copied_clip.replaceClips(file_path)
        print(f&quot;Clip replaced successfully with {file_path}.&quot;)
    except Exception as e:
        print(f&quot;Error replacing clip: {e}&quot;)

def main():
    # Obtener la secuencia activa en el timeline
    seq = hiero.ui.activeSequence()
    if not seq:
        print(&quot;No active sequence found.&quot;)
        return

    # Iniciar una acción de undo
    project = seq.project()
    project.beginUndo(&quot;Copy Clip, Reorder Tracks, Paste Clip to COMPARE, Set EXR to Difference, and Self Replace Clip&quot;)

    try:
        # Copiar el clip seleccionado
        copied_clip, start_time, duration = copy_clip()
        if not copied_clip:
            return

        # Reordenar los tracks y agregar el track COMPARE
        compare_track = reorder_tracks_and_add_compare(seq)
        if not compare_track:
            return

        # Pegar el clip copiado en el track COMPARE
        paste_clip_to_compare(compare_track, copied_clip, start_time, duration)
        
        # Cambiar el modo del track EXR a &quot;difference&quot;
        toggle_blend_mode_for_exr(seq)

        # Reemplazar el clip copiado en el track COMPARE con el archivo original
        self_replace_clip(copied_clip)
    except Exception as e:
        print(f&quot;Error during operation: {e}&quot;)
    finally:
        # Finalizar la acción de undo
        project.endUndo()

# Llamar a la función principal
main()
import hiero.core
import hiero.ui
import os

def copy_clip():
    # Obtener la secuencia activa en el timeline
    seq = hiero.ui.activeSequence()
    if not seq:
        print(&quot;No active sequence found.&quot;)
        return None

    # Obtener el timeline editor
    te = hiero.ui.getTimelineEditor(seq)
    selected_clips = te.selection()

    if len(selected_clips) == 0:
        print(&quot;*** No clips selected on the track ***&quot;)
        return None

    # Copiar el primer clip seleccionado (suponiendo que solo se selecciona uno)
    clip = selected_clips[0]
    if isinstance(clip, hiero.core.EffectTrackItem):
        print(f&quot;Ignored effect item: {clip.name()}&quot;)
        return None

    copied_clip = clip.copy()
    print(f&quot;Copied clip: {clip.name()}&quot;)
    return copied_clip, clip.timelineIn(), clip.timelineOut() - clip.timelineIn() + 1

def reorder_tracks_and_add_compare(seq):
    # Encontrar el índice del track llamado &quot;EXR&quot;
    exr_index = -1
    for index, track in enumerate(seq.videoTracks()):
        if track.name() == &quot;EXR&quot;:
            exr_index = index
            break

    if exr_index == -1:
        print(&quot;No se encontró un track llamado 'EXR'.&quot;)
        return None

    # Obtener la lista de todos los tracks de video
    video_tracks = list(seq.videoTracks())
    print(f&quot;Current video tracks: {[track.name() for track in video_tracks]}&quot;)

    # Remover todos los tracks
    for track in video_tracks:
        seq.removeTrack(track)

    # Crear el nuevo track llamado &quot;COMPARE&quot;
    compare_track = hiero.core.VideoTrack(&quot;COMPARE&quot;)

    # Reinsertar los tracks en el orden deseado, incluyendo el nuevo track antes de &quot;EXR&quot;
    reordered_tracks = video_tracks[:exr_index] + [compare_track] + video_tracks[exr_index:]
    for track in reordered_tracks:
        seq.addTrack(track)

    print(f&quot;Track 'COMPARE' added and moved to index {exr_index}.&quot;)
    print(f&quot;Reordered video tracks: {[track.name() for track in reordered_tracks]}&quot;)
    return compare_track

def paste_clip_to_compare(compare_track, copied_clip, start_time, duration):
    if not compare_track or not copied_clip:
        return

    # Pegar el clip en el track COMPARE
    compare_track.addItem(copied_clip)
    copied_clip.setTimelineIn(start_time)
    copied_clip.setTimelineOut(start_time + duration - 1)
    print(f&quot;Pasted clip '{copied_clip.name()}' to track COMPARE at start time {start_time}&quot;)

def toggle_blend_mode_for_exr(seq):
    # Volver a encontrar el track llamado &quot;EXR&quot; después de agregar el track &quot;COMPARE&quot;
    for track in seq.videoTracks():
        if track.name() == &quot;EXR&quot;:
            exr_track = track
            break
    else:
        print(&quot;No se encontró un track llamado 'EXR'.&quot;)
        return

    # Verificar si el blend mode ya está activado
    if exr_track.isBlendEnabled():
        # Si está activado, lo desactiva
        exr_track.setBlendEnabled(False)
        print(f&quot;Blend mode desactivado para el track 'EXR'.&quot;)
    else:
        # Si no está activado, lo activa y cambia el modo a &quot;Difference&quot;
        exr_track.setBlendEnabled(True)
        exr_track.setBlendMode(&quot;difference&quot;)
        print(f&quot;Blend mode 'Difference' activado para el track 'EXR'.&quot;)

def self_replace_clip(copied_clip):
    try:
        if isinstance(copied_clip, hiero.core.EffectTrackItem):
            print(f&quot;Ignored effect item: {copied_clip.name()}&quot;)
            return

        # Obtener el archivo original del clip copiado
        file_path = copied_clip.source().mediaSource().fileinfos()[0].filename()
        print(f&quot;Replacing clip with file: {file_path}&quot;)

        # Reemplazar el clip copiado con el archivo original
        copied_clip.replaceClips(file_path)
        print(f&quot;Clip replaced successfully with {file_path}.&quot;)
    except Exception as e:
        print(f&quot;Error replacing clip: {e}&quot;)

def main():
    # Obtener la secuencia activa en el timeline
    seq = hiero.ui.activeSequence()
    if not seq:
        print(&quot;No active sequence found.&quot;)
        return

    # Iniciar una acción de undo
    project = seq.project()
    project.beginUndo(&quot;Copy Clip, Reorder Tracks, Paste Clip to COMPARE, Set EXR to Difference, and Self Replace Clip&quot;)

    try:
        # Copiar el clip seleccionado
        copied_clip, start_time, duration = copy_clip()
        if not copied_clip:
            return

        # Reordenar los tracks y agregar el track COMPARE
        compare_track = reorder_tracks_and_add_compare(seq)
        if not compare_track:
            return

        # Pegar el clip copiado en el track COMPARE
        paste_clip_to_compare(compare_track, copied_clip, start_time, duration)
        
        # Cambiar el modo del track EXR a &quot;difference&quot;
        toggle_blend_mode_for_exr(seq)

        # Reemplazar el clip copiado en el track COMPARE con el archivo original
        self_replace_clip(copied_clip)
    except Exception as e:
        print(f&quot;Error during operation: {e}&quot;)
    finally:
        # Finalizar la acción de undo
        project.endUndo()

# Llamar a la función principal
main()
&quot;&quot;&quot;
_________________________________________________

  LGA_ReviewToolsPanel v2.2 - 2024 - Lega Pugliese
  Tools panel for Hiero / Nuke Studio
_________________________________________________

&quot;&quot;&quot;


import hiero.ui
import hiero.core
import os
import re
import subprocess
import socket
import PySide2, hiero
from PySide2.QtWidgets import *
from PySide2.QtGui import QIcon
from PySide2.QtCore import *
from PySide2 import QtWidgets, QtCore

# Variable global para activar o desactivar los prints
DEBUG = True

def debug_print(*message):
    if DEBUG:
        print(*message)

class ReconnectMediaWidget(QWidget):
    def __init__(self):
        super(ReconnectMediaWidget, self).__init__()

        self.setObjectName(&quot;com.lega.RevtoolPanel&quot;)
        self.setWindowTitle(&quot;Review&quot;)
        self.setStyleSheet(&quot;QToolTip { color: #ffffff; background-color: #2a2a2a; border: 1px solid white; }&quot;)

        self.layout = QGridLayout(self)  # Usamos QGridLayout en lugar de QVBoxLayout
        self.setLayout(self.layout)

        # Crear botones y agregarlos al layout
        self.buttons = [
            (&quot;Self ReplaceClip&quot;, self.SelfReaplaceClip, &quot;#191f28&quot;),
            (&quot;Compare Versions&quot;, self.run_compare_versions, &quot;#191f28&quot;),
            (&quot;EXR Track Difference&quot;, self.toggle_blend_mode_for_exr_track, &quot;#191f28&quot;),
            (&quot;ON Clips | OFF v00&quot;, self.enable_or_disable_clips, &quot;#191f28&quot;), 
            (&quot;Rec709 | &amp;Viewer&quot;, self.rec709_viewer, &quot;#191f28&quot;, &quot;Shift+V&quot;, &quot;Shift+V&quot;),
            (&quot;Reveal in &amp;Explorer&quot;, self.reveal_in_explorer, &quot;#261e1a&quot;, &quot;Shift+E&quot;, &quot;Shift+E&quot;),
            (&quot;Reveal NKS Project&quot;, self.reveal_project, &quot;#261e1a&quot;),
            (&quot;Reveal NK Sc&amp;ript&quot;, self.reveal_script, &quot;#261e1a&quot;, &quot;Shift+R&quot;, &quot;Shift+R&quot;),
            (&quot;OpenInNuke&amp;X&quot;, self.open_in_nukex_main, &quot;#212b1f&quot;, &quot;Shift+X&quot;, &quot;Shift+X&quot;)
        ]


        self.num_columns = 1  # Inicialmente una columna
        self.create_buttons()

        # Conectar la señal de cambio de tamaño del widget al método correspondiente
        self.adjust_columns_on_resize()
        self.resizeEvent = self.adjust_columns_on_resize

    def create_buttons(self):
        for index, button_info in enumerate(self.buttons):
            name = button_info[0]
            handler = button_info[1]
            style = button_info[2]
            shortcut = button_info[3] if len(button_info) &gt; 3 else None
            tooltip = button_info[4] if len(button_info) &gt; 4 else None

            button = QPushButton(name)
            button.setStyleSheet(f&quot;background-color: {style}&quot;)
            button.clicked.connect(handler)
            if shortcut:
                button.setShortcut(shortcut)
            if tooltip:
                button.setToolTip(tooltip)

            row = index // self.num_columns
            column = index % self.num_columns
            self.layout.addWidget(button, row, column)

    def adjust_columns_on_resize(self, event=None):
        # Obtener el ancho actual del widget
        panel_width = self.width()
        button_width = 120  # Ancho aproximado de cada botón
        min_button_spacing = 10  # Espacio mínimo entre botones

        # Calcular el número de columnas en función del ancho del widget
        self.num_columns = max(1, (panel_width + min_button_spacing) // (button_width + min_button_spacing))

        # Limpiar el layout actual y eliminar widgets solo si existen
        while self.layout.count():
            item = self.layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

        # Volver a crear los botones con el nuevo número de columnas
        self.create_buttons()

        # Calcular el número de filas usadas
        num_rows = (len(self.buttons) + self.num_columns - 1) // self.num_columns

        # Añadir el espaciador vertical
        spacer = QSpacerItem(20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding)
        self.layout.addItem(spacer, num_rows, 0, 1, self.num_columns)



#### SelfReaplaceClip
    def get_full_bin_path(self, bin_item):
        path = []
        while bin_item:
            if isinstance(bin_item, hiero.core.Bin):
                path.append(bin_item.name())
            bin_item = bin_item.parentBin() if hasattr(bin_item, 'parentBin') else None
        return '/'.join(reversed(path))

    def find_or_create_bin(self, project, bin_path):
        &quot;&quot;&quot;
        Encuentra un bin existente o crea uno nuevo si no existe.

        Args:
        - project (hiero.core.Project): El proyecto actual en Hiero.
        - bin_path (str): La ruta del bin.

        Returns:
        - hiero.core.Bin: El bin encontrado o creado.
        &quot;&quot;&quot;
        # Dividir la ruta en partes
        bin_names = bin_path.split('/')

        # Empezar desde el bin de clips
        current_bin = project.clipsBin()

        # Iterar sobre las partes de la ruta
        for bin_name in bin_names:
            found_bin = None
            # Buscar el bin actual por su nombre
            for item in current_bin.items():
                if isinstance(item, hiero.core.Bin) and item.name() == bin_name:
                    found_bin = item
                    break
            # Si no se encontró el bin, crear uno nuevo
            if not found_bin:
                found_bin = hiero.core.Bin(bin_name)
                current_bin.addItem(found_bin)
            current_bin = found_bin

        return current_bin

    def move_clip_to_bin(self, project, clip_name, source_bin_name, target_bin_path, shot):
        &quot;&quot;&quot;
        Mueve un clip de un bin de origen a un bin de destino en el proyecto.

        Args:
        - project (hiero.core.Project): El proyecto actual en Hiero.
        - clip_name (str): El nombre del clip que se moverá.
        - source_bin_name (str): El nombre del bin de origen que contiene el clip.
        - target_bin_path (str): La ruta del bin de destino donde se moverá el clip.
        &quot;&quot;&quot;
        # Buscar el bin de origen por su nombre
        source_bin = None
        for bin_item in project.clipsBin().items():
            if bin_item.name() == source_bin_name:
                source_bin = bin_item
                break

        if source_bin:
            # Buscar el clip por su nombre dentro del bin de origen
            clip_to_move = None
            for clip_item in source_bin.items():
                if clip_item.name() == clip_name:
                    clip_to_move = clip_item
                    break

            if clip_to_move:
                # Encontrar o crear el bin de destino
                target_bin = self.find_or_create_bin(project, target_bin_path)

                # Remover el clip del bin de origen
                source_bin.removeItem(clip_to_move)

                # Remover el clip del bin original (no me está funcionando)
                original_bin_item = shot.source().binItem()
                original_bin = original_bin_item.parentBin()
                #original_bin.removeItem(original_bin_item)    
                
                # Agregar el clip al bin de destino
                target_bin.addItem(clip_to_move)
                debug_print(&quot;Se movió el clip '{}' del bin '{}' al bin '{}'.&quot;.format(clip_name, source_bin_name, target_bin_path))
            else:
                debug_print(&quot;No se encontró el clip '{}' en el bin de origen '{}'.&quot;.format(clip_name, source_bin_name))
        else:
            debug_print(&quot;No se encontró el bin de origen '{}'.&quot;.format(source_bin_name))

    def SelfReaplaceClip(self):
        # Obtener el proyecto actual en Hiero
        project = hiero.core.projects()[0] if hiero.core.projects() else None
        try:
            seq = hiero.ui.activeSequence()
            if not seq:
                debug_print(&quot;No active sequence found.&quot;)
                return

            te = hiero.ui.getTimelineEditor(seq)
            selected_clips = te.selection()
            project = hiero.core.projects()[0]
            project.beginUndo(&quot;Change Clip Color&quot;)

            if len(selected_clips) == 0:
                debug_print(&quot;*** No clips selected on the track ***&quot;)
            else:


                for shot in selected_clips:
                    if isinstance(shot, hiero.core.EffectTrackItem):  # Verificar si es un efecto
                        debug_print(f&quot;Ignore effect item: {shot.name()}&quot;)
                    else:            
                    
                        file_path = shot.source().mediaSource().fileinfos()[0].filename()
                        debug_print(&quot;File path:&quot;, file_path)

                        bin_item = shot.source().binItem()
                        full_bin_path = self.get_full_bin_path(bin_item)
                        full_bin_path = full_bin_path.replace(&quot;Sequences/&quot;, &quot;&quot;)
                        debug_print(&quot;Full bin path for the clip:&quot;, full_bin_path)

                        try:
                            shot.replaceClips(file_path)
                            debug_print(&quot;Clip replaced successfully.&quot;)
                        except:
                            debug_print(&quot;Error replacing clip.&quot;)


                        
                        new_clip_name = shot.source().name()
                        debug_print(f&quot;Clip name: {new_clip_name}&quot;)

                        conform_bin_name = &quot;Conform&quot;
                        original_bin_name = full_bin_path.split(' &gt; ')[-1]
                        self.move_clip_to_bin(project, new_clip_name, conform_bin_name, full_bin_path, shot)


            project.endUndo()
        except Exception as e:
            debug_print(f&quot;Error during operation: {e}&quot;)


##### Compare Versions
def run_compare_versions(self):
    try:
        script_path = os.path.join(os.path.dirname(__file__), 'LGA_NKS', 'LGA_NKS_Compare.py')
        if os.path.exists(script_path):
            import importlib.util
            spec = importlib.util.spec_from_file_location(&quot;LGA_NKS_Compare&quot;, script_path)
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
        else:
            debug_print(f&quot;Script not found at path: {script_path}&quot;)
    except Exception as e:
        debug_print(f&quot;Error during running compare script: {e}&quot;)


##### ON Clips | OFF v00
    def enable_or_disable_clips(self):
        try:
            seq = hiero.ui.activeSequence()
            if seq:
                te = hiero.ui.getTimelineEditor(seq)
                selected_items = te.selection()
                if selected_items:
                    for item in selected_items:
                        if not isinstance(item, hiero.core.EffectTrackItem):
                            file_path = item.source().mediaSource().fileinfos()[0].filename() if item.source().mediaSource().fileinfos() else None
                            if file_path and '_comp_' in os.path.basename(file_path).lower():
                                if re.search(r'_comp_v00', os.path.basename(file_path).lower()):
                                    item.setEnabled(False)
                                else:
                                    item.setEnabled(True)
                            else:
                                item.setEnabled(True)
                else:
                    debug_print(&quot;No clips selected on the timeline.&quot;)
            else:
                debug_print(&quot;No active sequence found in Hiero.&quot;)
        except Exception as e:
            debug_print(f&quot;Error during operation: {e}&quot;)


##### Rec 709 en viewer
    def rec709_viewer(self):
        hiero.ui.currentViewer().player().setLUT('ACES/Rec.709')
        

##### Reveal in explorer
    def open_file_explorer(self, path):
        if os.name == 'nt':  # Windows
            os.startfile(os.path.dirname(path))
        elif os.name == 'posix':  # macOS
            subprocess.Popen(['open', os.path.dirname(path)])
        else:
            debug_print(&quot;Unsupported OS&quot;)


    def reveal_in_explorer(self):
        try:
            seq = hiero.ui.activeSequence()
            if not seq:
                debug_print(&quot;No active sequence found.&quot;)
                return

            te = hiero.ui.getTimelineEditor(seq)
            selected_clips = te.selection()

            if len(selected_clips) == 0:
                debug_print(&quot;*** No clips selected on the track ***&quot;)
                self.reveal_project()
            else:
                for shot in selected_clips:
                    if isinstance(shot, hiero.core.EffectTrackItem):  # Verificar si es un efecto
                        pass  
                    else:
                        # Obtener el file path del clip seleccionado
                        file_path = shot.source().mediaSource().fileinfos()[0].filename()
                        debug_print(f&quot;Original file path: {file_path}&quot;)
                        self.open_file_explorer(file_path)
        except Exception as e:
            debug_print(f&quot;Error: {e}&quot;)


    def get_active_project(self):
        &quot;&quot;&quot;
        Obtiene el proyecto activo en Hiero.

        Returns:
        - hiero.core.Project o None: El proyecto activo, o None si no se encuentra ningún proyecto activo.
        &quot;&quot;&quot;
        projects = hiero.core.projects()
        if projects:
            return projects[0]  # Devuelve el primer proyecto en la lista
        else:
            return None


##### Reveal 
    def reveal_project(self):
        # Obtener el proyecto activo
        project = self.get_active_project()
        if project:
            # Obtener el directorio del proyecto activo
            project_path = project.path()

            # Imprimir el directorio del proyecto activo
            debug_print(f&quot;El directorio del proyecto activo es: {project_path}&quot;)
            self.open_file_explorer(project_path)
        else:
            debug_print(&quot;No se encontró un proyecto activo en Hiero.&quot;)


    def reveal_script(self):
        try:
            seq = hiero.ui.activeSequence()
            if not seq:
                debug_print(&quot;No active sequence found.&quot;)
                return

            te = hiero.ui.getTimelineEditor(seq)
            selected_clips = te.selection()

            if len(selected_clips) == 0:
                debug_print(&quot;*** No clips selected on the track ***&quot;)
            else:
                for shot in selected_clips:
                    if isinstance(shot, hiero.core.EffectTrackItem):  # Verificar si es un efecto
                        pass  
                    else:
                        # Obtener el file path del clip seleccionado
                        file_path = shot.source().mediaSource().fileinfos()[0].filename()
                        debug_print(f&quot;Original file path: {file_path}&quot;)

                        # Obtener la nueva ruta del proyecto
                        project_path = self.get_project_path(file_path)
                        
                        # Asegurarnos de que la ruta termina con '/'
                        if not project_path.endswith('/'):
                            project_path += '/'
                        
                        debug_print(f&quot;Project path: {project_path}&quot;)

                        # Abre el explorador de archivos en la nueva ruta del proyecto
                        self.open_file_explorer(project_path)
        except Exception as e:
            debug_print(f&quot;Error: {e}&quot;)


            

##### OpenInNukeX
    def open_in_nukex_main(self):
        seq = hiero.ui.activeSequence()
        if not seq:
            debug_print(&quot;No active sequence found.&quot;)
            self.show_message(&quot;Error&quot;, &quot;No active sequence found.&quot;)
            return

        te = hiero.ui.getTimelineEditor(seq)
        selected_clips = te.selection()

        if len(selected_clips) == 0:
            debug_print(&quot;*** No clips selected on the track ***&quot;)
            self.show_message(&quot;Error&quot;, &quot;No clips selected.&quot;)
            return

        for shot in selected_clips:
            if isinstance(shot, hiero.core.EffectTrackItem):
                continue  # Ignorar si es un efecto
            try:
                file_path = shot.source().mediaSource().fileinfos()[0].filename()
                project_path = self.get_project_path(file_path)
                script_name = self.get_script_name(file_path)
                script_full_path = os.path.join(project_path, script_name)

                # Verificar si el archivo existe y abrir en Nuke si es así
                if os.path.exists(script_full_path):
                    self.open_nuke_script(script_full_path)
                else:
                    formatted_message = &quot;&lt;div style='text-align: left;'&gt;&lt;b&gt;File not found&lt;/b&gt;&lt;br&gt;&lt;br&gt;&quot; + script_full_path + &quot;&lt;/div&gt;&quot;
                    self.show_message(&quot;Error&quot;, formatted_message)
                return  # Salir después de abrir el script
            except AttributeError as e:
                debug_print(f&quot;Clip does not have a valid source: {e}&quot;)
        
        self.show_message(&quot;Error&quot;, &quot;No valid clip found.&quot;)



    def show_message(self, title, message, duration=None):
        msgBox = QtWidgets.QMessageBox()
        msgBox.setWindowTitle(title)
        # Interpretar el mensaje como HTML si incluye etiquetas, de lo contrario como texto normal
        if '&lt;' in message and '&gt;' in message:
            msgBox.setTextFormat(QtCore.Qt.TextFormat.RichText)  # Interpretar como HTML
        else:
            msgBox.setTextFormat(QtCore.Qt.TextFormat.PlainText)  # Interpretar como texto normal
        msgBox.setText(message)
        msgBox.setStandardButtons(QtWidgets.QMessageBox.Ok)
        if duration:
            QtCore.QTimer.singleShot(duration, msgBox.close)
        msgBox.exec_()

    def show_timed_message(sef, title, message, duration):
        msgBox = TimedMessageBox(title, message, duration)
        msgBox.exec_()

    # Función para obtener la ruta del proyecto
    def get_project_path(self, file_path):
        # Dividir el path en partes usando '/' como separador
        path_parts = file_path.split('/')
        # Construir la nueva ruta agregando '/Comp/1_projects'
        project_path = '/'.join(path_parts[:4]) + '/Comp/1_projects'
        return project_path

    # Función para obtener el nombre del archivo del script relacionado con el clip
    def get_script_name(self, file_path):
        # Extraer el nombre del archivo del path completo
        script_name = os.path.basename(file_path)
        # Eliminar la extensión y cualquier secuencia de frame como %04d
        script_name = re.sub(r'_%\d+?d\.exr$', '', script_name)  # Ajusta la expresión regular según necesidad
        return script_name + '.nk'  # Añadir la extensión correcta de Nuke

    # Función para abrir Nuke Studio o NukeX si la conexión falla
    def open_nuke_script(self, nk_filepath):
        host = 'localhost'
        port = 54325
        nuke_path = &quot;C:/Program Files/Nuke15.0v4/Nuke15.0.exe&quot;

        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(10)
                s.connect((host, port))
                # Enviar un comando 'ping'
                s.sendall(&quot;ping&quot;.encode())
                # Esperar una respuesta para confirmar que NukeX está operativo
                response = s.recv(1024).decode()
                if &quot;pong&quot; in response:
                    debug_print(&quot;NukeX is active and responding.&quot;)
                    # Cerrar el socket anterior y abrir uno nuevo para enviar el comando de ejecución
                    s.close()
                    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as new_socket:
                        new_socket.connect((host, port))
                        normalized_path = os.path.normpath(nk_filepath).replace('\\', '/')
                        full_command = f&quot;run_script||{normalized_path}&quot;
                        new_socket.sendall(full_command.encode())
                        self.show_timed_message(
                            &quot;OpenInNukeX&quot;, 
                            (
                                f&quot;&lt;div style='text-align: center;'&gt;&quot;
                                f&quot;&lt;span&gt;Opening&lt;/span&gt;&lt;br&gt;&quot;
                                f&quot;&lt;span style='font-style: italic; color: #9f9f9f; font-size: 0.9em;'&gt;{os.path.basename(nk_filepath)}&lt;/span&gt;&lt;br&gt;&lt;br&gt;&quot;
                                f&quot;&lt;span style='color:white;'&gt;Please switch to the NukeX window...&lt;/span&gt;&quot;
                                f&quot;&lt;/div&gt;&quot;
                            ),
                            5000
                        )
                        return

                else:
                    raise Exception(&quot;NukeX is not responding as expected.&quot;)
        except (socket.timeout, ConnectionRefusedError, Exception) as e:
            # Si no se puede establecer la conexión o no se recibe la respuesta esperada, intentar abrir NukeX directamente
            command = f'&quot;{nuke_path}&quot; --nukex &quot;{nk_filepath}&quot;'
            subprocess.Popen(command, shell=True)
            self.show_timed_message(
                &quot;Error&quot;, 
                (
                    f&quot;&lt;span style='color:white;'&gt;&lt;b&gt;Failed to connect to NukeX&lt;/b&gt;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&quot;
                    f&quot;Opening a new NukeX instance&lt;br&gt;&quot;
                    f&quot;&lt;span style='font-style: italic; color: #9f9f9f; font-size: 0.9em;'&gt;{nuke_path}&lt;/span&gt;&quot;
                ), 
                5000
            )
        except ConnectionResetError:
            self.show_message(&quot;Error&quot;, &quot;The connection was closed by the server.&quot;)


##### Difference mode in track
    def toggle_blend_mode_for_exr_track(self):
        # Obtiene la secuencia activa
        seq = hiero.ui.activeSequence()
        
        if not seq:
            debug_print(&quot;No hay una secuencia activa.&quot;)
            return
        
        # Itera sobre los tracks de video para encontrar el que se llama &quot;EXR&quot;
        for index, track in enumerate(seq.videoTracks()):
            if track.name() == &quot;EXR&quot;:
                # Verifica si el blend mode ya está activado
                if track.isBlendEnabled():
                    # Si está activado, lo desactiva
                    track.setBlendEnabled(False)
                    debug_print(f&quot;Blend mode desactivado para el track 'EXR' en el índice: {index}&quot;)
                else:
                    # Si no está activado, lo activa y cambia el modo a &quot;Difference&quot;
                    track.setBlendEnabled(True)
                    track.setBlendMode(&quot;difference&quot;)
                    debug_print(f&quot;Blend mode 'Difference' activado para el track 'EXR' en el índice: {index}&quot;)
                break
        else:
            debug_print(&quot;No se encontró un track llamado 'EXR'.&quot;)


##### Clase para OpenInNukeX
class TimedMessageBox(QtWidgets.QMessageBox):
    def __init__(self, title, message, duration):
        super().__init__()
        self.setWindowTitle(title)
        self.setText(message)
        self.setStandardButtons(QtWidgets.QMessageBox.Ok)

        self.timer = QtCore.QTimer(self)
        self.timer.timeout.connect(self.updateButton)
        self.timeLeft = duration // 1000  # Convert milliseconds to seconds
        self.timer.start(1000)  # Update every second

        self.updateButton()  # Initialize the button text

    def updateButton(self):
        if self.timeLeft &gt; 0:
            self.button(QtWidgets.QMessageBox.Ok).setText(f&quot;OK ({self.timeLeft})&quot;)
            self.timeLeft -= 1
        else:
            self.timer.stop()
            self.accept()  # Close the message box automatically


# Crear la instancia del widget y añadirlo al gestor de ventanas de Hiero
reconnectWidget = ReconnectMediaWidget()
wm = hiero.ui.windowManager()
wm.addWindow(reconnectWidget)
import hiero.core
import hiero.ui
from PySide2.QtGui import QColor

def copy_clip():
    # Obtener la secuencia activa en el timeline
    seq = hiero.ui.activeSequence()
    if not seq:
        print(&quot;No active sequence found.&quot;)
        return None

    # Obtener el timeline editor
    te = hiero.ui.getTimelineEditor(seq)
    selected_clips = te.selection()

    if len(selected_clips) == 0:
        print(&quot;*** No clips selected on the track ***&quot;)
        return None

    # Copiar el primer clip seleccionado (suponiendo que solo se selecciona uno)
    clip = selected_clips[0]
    if isinstance(clip, hiero.core.EffectTrackItem):
        print(f&quot;Ignored effect item: {clip.name()}&quot;)
        return None

    copied_clip = clip.copy()
    print(f&quot;Copied clip: {clip.name()}&quot;)
    return copied_clip, clip.timelineIn(), clip.timelineOut() - clip.timelineIn() + 1

def reorder_tracks_and_add_compare(seq):
    # Encontrar el índice del track llamado &quot;EXR&quot;
    exr_index = -1
    for index, track in enumerate(seq.videoTracks()):
        if track.name() == &quot;EXR&quot;:
            exr_index = index
            break

    if exr_index == -1:
        print(&quot;No se encontró un track llamado 'EXR'.&quot;)
        return None

    # Obtener la lista de todos los tracks de video
    video_tracks = list(seq.videoTracks())
    print(f&quot;Current video tracks: {[track.name() for track in video_tracks]}&quot;)

    # Remover todos los tracks
    for track in video_tracks:
        seq.removeTrack(track)

    # Crear el nuevo track llamado &quot;COMPARE&quot;
    compare_track = hiero.core.VideoTrack(&quot;COMPARE&quot;)

    # Reinsertar los tracks en el orden deseado, incluyendo el nuevo track antes de &quot;EXR&quot;
    reordered_tracks = video_tracks[:exr_index] + [compare_track] + video_tracks[exr_index:]
    for track in reordered_tracks:
        seq.addTrack(track)

    print(f&quot;Track 'COMPARE' added and moved to index {exr_index}.&quot;)
    print(f&quot;Reordered video tracks: {[track.name() for track in reordered_tracks]}&quot;)
    return compare_track

def paste_clip_to_compare(compare_track, copied_clip, start_time, duration):
    if not compare_track or not copied_clip:
        return

    # Pegar el clip en el track COMPARE
    compare_track.addItem(copied_clip)
    copied_clip.setTimelineIn(start_time)
    copied_clip.setTimelineOut(start_time + duration - 1)
    print(f&quot;Pasted clip '{copied_clip.name()}' to track COMPARE at start time {start_time}&quot;)

def toggle_blend_mode_for_exr(seq):
    # Volver a encontrar el track llamado &quot;EXR&quot; después de agregar el track &quot;COMPARE&quot;
    for track in seq.videoTracks():
        if track.name() == &quot;EXR&quot;:
            exr_track = track
            break
    else:
        print(&quot;No se encontró un track llamado 'EXR'.&quot;)
        return

    # Verificar si el blend mode ya está activado
    if exr_track.isBlendEnabled():
        # Si está activado, lo desactiva
        exr_track.setBlendEnabled(False)
        print(f&quot;Blend mode desactivado para el track 'EXR'.&quot;)
    else:
        # Si no está activado, lo activa y cambia el modo a &quot;Difference&quot;
        exr_track.setBlendEnabled(True)
        exr_track.setBlendMode(&quot;difference&quot;)
        print(f&quot;Blend mode 'Difference' activado para el track 'EXR'.&quot;)

def self_replace_clip(copied_clip):
    try:
        if isinstance(copied_clip, hiero.core.EffectTrackItem):
            print(f&quot;Ignored effect item: {copied_clip.name()}&quot;)
            return

        # Obtener el archivo original del clip copiado
        file_path = copied_clip.source().mediaSource().fileinfos()[0].filename()
        print(f&quot;Replacing clip with file: {file_path}&quot;)

        # Reemplazar el clip copiado con el archivo original
        copied_clip.replaceClips(file_path)
        print(f&quot;Clip replaced successfully with {file_path}.&quot;)
    except Exception as e:
        print(f&quot;Error replacing clip: {e}&quot;)

def downgrade_clip_version(clip):
    def get_all_versions(binItem):
        versions = binItem.items()
        return sorted(versions, key=lambda v: int(v.name().split('_v')[-1]))

    bin_item = clip.source().binItem()
    if clip.source().mediaSource().isMediaPresent():
        versions = get_all_versions(bin_item)
        if versions:
            current_version = bin_item.activeVersion()
            current_version_index = versions.index(current_version)
            
            if current_version_index &gt; 0:
                previous_version = versions[current_version_index - 1]
                bin_item.setActiveVersion(previous_version)
                print(f&quot;Changed {clip.name()} to version {previous_version.name()}&quot;)
            else:
                print(f&quot;{clip.name()} is already at the oldest version available.&quot;)
        else:
            print(f&quot;No versions found for clip: {clip.name()}&quot;)
    else:
        print(f&quot;No media present for clip: {clip.name()}&quot;)

def main():
    # Obtener la secuencia activa en el timeline
    seq = hiero.ui.activeSequence()
    if not seq:
        print(&quot;No active sequence found.&quot;)
        return

    # Iniciar una acción de undo para las primeras operaciones
    project = seq.project()
    project.beginUndo(&quot;Copy Clip, Reorder Tracks, Paste Clip to COMPARE, Set EXR to Difference, and Downgrade Version&quot;)

    try:
        # Copiar el clip seleccionado
        copied_clip, start_time, duration = copy_clip()
        if not copied_clip:
            return

        # Reordenar los tracks y agregar el track COMPARE
        compare_track = reorder_tracks_and_add_compare(seq)
        if not compare_track:
            return

        # Pegar el clip copiado en el track COMPARE
        paste_clip_to_compare(compare_track, copied_clip, start_time, duration)
        
        # Cambiar el modo del track EXR a &quot;difference&quot;
        toggle_blend_mode_for_exr(seq)

        # Bajar una versión del clip copiado
        downgrade_clip_version(copied_clip)
    except Exception as e:
        print(f&quot;Error during operation: {e}&quot;)
    finally:
        # Finalizar la primera acción de undo
        project.endUndo()

    # Iniciar una nueva acción de undo para el self replace clip
    project.beginUndo(&quot;Self Replace Clip&quot;)
    try:
        # Reemplazar el clip copiado en el track COMPARE con el archivo original
        self_replace_clip(copied_clip)
    except Exception as e:
        print(f&quot;Error during self replace clip: {e}&quot;)
    finally:
        # Finalizar la segunda acción de undo
        project.endUndo()

# Llamar a la función principal
main()
import hiero.core
import hiero.ui
from PySide2.QtGui import QColor

def copy_clip():
    # Obtener la secuencia activa en el timeline
    seq = hiero.ui.activeSequence()
    if not seq:
        print(&quot;No active sequence found.&quot;)
        return None

    # Obtener el timeline editor
    te = hiero.ui.getTimelineEditor(seq)
    selected_clips = te.selection()

    if len(selected_clips) == 0:
        print(&quot;*** No clips selected on the track ***&quot;)
        return None

    # Copiar el primer clip seleccionado (suponiendo que solo se selecciona uno)
    clip = selected_clips[0]
    if isinstance(clip, hiero.core.EffectTrackItem):
        print(f&quot;Ignored effect item: {clip.name()}&quot;)
        return None

    copied_clip = clip.copy()
    print(f&quot;Copied clip: {clip.name()}&quot;)
    return copied_clip, clip.timelineIn(), clip.timelineOut() - clip.timelineIn() + 1

def reorder_tracks_and_add_compare(seq):
    # Encontrar el índice del track llamado &quot;EXR&quot;
    exr_index = -1
    for index, track in enumerate(seq.videoTracks()):
        if track.name() == &quot;EXR&quot;:
            exr_index = index
            break

    if exr_index == -1:
        print(&quot;No se encontró un track llamado 'EXR'.&quot;)
        return None

    # Obtener la lista de todos los tracks de video
    video_tracks = list(seq.videoTracks())
    print(f&quot;Current video tracks: {[track.name() for track in video_tracks]}&quot;)

    # Remover todos los tracks
    for track in video_tracks:
        seq.removeTrack(track)

    # Crear el nuevo track llamado &quot;COMPARE&quot;
    compare_track = hiero.core.VideoTrack(&quot;COMPARE&quot;)

    # Reinsertar los tracks en el orden deseado, incluyendo el nuevo track antes de &quot;EXR&quot;
    reordered_tracks = video_tracks[:exr_index] + [compare_track] + video_tracks[exr_index:]
    for track in reordered_tracks:
        seq.addTrack(track)

    print(f&quot;Track 'COMPARE' added and moved to index {exr_index}.&quot;)
    print(f&quot;Reordered video tracks: {[track.name() for track in reordered_tracks]}&quot;)
    return compare_track

def paste_clip_to_compare(compare_track, copied_clip, start_time, duration):
    if not compare_track or not copied_clip:
        return

    # Pegar el clip en el track COMPARE
    compare_track.addItem(copied_clip)
    copied_clip.setTimelineIn(start_time)
    copied_clip.setTimelineOut(start_time + duration - 1)
    print(f&quot;Pasted clip '{copied_clip.name()}' to track COMPARE at start time {start_time}&quot;)

def toggle_blend_mode_for_exr(seq):
    # Volver a encontrar el track llamado &quot;EXR&quot; después de agregar el track &quot;COMPARE&quot;
    for track in seq.videoTracks():
        if track.name() == &quot;EXR&quot;:
            exr_track = track
            break
    else:
        print(&quot;No se encontró un track llamado 'EXR'.&quot;)
        return

    # Verificar si el blend mode ya está activado
    if exr_track.isBlendEnabled():
        # Si está activado, lo desactiva
        exr_track.setBlendEnabled(False)
        print(f&quot;Blend mode desactivado para el track 'EXR'.&quot;)
    else:
        # Si no está activado, lo activa y cambia el modo a &quot;Difference&quot;
        exr_track.setBlendEnabled(True)
        exr_track.setBlendMode(&quot;difference&quot;)
        print(f&quot;Blend mode 'Difference' activado para el track 'EXR'.&quot;)

def self_replace_clip(copied_clip):
    try:
        if isinstance(copied_clip, hiero.core.EffectTrackItem):
            print(f&quot;Ignored effect item: {copied_clip.name()}&quot;)
            return

        # Obtener el archivo original del clip copiado
        file_path = copied_clip.source().mediaSource().fileinfos()[0].filename()
        print(f&quot;Replacing clip with file: {file_path}&quot;)

        # Reemplazar el clip copiado con el archivo original
        copied_clip.replaceClips(file_path)
        print(f&quot;Clip replaced successfully with {file_path}.&quot;)
    except Exception as e:
        print(f&quot;Error replacing clip: {e}&quot;)

def downgrade_clip_version(clip):
    def get_all_versions(binItem):
        versions = binItem.items()
        return sorted(versions, key=lambda v: int(v.name().split('_v')[-1]))

    bin_item = clip.source().binItem()
    if clip.source().mediaSource().isMediaPresent():
        versions = get_all_versions(bin_item)
        if versions:
            current_version = bin_item.activeVersion()
            current_version_index = versions.index(current_version)
            
            if current_version_index &gt; 0:
                previous_version = versions[current_version_index - 1]
                bin_item.setActiveVersion(previous_version)
                print(f&quot;Changed {clip.name()} to version {previous_version.name()}&quot;)
            else:
                print(f&quot;{clip.name()} is already at the oldest version available.&quot;)
        else:
            print(f&quot;No versions found for clip: {clip.name()}&quot;)
    else:
        print(f&quot;No media present for clip: {clip.name()}&quot;)

def main():
    # Obtener la secuencia activa en el timeline
    seq = hiero.ui.activeSequence()
    if not seq:
        print(&quot;No active sequence found.&quot;)
        return

    # Iniciar una acción de undo para las primeras operaciones
    project = seq.project()
    project.beginUndo(&quot;Copy Clip, Reorder Tracks, Paste Clip to COMPARE, and Set EXR to Difference&quot;)

    try:
        # Copiar el clip seleccionado
        copied_clip, start_time, duration = copy_clip()
        if not copied_clip:
            return

        # Guardar el clip original antes de copiarlo
        original_clip = hiero.ui.getTimelineEditor(seq).selection()[0]

        # Reordenar los tracks y agregar el track COMPARE
        compare_track = reorder_tracks_and_add_compare(seq)
        if not compare_track:
            return

        # Pegar el clip copiado en el track COMPARE
        paste_clip_to_compare(compare_track, copied_clip, start_time, duration)
        
        # Cambiar el modo del track EXR a &quot;difference&quot;
        toggle_blend_mode_for_exr(seq)
    except Exception as e:
        print(f&quot;Error during operation: {e}&quot;)
    finally:
        # Finalizar la primera acción de undo
        project.endUndo()

    # Iniciar una nueva acción de undo para el self replace clip
    project.beginUndo(&quot;Self Replace Clip&quot;)
    try:
        # Reemplazar el clip copiado en el track COMPARE con el archivo original
        self_replace_clip(copied_clip)
    except Exception as e:
        print(f&quot;Error during self replace clip: {e}&quot;)
    finally:
        # Finalizar la segunda acción de undo
        project.endUndo()

    # Iniciar una nueva acción de undo para bajar la versión del clip original
    project.beginUndo(&quot;Downgrade Original Clip Version&quot;)
    try:
        # Bajar una versión del clip original
        downgrade_clip_version(original_clip)
    except Exception as e:
        print(f&quot;Error during downgrade clip version: {e}&quot;)
    finally:
        # Finalizar la tercera acción de undo
        project.endUndo()

# Llamar a la función principal
main()

# Llamar a la función principal
main()
import hiero.core
import hiero.ui
from PySide2.QtGui import QColor

def copy_clip():
    # Obtener la secuencia activa en el timeline
    seq = hiero.ui.activeSequence()
    if not seq:
        print(&quot;No active sequence found.&quot;)
        return None

    # Obtener el timeline editor
    te = hiero.ui.getTimelineEditor(seq)
    selected_clips = te.selection()

    if len(selected_clips) == 0:
        print(&quot;*** No clips selected on the track ***&quot;)
        return None

    # Copiar el primer clip seleccionado (suponiendo que solo se selecciona uno)
    clip = selected_clips[0]
    if isinstance(clip, hiero.core.EffectTrackItem):
        print(f&quot;Ignored effect item: {clip.name()}&quot;)
        return None

    copied_clip = clip.copy()
    print(f&quot;Copied clip: {clip.name()}&quot;)
    return copied_clip, clip.timelineIn(), clip.timelineOut() - clip.timelineIn() + 1

def reorder_tracks_and_add_compare(seq):
    # Verificar si ya existe un track llamado &quot;COMPARE&quot;
    compare_track = None
    for track in seq.videoTracks():
        if track.name() == &quot;COMPARE&quot;:
            compare_track = track
            break

    # Si no existe un track llamado &quot;COMPARE&quot;, encontrar el índice del track &quot;EXR&quot; y crear &quot;COMPARE&quot;
    if not compare_track:
        exr_index = -1
        for index, track in enumerate(seq.videoTracks()):
            if track.name() == &quot;EXR&quot;:
                exr_index = index
                break

        if exr_index == -1:
            print(&quot;No se encontró un track llamado 'EXR'.&quot;)
            return None

        # Obtener la lista de todos los tracks de video
        video_tracks = list(seq.videoTracks())
        print(f&quot;Current video tracks: {[track.name() for track in video_tracks]}&quot;)

        # Remover todos los tracks
        for track in video_tracks:
            seq.removeTrack(track)

        # Crear el nuevo track llamado &quot;COMPARE&quot;
        compare_track = hiero.core.VideoTrack(&quot;COMPARE&quot;)

        # Reinsertar los tracks en el orden deseado, incluyendo el nuevo track antes de &quot;EXR&quot;
        reordered_tracks = video_tracks[:exr_index] + [compare_track] + video_tracks[exr_index:]
        for track in reordered_tracks:
            seq.addTrack(track)

        print(f&quot;Track 'COMPARE' added and moved to index {exr_index}.&quot;)
        print(f&quot;Reordered video tracks: {[track.name() for track in reordered_tracks]}&quot;)
    else:
        print(&quot;Track 'COMPARE' already exists.&quot;)
        
    return compare_track

def paste_clip_to_compare(compare_track, copied_clip, start_time, duration):
    if not compare_track or not copied_clip:
        return

    # Pegar el clip en el track COMPARE
    compare_track.addItem(copied_clip)
    copied_clip.setTimelineIn(start_time)
    copied_clip.setTimelineOut(start_time + duration - 1)
    print(f&quot;Pasted clip '{copied_clip.name()}' to track COMPARE at start time {start_time}&quot;)

def toggle_blend_mode_for_exr(seq):
    # Volver a encontrar el track llamado &quot;EXR&quot; después de agregar el track &quot;COMPARE&quot;
    for track in seq.videoTracks():
        if track.name() == &quot;EXR&quot;:
            exr_track = track
            break
    else:
        print(&quot;No se encontró un track llamado 'EXR'.&quot;)
        return

    # Verificar si el blend mode ya está activado
    if exr_track.isBlendEnabled():
        # Si está activado, lo desactiva
        exr_track.setBlendEnabled(False)
        print(f&quot;Blend mode desactivado para el track 'EXR'.&quot;)
    else:
        # Si no está activado, lo activa y cambia el modo a &quot;Difference&quot;
        exr_track.setBlendEnabled(True)
        exr_track.setBlendMode(&quot;difference&quot;)
        print(f&quot;Blend mode 'Difference' activado para el track 'EXR'.&quot;)

def self_replace_clip(copied_clip):
    try:
        if isinstance(copied_clip, hiero.core.EffectTrackItem):
            print(f&quot;Ignored effect item: {copied_clip.name()}&quot;)
            return

        # Obtener el archivo original del clip copiado
        file_path = copied_clip.source().mediaSource().fileinfos()[0].filename()
        print(f&quot;Replacing clip with file: {file_path}&quot;)

        # Reemplazar el clip copiado con el archivo original
        copied_clip.replaceClips(file_path)
        print(f&quot;Clip replaced successfully with {file_path}.&quot;)
    except Exception as e:
        print(f&quot;Error replacing clip: {e}&quot;)

def scan_and_downgrade_clip_version(clip):
    def get_all_versions(binItem):
        versions = binItem.items()
        return sorted(versions, key=lambda v: int(v.name().split('_v')[-1]))

    vc = hiero.core.VersionScanner()
    bin_item = clip.source().binItem()
    activeVersion = bin_item.activeVersion()
    vc.doScan(activeVersion)

    versions = get_all_versions(bin_item)
    if versions:
        current_version = bin_item.activeVersion()
        current_version_index = versions.index(current_version)
        
        if current_version_index &gt; 0:
            previous_version = versions[current_version_index - 1]
            bin_item.setActiveVersion(previous_version)
            print(f&quot;Changed {clip.name()} to version {previous_version.name()}&quot;)
        else:
            print(f&quot;{clip.name()} is already at the oldest version available.&quot;)
    else:
        print(f&quot;No versions found for clip: {clip.name()}&quot;)

def main():
    # Obtener la secuencia activa en el timeline
    seq = hiero.ui.activeSequence()
    if not seq:
        print(&quot;No active sequence found.&quot;)
        return

    # Iniciar una acción de undo para las primeras operaciones
    project = seq.project()
    project.beginUndo(&quot;Copy Clip, Reorder Tracks, Paste Clip to COMPARE, and Set EXR to Difference&quot;)

    try:
        # Copiar el clip seleccionado
        copied_clip, start_time, duration = copy_clip()
        if not copied_clip:
            return

        # Guardar el clip original antes de copiarlo
        original_clip = hiero.ui.getTimelineEditor(seq).selection()[0]

        # Reordenar los tracks y agregar el track COMPARE (solo si no existe)
        compare_track = reorder_tracks_and_add_compare(seq)
        if not compare_track:
            return

        # Pegar el clip copiado en el track COMPARE
        paste_clip_to_compare(compare_track, copied_clip, start_time, duration)
        
        # Cambiar el modo del track EXR a &quot;difference&quot;
        toggle_blend_mode_for_exr(seq)
    except Exception as e:
        print(f&quot;Error during operation: {e}&quot;)
    finally:
        # Finalizar la primera acción de undo
        project.endUndo()

    # Iniciar una nueva acción de undo para el self replace clip
    project.beginUndo(&quot;Self Replace Clip&quot;)
    try:
        # Reemplazar el clip copiado en el track COMPARE con el archivo original
        self_replace_clip(copied_clip)
    except Exception as e:
        print(f&quot;Error during self replace clip: {e}&quot;)
    finally:
        # Finalizar la segunda acción de undo
        project.endUndo()

    # Iniciar una nueva acción de undo para escanear y bajar la versión del nuevo clip
    project.beginUndo(&quot;Scan and Downgrade New Clip Version&quot;)
    try:
        # Escanear y bajar una versión del nuevo clip
        scan_and_downgrade_clip_version(copied_clip)
    except Exception as e:
        print(f&quot;Error during scan and downgrade clip version: {e}&quot;)
    finally:
        # Finalizar la tercera acción de undo
        project.endUndo()

# Llamar a la función principal
main()
&quot;&quot;&quot;
_________________________________________________

  LGA_ReviewToolsPanel v2.2 - 2024 - Lega Pugliese
  Tools panel for Hiero / Nuke Studio
_________________________________________________

&quot;&quot;&quot;


import hiero.ui
import hiero.core
import os
import re
import subprocess
import socket
import PySide2, hiero
from PySide2.QtWidgets import *
from PySide2.QtGui import QIcon
from PySide2.QtCore import *
from PySide2 import QtWidgets, QtCore

# Variable global para activar o desactivar los prints
DEBUG = True

def debug_print(*message):
    if DEBUG:
        print(*message)

class ReconnectMediaWidget(QWidget):
    def __init__(self):
        super(ReconnectMediaWidget, self).__init__()

        self.setObjectName(&quot;com.lega.RevtoolPanel&quot;)
        self.setWindowTitle(&quot;Review&quot;)
        self.setStyleSheet(&quot;QToolTip { color: #ffffff; background-color: #2a2a2a; border: 1px solid white; }&quot;)

        self.layout = QGridLayout(self)  # Usamos QGridLayout en lugar de QVBoxLayout
        self.setLayout(self.layout)

        # Crear botones y agregarlos al layout
        self.buttons = [
            (&quot;Self ReplaceClip&quot;, self.SelfReaplaceClip, &quot;#191f28&quot;),
            (&quot;ON Clips | OFF v00&quot;, self.enable_or_disable_clips, &quot;#191f28&quot;), 
            (&quot;EXR Track Difference&quot;, self.toggle_blend_mode_for_exr_track, &quot;#35273c&quot;),
            (&quot;Compare Versions&quot;, self.run_compare_versions, &quot;#35273c&quot;),
            (&quot;Compare OFF&quot;, self.compare_versions_off, &quot;#35273c&quot;),
            (&quot;Rec709 | &amp;Viewer&quot;, self.rec709_viewer, &quot;#191f28&quot;, &quot;Shift+V&quot;, &quot;Shift+V&quot;),
            (&quot;Reveal in &amp;Explorer&quot;, self.reveal_in_explorer, &quot;#261e1a&quot;, &quot;Shift+E&quot;, &quot;Shift+E&quot;),
            (&quot;Reveal NKS Project&quot;, self.reveal_project, &quot;#261e1a&quot;),
            (&quot;Reveal NK Sc&amp;ript&quot;, self.reveal_script, &quot;#261e1a&quot;, &quot;Shift+R&quot;, &quot;Shift+R&quot;),
            (&quot;OpenInNuke&amp;X&quot;, self.open_in_nukex_main, &quot;#212b1f&quot;, &quot;Shift+X&quot;, &quot;Shift+X&quot;)
        ]


        self.num_columns = 1  # Inicialmente una columna
        self.create_buttons()

        # Conectar la señal de cambio de tamaño del widget al método correspondiente
        self.adjust_columns_on_resize()
        self.resizeEvent = self.adjust_columns_on_resize

    def create_buttons(self):
        for index, button_info in enumerate(self.buttons):
            name = button_info[0]
            handler = button_info[1]
            style = button_info[2]
            shortcut = button_info[3] if len(button_info) &gt; 3 else None
            tooltip = button_info[4] if len(button_info) &gt; 4 else None

            button = QPushButton(name)
            button.setStyleSheet(f&quot;background-color: {style}&quot;)
            button.clicked.connect(handler)
            if shortcut:
                button.setShortcut(shortcut)
            if tooltip:
                button.setToolTip(tooltip)

            row = index // self.num_columns
            column = index % self.num_columns
            self.layout.addWidget(button, row, column)

    def adjust_columns_on_resize(self, event=None):
        # Obtener el ancho actual del widget
        panel_width = self.width()
        button_width = 120  # Ancho aproximado de cada botón
        min_button_spacing = 10  # Espacio mínimo entre botones

        # Calcular el número de columnas en función del ancho del widget
        self.num_columns = max(1, (panel_width + min_button_spacing) // (button_width + min_button_spacing))

        # Limpiar el layout actual y eliminar widgets solo si existen
        while self.layout.count():
            item = self.layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

        # Volver a crear los botones con el nuevo número de columnas
        self.create_buttons()

        # Calcular el número de filas usadas
        num_rows = (len(self.buttons) + self.num_columns - 1) // self.num_columns

        # Añadir el espaciador vertical
        spacer = QSpacerItem(20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding)
        self.layout.addItem(spacer, num_rows, 0, 1, self.num_columns)



#### SelfReaplaceClip
    def get_full_bin_path(self, bin_item):
        path = []
        while bin_item:
            if isinstance(bin_item, hiero.core.Bin):
                path.append(bin_item.name())
            bin_item = bin_item.parentBin() if hasattr(bin_item, 'parentBin') else None
        return '/'.join(reversed(path))

    def find_or_create_bin(self, project, bin_path):
        &quot;&quot;&quot;
        Encuentra un bin existente o crea uno nuevo si no existe.

        Args:
        - project (hiero.core.Project): El proyecto actual en Hiero.
        - bin_path (str): La ruta del bin.

        Returns:
        - hiero.core.Bin: El bin encontrado o creado.
        &quot;&quot;&quot;
        # Dividir la ruta en partes
        bin_names = bin_path.split('/')

        # Empezar desde el bin de clips
        current_bin = project.clipsBin()

        # Iterar sobre las partes de la ruta
        for bin_name in bin_names:
            found_bin = None
            # Buscar el bin actual por su nombre
            for item in current_bin.items():
                if isinstance(item, hiero.core.Bin) and item.name() == bin_name:
                    found_bin = item
                    break
            # Si no se encontró el bin, crear uno nuevo
            if not found_bin:
                found_bin = hiero.core.Bin(bin_name)
                current_bin.addItem(found_bin)
            current_bin = found_bin

        return current_bin

    def move_clip_to_bin(self, project, clip_name, source_bin_name, target_bin_path, shot):
        &quot;&quot;&quot;
        Mueve un clip de un bin de origen a un bin de destino en el proyecto.

        Args:
        - project (hiero.core.Project): El proyecto actual en Hiero.
        - clip_name (str): El nombre del clip que se moverá.
        - source_bin_name (str): El nombre del bin de origen que contiene el clip.
        - target_bin_path (str): La ruta del bin de destino donde se moverá el clip.
        &quot;&quot;&quot;
        # Buscar el bin de origen por su nombre
        source_bin = None
        for bin_item in project.clipsBin().items():
            if bin_item.name() == source_bin_name:
                source_bin = bin_item
                break

        if source_bin:
            # Buscar el clip por su nombre dentro del bin de origen
            clip_to_move = None
            for clip_item in source_bin.items():
                if clip_item.name() == clip_name:
                    clip_to_move = clip_item
                    break

            if clip_to_move:
                # Encontrar o crear el bin de destino
                target_bin = self.find_or_create_bin(project, target_bin_path)

                # Remover el clip del bin de origen
                source_bin.removeItem(clip_to_move)

                # Remover el clip del bin original (no me está funcionando)
                original_bin_item = shot.source().binItem()
                original_bin = original_bin_item.parentBin()
                #original_bin.removeItem(original_bin_item)    
                
                # Agregar el clip al bin de destino
                target_bin.addItem(clip_to_move)
                debug_print(&quot;Se movió el clip '{}' del bin '{}' al bin '{}'.&quot;.format(clip_name, source_bin_name, target_bin_path))
            else:
                debug_print(&quot;No se encontró el clip '{}' en el bin de origen '{}'.&quot;.format(clip_name, source_bin_name))
        else:
            debug_print(&quot;No se encontró el bin de origen '{}'.&quot;.format(source_bin_name))

    def SelfReaplaceClip(self):
        # Obtener el proyecto actual en Hiero
        project = hiero.core.projects()[0] if hiero.core.projects() else None
        try:
            seq = hiero.ui.activeSequence()
            if not seq:
                debug_print(&quot;No active sequence found.&quot;)
                return

            te = hiero.ui.getTimelineEditor(seq)
            selected_clips = te.selection()
            project = hiero.core.projects()[0]
            project.beginUndo(&quot;Change Clip Color&quot;)

            if len(selected_clips) == 0:
                debug_print(&quot;*** No clips selected on the track ***&quot;)
            else:


                for shot in selected_clips:
                    if isinstance(shot, hiero.core.EffectTrackItem):  # Verificar si es un efecto
                        debug_print(f&quot;Ignore effect item: {shot.name()}&quot;)
                    else:            
                    
                        file_path = shot.source().mediaSource().fileinfos()[0].filename()
                        debug_print(&quot;File path:&quot;, file_path)

                        bin_item = shot.source().binItem()
                        full_bin_path = self.get_full_bin_path(bin_item)
                        full_bin_path = full_bin_path.replace(&quot;Sequences/&quot;, &quot;&quot;)
                        debug_print(&quot;Full bin path for the clip:&quot;, full_bin_path)

                        try:
                            shot.replaceClips(file_path)
                            debug_print(&quot;Clip replaced successfully.&quot;)
                        except:
                            debug_print(&quot;Error replacing clip.&quot;)


                        
                        new_clip_name = shot.source().name()
                        debug_print(f&quot;Clip name: {new_clip_name}&quot;)

                        conform_bin_name = &quot;Conform&quot;
                        original_bin_name = full_bin_path.split(' &gt; ')[-1]
                        self.move_clip_to_bin(project, new_clip_name, conform_bin_name, full_bin_path, shot)


            project.endUndo()
        except Exception as e:
            debug_print(f&quot;Error during operation: {e}&quot;)


##### Compare Versions
    def run_compare_versions(self):
        try:
            seq = hiero.ui.activeSequence()
            if not seq:
                debug_print(&quot;No active sequence found.&quot;)
                return

            te = hiero.ui.getTimelineEditor(seq)
            selected_clips = te.selection()

            if len(selected_clips) == 0:
                debug_print(&quot;*** No clips selected on the track ***&quot;)
                return

            for selected_clip in selected_clips:
                if isinstance(selected_clip, hiero.core.EffectTrackItem):
                    continue  # Ignorar si es un efecto
                
                # Comprobar si el clip está en un track llamado EXR
                if selected_clip.parentTrack().name() != &quot;EXR&quot;:
                    continue  # Ignorar si no está en un track llamado EXR

                script_path = os.path.join(os.path.dirname(__file__), 'LGA_NKS', 'LGA_NKS_Compare_Versions.py')
                if os.path.exists(script_path):
                    import importlib.util
                    spec = importlib.util.spec_from_file_location(&quot;LGA_NKS_Compare_Versions&quot;, script_path)
                    module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module)

                    # Llamar a la función main del script y pasar el clip seleccionado
                    module.main(selected_clip)
                    return  # Salir después de procesar el primer clip válido
                else:
                    debug_print(f&quot;Script not found at path: {script_path}&quot;)
                    return
        except Exception as e:
            debug_print(f&quot;Error during running compare script: {e}&quot;)


##### Compare Versions OFF
    def compare_versions_off(self):
        try:
            script_path = os.path.join(os.path.dirname(__file__), 'LGA_NKS', 'LGA_NKS_Compare_Versions_OFF.py')
            if os.path.exists(script_path):
                import importlib.util
                spec = importlib.util.spec_from_file_location(&quot;LGA_NKS_Compare_Versions_OFF&quot;, script_path)
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)

                # Llamar a la función main del script
                module.main()
            else:
                debug_print(f&quot;Script not found at path: {script_path}&quot;)
        except Exception as e:
            debug_print(f&quot;Error during running compare versions off script: {e}&quot;)



##### ON Clips | OFF v00
    def enable_or_disable_clips(self):
        try:
            seq = hiero.ui.activeSequence()
            if seq:
                te = hiero.ui.getTimelineEditor(seq)
                selected_items = te.selection()
                if selected_items:
                    for item in selected_items:
                        if not isinstance(item, hiero.core.EffectTrackItem):
                            file_path = item.source().mediaSource().fileinfos()[0].filename() if item.source().mediaSource().fileinfos() else None
                            if file_path and '_comp_' in os.path.basename(file_path).lower():
                                if re.search(r'_comp_v00', os.path.basename(file_path).lower()):
                                    item.setEnabled(False)
                                else:
                                    item.setEnabled(True)
                            else:
                                item.setEnabled(True)
                else:
                    debug_print(&quot;No clips selected on the timeline.&quot;)
            else:
                debug_print(&quot;No active sequence found in Hiero.&quot;)
        except Exception as e:
            debug_print(f&quot;Error during operation: {e}&quot;)


##### Rec 709 en viewer
    def rec709_viewer(self):
        hiero.ui.currentViewer().player().setLUT('ACES/Rec.709')
        

##### Reveal in explorer
    def open_file_explorer(self, path):
        if os.name == 'nt':  # Windows
            os.startfile(os.path.dirname(path))
        elif os.name == 'posix':  # macOS
            subprocess.Popen(['open', os.path.dirname(path)])
        else:
            debug_print(&quot;Unsupported OS&quot;)


    def reveal_in_explorer(self):
        try:
            seq = hiero.ui.activeSequence()
            if not seq:
                debug_print(&quot;No active sequence found.&quot;)
                return

            te = hiero.ui.getTimelineEditor(seq)
            selected_clips = te.selection()

            if len(selected_clips) == 0:
                debug_print(&quot;*** No clips selected on the track ***&quot;)
                self.reveal_project()
            else:
                for shot in selected_clips:
                    if isinstance(shot, hiero.core.EffectTrackItem):  # Verificar si es un efecto
                        pass  
                    else:
                        # Obtener el file path del clip seleccionado
                        file_path = shot.source().mediaSource().fileinfos()[0].filename()
                        debug_print(f&quot;Original file path: {file_path}&quot;)
                        self.open_file_explorer(file_path)
        except Exception as e:
            debug_print(f&quot;Error: {e}&quot;)


    def get_active_project(self):
        &quot;&quot;&quot;
        Obtiene el proyecto activo en Hiero.

        Returns:
        - hiero.core.Project o None: El proyecto activo, o None si no se encuentra ningún proyecto activo.
        &quot;&quot;&quot;
        projects = hiero.core.projects()
        if projects:
            return projects[0]  # Devuelve el primer proyecto en la lista
        else:
            return None


##### Reveal 
    def reveal_project(self):
        # Obtener el proyecto activo
        project = self.get_active_project()
        if project:
            # Obtener el directorio del proyecto activo
            project_path = project.path()

            # Imprimir el directorio del proyecto activo
            debug_print(f&quot;El directorio del proyecto activo es: {project_path}&quot;)
            self.open_file_explorer(project_path)
        else:
            debug_print(&quot;No se encontró un proyecto activo en Hiero.&quot;)


    def reveal_script(self):
        try:
            seq = hiero.ui.activeSequence()
            if not seq:
                debug_print(&quot;No active sequence found.&quot;)
                return

            te = hiero.ui.getTimelineEditor(seq)
            selected_clips = te.selection()

            if len(selected_clips) == 0:
                debug_print(&quot;*** No clips selected on the track ***&quot;)
            else:
                for shot in selected_clips:
                    if isinstance(shot, hiero.core.EffectTrackItem):  # Verificar si es un efecto
                        pass  
                    else:
                        # Obtener el file path del clip seleccionado
                        file_path = shot.source().mediaSource().fileinfos()[0].filename()
                        debug_print(f&quot;Original file path: {file_path}&quot;)

                        # Obtener la nueva ruta del proyecto
                        project_path = self.get_project_path(file_path)
                        
                        # Asegurarnos de que la ruta termina con '/'
                        if not project_path.endswith('/'):
                            project_path += '/'
                        
                        debug_print(f&quot;Project path: {project_path}&quot;)

                        # Abre el explorador de archivos en la nueva ruta del proyecto
                        self.open_file_explorer(project_path)
        except Exception as e:
            debug_print(f&quot;Error: {e}&quot;)


            

##### OpenInNukeX
    def open_in_nukex_main(self):
        seq = hiero.ui.activeSequence()
        if not seq:
            debug_print(&quot;No active sequence found.&quot;)
            self.show_message(&quot;Error&quot;, &quot;No active sequence found.&quot;)
            return

        te = hiero.ui.getTimelineEditor(seq)
        selected_clips = te.selection()

        if len(selected_clips) == 0:
            debug_print(&quot;*** No clips selected on the track ***&quot;)
            self.show_message(&quot;Error&quot;, &quot;No clips selected.&quot;)
            return

        for shot in selected_clips:
            if isinstance(shot, hiero.core.EffectTrackItem):
                continue  # Ignorar si es un efecto
            try:
                file_path = shot.source().mediaSource().fileinfos()[0].filename()
                project_path = self.get_project_path(file_path)
                script_name = self.get_script_name(file_path)
                script_full_path = os.path.join(project_path, script_name)

                # Verificar si el archivo existe y abrir en Nuke si es así
                if os.path.exists(script_full_path):
                    self.open_nuke_script(script_full_path)
                else:
                    formatted_message = &quot;&lt;div style='text-align: left;'&gt;&lt;b&gt;File not found&lt;/b&gt;&lt;br&gt;&lt;br&gt;&quot; + script_full_path + &quot;&lt;/div&gt;&quot;
                    self.show_message(&quot;Error&quot;, formatted_message)
                return  # Salir después de abrir el script
            except AttributeError as e:
                debug_print(f&quot;Clip does not have a valid source: {e}&quot;)
        
        self.show_message(&quot;Error&quot;, &quot;No valid clip found.&quot;)



    def show_message(self, title, message, duration=None):
        msgBox = QtWidgets.QMessageBox()
        msgBox.setWindowTitle(title)
        # Interpretar el mensaje como HTML si incluye etiquetas, de lo contrario como texto normal
        if '&lt;' in message and '&gt;' in message:
            msgBox.setTextFormat(QtCore.Qt.TextFormat.RichText)  # Interpretar como HTML
        else:
            msgBox.setTextFormat(QtCore.Qt.TextFormat.PlainText)  # Interpretar como texto normal
        msgBox.setText(message)
        msgBox.setStandardButtons(QtWidgets.QMessageBox.Ok)
        if duration:
            QtCore.QTimer.singleShot(duration, msgBox.close)
        msgBox.exec_()

    def show_timed_message(sef, title, message, duration):
        msgBox = TimedMessageBox(title, message, duration)
        msgBox.exec_()

    # Función para obtener la ruta del proyecto
    def get_project_path(self, file_path):
        # Dividir el path en partes usando '/' como separador
        path_parts = file_path.split('/')
        # Construir la nueva ruta agregando '/Comp/1_projects'
        project_path = '/'.join(path_parts[:4]) + '/Comp/1_projects'
        return project_path

    # Función para obtener el nombre del archivo del script relacionado con el clip
    def get_script_name(self, file_path):
        # Extraer el nombre del archivo del path completo
        script_name = os.path.basename(file_path)
        # Eliminar la extensión y cualquier secuencia de frame como %04d
        script_name = re.sub(r'_%\d+?d\.exr$', '', script_name)  # Ajusta la expresión regular según necesidad
        return script_name + '.nk'  # Añadir la extensión correcta de Nuke

    # Función para abrir Nuke Studio o NukeX si la conexión falla
    def open_nuke_script(self, nk_filepath):
        host = 'localhost'
        port = 54325
        nuke_path = &quot;C:/Program Files/Nuke15.0v4/Nuke15.0.exe&quot;

        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(10)
                s.connect((host, port))
                # Enviar un comando 'ping'
                s.sendall(&quot;ping&quot;.encode())
                # Esperar una respuesta para confirmar que NukeX está operativo
                response = s.recv(1024).decode()
                if &quot;pong&quot; in response:
                    debug_print(&quot;NukeX is active and responding.&quot;)
                    # Cerrar el socket anterior y abrir uno nuevo para enviar el comando de ejecución
                    s.close()
                    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as new_socket:
                        new_socket.connect((host, port))
                        normalized_path = os.path.normpath(nk_filepath).replace('\\', '/')
                        full_command = f&quot;run_script||{normalized_path}&quot;
                        new_socket.sendall(full_command.encode())
                        self.show_timed_message(
                            &quot;OpenInNukeX&quot;, 
                            (
                                f&quot;&lt;div style='text-align: center;'&gt;&quot;
                                f&quot;&lt;span&gt;Opening&lt;/span&gt;&lt;br&gt;&quot;
                                f&quot;&lt;span style='font-style: italic; color: #9f9f9f; font-size: 0.9em;'&gt;{os.path.basename(nk_filepath)}&lt;/span&gt;&lt;br&gt;&lt;br&gt;&quot;
                                f&quot;&lt;span style='color:white;'&gt;Please switch to the NukeX window...&lt;/span&gt;&quot;
                                f&quot;&lt;/div&gt;&quot;
                            ),
                            5000
                        )
                        return

                else:
                    raise Exception(&quot;NukeX is not responding as expected.&quot;)
        except (socket.timeout, ConnectionRefusedError, Exception) as e:
            # Si no se puede establecer la conexión o no se recibe la respuesta esperada, intentar abrir NukeX directamente
            command = f'&quot;{nuke_path}&quot; --nukex &quot;{nk_filepath}&quot;'
            subprocess.Popen(command, shell=True)
            self.show_timed_message(
                &quot;Error&quot;, 
                (
                    f&quot;&lt;span style='color:white;'&gt;&lt;b&gt;Failed to connect to NukeX&lt;/b&gt;&lt;/span&gt;&lt;br&gt;&lt;br&gt;&quot;
                    f&quot;Opening a new NukeX instance&lt;br&gt;&quot;
                    f&quot;&lt;span style='font-style: italic; color: #9f9f9f; font-size: 0.9em;'&gt;{nuke_path}&lt;/span&gt;&quot;
                ), 
                5000
            )
        except ConnectionResetError:
            self.show_message(&quot;Error&quot;, &quot;The connection was closed by the server.&quot;)


##### Difference mode in track
    def toggle_blend_mode_for_exr_track(self):
        # Obtiene la secuencia activa
        seq = hiero.ui.activeSequence()
        
        if not seq:
            debug_print(&quot;No hay una secuencia activa.&quot;)
            return
        
        # Itera sobre los tracks de video para encontrar el que se llama &quot;EXR&quot;
        for index, track in enumerate(seq.videoTracks()):
            if track.name() == &quot;EXR&quot;:
                # Verifica si el blend mode ya está activado
                if track.isBlendEnabled():
                    # Si está activado, lo desactiva
                    track.setBlendEnabled(False)
                    debug_print(f&quot;Blend mode desactivado para el track 'EXR' en el índice: {index}&quot;)
                else:
                    # Si no está activado, lo activa y cambia el modo a &quot;Difference&quot;
                    track.setBlendEnabled(True)
                    track.setBlendMode(&quot;difference&quot;)
                    debug_print(f&quot;Blend mode 'Difference' activado para el track 'EXR' en el índice: {index}&quot;)
                break
        else:
            debug_print(&quot;No se encontró un track llamado 'EXR'.&quot;)


##### Clase para OpenInNukeX
class TimedMessageBox(QtWidgets.QMessageBox):
    def __init__(self, title, message, duration):
        super().__init__()
        self.setWindowTitle(title)
        self.setText(message)
        self.setStandardButtons(QtWidgets.QMessageBox.Ok)

        self.timer = QtCore.QTimer(self)
        self.timer.timeout.connect(self.updateButton)
        self.timeLeft = duration // 1000  # Convert milliseconds to seconds
        self.timer.start(1000)  # Update every second

        self.updateButton()  # Initialize the button text

    def updateButton(self):
        if self.timeLeft &gt; 0:
            self.button(QtWidgets.QMessageBox.Ok).setText(f&quot;OK ({self.timeLeft})&quot;)
            self.timeLeft -= 1
        else:
            self.timer.stop()
            self.accept()  # Close the message box automatically


# Crear la instancia del widget y añadirlo al gestor de ventanas de Hiero
reconnectWidget = ReconnectMediaWidget()
wm = hiero.ui.windowManager()
wm.addWindow(reconnectWidget)
import importlib
import LGA_disable_A_B
importlib.reload(LGA_disable_A_B)

&quot;&quot;&quot;
____________________________________________________________________________________

  LGA_NKS_Flow_Panel v1.9 - 2024 - Lega Pugliese
  Panel con herramientas que interactuan con las tasks de Flow Production Tracking 
  que fueron descargadas previamente con la app LGA_NKS_Flow_Downloader
____________________________________________________________________________________
&quot;&quot;&quot;

import hiero.ui
import hiero.core
import sys
import os
from PySide2.QtWidgets import QWidget, QPushButton, QGridLayout, QSpacerItem, QSizePolicy, QMessageBox
from PySide2.QtGui import QColor


# Variable global para activar o desactivar los prints
DEBUG = False

def debug_print(*message):
    if DEBUG:
        print(*message)


class ColorChangeWidget(QWidget):
    def __init__(self):
        super(ColorChangeWidget, self).__init__()

        self.setObjectName(&quot;com.lega.FPTPanel&quot;)
        self.setWindowTitle(&quot;Flow&quot;)

        self.layout = QGridLayout()  # Usamos QGridLayout
        self.setLayout(self.layout)

        # Crear botones y agregarlos al layout con coordenadas específicas
        self.buttons = [
            {&quot;name&quot;: &quot;Flow Pull&quot;, &quot;color&quot;: None, &quot;style&quot;: &quot;#1f1f1f&quot;, &quot;action&quot;: &quot;fpt_pull&quot;},
            {&quot;name&quot;: &quot;Shot Info&quot;, &quot;color&quot;: None, &quot;style&quot;: &quot;#1f1f1f&quot;, &quot;action&quot;: &quot;shot_info&quot;, &quot;shortcut&quot;: &quot;Shift+T&quot;},
            {&quot;name&quot;: &quot;Clear Tag&quot;, &quot;color&quot;: None, &quot;style&quot;: &quot;#1f1f1f&quot;, &quot;action&quot;: &quot;clear_tag&quot;},  # Nuevo botón
            {&quot;name&quot;: &quot;Corrections&quot;, &quot;color&quot;: QColor(46, 119, 212), &quot;style&quot;: &quot;#2e77d4&quot;, &quot;action&quot;: &quot;color&quot;},
            #{&quot;name&quot;: &quot;Corrs_Lega&quot;, &quot;color&quot;: QColor(105, 19, 94), &quot;style&quot;: &quot;#69135e&quot;, &quot;action&quot;: &quot;color&quot;},
            {&quot;name&quot;: &quot;Rev_Sup&quot;, &quot;color&quot;: QColor(163, 85, 126), &quot;style&quot;: &quot;#a3557e&quot;, &quot;action&quot;: &quot;color&quot;},
            {&quot;name&quot;: &quot;Rev_Lega&quot;, &quot;color&quot;: QColor(105, 19, 94), &quot;style&quot;: &quot;#69135e&quot;, &quot;action&quot;: &quot;color&quot;},
            {&quot;name&quot;: &quot;Rev_Dir&quot;, &quot;color&quot;: QColor(152, 192, 84), &quot;style&quot;: &quot;#98c054&quot;, &quot;action&quot;: &quot;color&quot;},
            {&quot;name&quot;: &quot;Approved&quot;, &quot;color&quot;: QColor(36, 76, 25), &quot;style&quot;: &quot;#244c19&quot;, &quot;action&quot;: &quot;color&quot;},
            {&quot;name&quot;: &quot;Rev_Sup_D&quot;, &quot;color&quot;: QColor(82, 61, 128), &quot;style&quot;: &quot;#523d80&quot;, &quot;action&quot;: &quot;color&quot;},
            {&quot;name&quot;: &quot;Rev_Dir_D&quot;, &quot;color&quot;: QColor(77, 33, 168), &quot;style&quot;: &quot;#4d21a8&quot;, &quot;action&quot;: &quot;color&quot;},
        ]

        
        self.num_columns = 1  # Inicialmente una columna
        self.create_buttons()

        # Conectar la señal de cambio de tamaño del widget al método correspondiente
        self.adjust_columns_on_resize()
        self.resizeEvent = self.adjust_columns_on_resize

    def create_buttons(self):
        for index, button_info in enumerate(self.buttons):
            name = button_info[&quot;name&quot;]
            color = button_info[&quot;color&quot;]
            style = button_info[&quot;style&quot;]
            action = button_info[&quot;action&quot;]

            button = QPushButton(name)
            button.setStyleSheet(f&quot;background-color: {style}&quot;)
            if action == &quot;color&quot;:
                button.clicked.connect(self.handle_color_button_click(color, name))
            elif action == &quot;fpt_pull&quot;:
                button.clicked.connect(self.run_FPT_pull)
            elif action == &quot;clear_tag&quot;:
                button.clicked.connect(self.run_clear_tag_script)
            elif action == &quot;shot_info&quot;:
                button.clicked.connect(self.run_shot_info_script)
            row = index // self.num_columns
            column = index % self.num_columns
            self.layout.addWidget(button, row, column)

    def handle_color_button_click(self, color, button_name):
        def button_click_handler(_):
            confirmation = self.confirm_status_application(button_name)
            if confirmation:
                self.change_clip_color_and_push_status(color, button_name)
                if button_name in [&quot;Rev_Dir&quot;, &quot;Corrections&quot;]:
                    self.run_clear_tag_script()
        return button_click_handler

    def parse_exr_name(self, exr_name):
        # Ajustar el manejo del formato del nombre del archivo EXR
        if '%04d' in exr_name:
            exr_name = exr_name.replace('.%', '_%')  # Reemplazar patrón para análisis

        parts = exr_name.split('_')
        if len(parts) &lt; 7 or not parts[-2].startswith('v'):
            raise ValueError(f&quot;Nombre del archivo EXR no tiene el formato esperado: {exr_name}&quot;)
        base_name = '_'.join(parts[:-1])  # Todas las partes excepto la última forman el base_name
        return base_name

    def push_task_status(self, button_name, base_name):
        try:
            script_path = os.path.join(os.path.dirname(__file__), 'LGA_NKS_Flow', 'LGA_NKS_Flow_Push.py')
            if os.path.exists(script_path):
                import importlib.util
                spec = importlib.util.spec_from_file_location(&quot;LGA_NKS_Flow_Push&quot;, script_path)
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                module.Push_Task_Status(button_name, base_name)
            else:
                debug_print(f&quot;Script not found at path: {script_path}&quot;)
        except Exception as e:
            debug_print(f&quot;Error during push task status operation: {e}&quot;)

    def change_clip_color_and_push_status(self, color, button_name):
        try:
            seq = hiero.ui.activeSequence()
            if seq:
                te = hiero.ui.getTimelineEditor(seq)
                selected_items = te.selection()

                project = hiero.core.projects()[0]
                project.beginUndo(&quot;Change Clip Color&quot;)

                for item in selected_items:
                    if not isinstance(item, hiero.core.EffectTrackItem):
                        bin_item = item.source().binItem()
                        if item.source().mediaSource().isMediaPresent():
                            active_version = bin_item.activeVersion()
                            if active_version:
                                bin_item.setColor(color)

                            file_path = item.source().mediaSource().fileinfos()[0].filename() if item.source().mediaSource().fileinfos() else None
                            if not file_path or '_comp_' not in os.path.basename(file_path).lower():
                                continue
                            exr_name = os.path.basename(file_path)
                            exr_name = exr_name.replace('.%', '_%')  # Reemplazar patrón para análisis
                            try:
                                base_name = self.parse_exr_name(exr_name)
                                debug_print(f&quot;Status: {button_name}, Shot: {base_name}&quot;)
                                self.push_task_status(button_name, base_name)
                            except ValueError as e:
                                debug_print(f&quot;Error: {e}&quot;)
                project.endUndo()
            else:
                pass
        except Exception as e:
            debug_print(f&quot;Error during operation: {e}&quot;)


    def confirm_status_application(self, status):
        seq = hiero.ui.activeSequence()
        if seq:
            te = hiero.ui.getTimelineEditor(seq)
            selected_items = te.selection()
            if len(selected_items) &gt; 4:
                msg = QMessageBox()
                msg.setIcon(QMessageBox.Question)
                msg.setWindowTitle(&quot;Confirm Status Application&quot;)
                msg.setText(f&quot;Are you sure you want to apply the status '{status}' to {len(selected_items)} clips?&quot;)
                msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
                result = msg.exec_()
                return result == QMessageBox.Yes
        return True

    def adjust_columns_on_resize(self, event=None):
        # Obtener el ancho actual del widget
        panel_width = self.width()
        button_width = 100  # Ancho aproximado de cada botón
        min_button_spacing = 10  # Espacio mínimo entre botones

        # Calcular el número de columnas en función del ancho del widget
        self.num_columns = max(1, (panel_width + min_button_spacing) // (button_width + min_button_spacing))

        # Limpiar el layout actual y eliminar widgets solo si existen
        while self.layout.count():
            item = self.layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

        # Volver a crear los botones con el nuevo número de columnas
        self.create_buttons()

        # Calcular el número de filas usadas
        num_rows = (len(self.buttons) + self.num_columns - 1) // self.num_columns

        # Añadir el espaciador vertical
        spacer = QSpacerItem(20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding)
        self.layout.addItem(spacer, num_rows, 0, 1, self.num_columns)

    def run_FPT_pull(self):
        # Obtener el proyecto actual
        project = hiero.core.projects()[0] if hiero.core.projects() else None
        if project:
            project.beginUndo(&quot;Run External Script&quot;)
            try:
                # Importar y ejecutar el script de la subcarpeta
                script_path = os.path.join(os.path.dirname(__file__), 'LGA_NKS_Flow', 'LGA_NKS_Flow_Pull.py')
                if os.path.exists(script_path):
                    try:
                        import importlib.util
                        spec = importlib.util.spec_from_file_location(&quot;LGA_NKS_Flow_Pull&quot;, script_path)
                        module = importlib.util.module_from_spec(spec)
                        spec.loader.exec_module(module)
                        module.FPT_Hiero()
                        #debug_print(&quot;Script ejecutado correctamente.&quot;)
                    except Exception as e:
                        debug_print(f&quot;Error al ejecutar el script: {e}&quot;)
                else:
                    debug_print(f&quot;Script no encontrado en la ruta: {script_path}&quot;)
            finally:
                project.endUndo()

    def run_clear_tag_script(self):
        project = hiero.core.projects()[0] if hiero.core.projects() else None
        if project:
            project.beginUndo(&quot;Run External Script&quot;)
            try:
                seq = hiero.ui.activeSequence()
                if seq:
                    te = hiero.ui.getTimelineEditor(seq)
                    selected_items = te.selection()

                    for item in selected_items:
                        if not isinstance(item, hiero.core.EffectTrackItem):  # Verificación de que el clip no sea un efecto
                            # Importar y ejecutar el script de la subcarpeta para cada clip válido
                            script_path = os.path.join(os.path.dirname(__file__), 'LGA_NKS_Flow', 'LGA_NKS_Delete_ClipTags.py')
                            if os.path.exists(script_path):
                                try:
                                    import importlib.util
                                    spec = importlib.util.spec_from_file_location(&quot;LGA_H_DeleteClipTags&quot;, script_path)
                                    module = importlib.util.module_from_spec(spec)
                                    spec.loader.exec_module(module)
                                    module.delete_tags_from_clip(item)  # Pasar el clip válido como parámetro
                                    # debug_print(&quot;Script ejecutado correctamente.&quot;)
                                except Exception as e:
                                    debug_print(f&quot;Error al ejecutar el script para el clip {item}: {e}&quot;)
                            else:
                                debug_print(f&quot;Script no encontrado en la ruta: {script_path}&quot;)
            finally:
                project.endUndo()




    def run_shot_info_script(self):
        project = hiero.core.projects()[0] if hiero.core.projects() else None
        if project:
            project.beginUndo(&quot;Run External Script&quot;)
            try:
                script_path = os.path.join(os.path.dirname(__file__), 'LGA_NKS_Flow', 'LGA_NKS_Flow_Shot_info.py')
                if os.path.exists(script_path):
                    try:
                        import importlib.util
                        spec = importlib.util.spec_from_file_location(&quot;LGA_NKS_Flow_Shot_info&quot;, script_path)
                        module = importlib.util.module_from_spec(spec)
                        spec.loader.exec_module(module)
                        module.main()  # Asumimos que el script tiene un método main
                    except Exception as e:
                        debug_print(f&quot;Error al ejecutar el script: {e}&quot;)
                else:
                    debug_print(f&quot;Script no encontrado en la ruta: {script_path}&quot;)
            finally:
                project.endUndo()






# Crear la instancia del widget y añadirlo al gestor de ventanas de Hiero
colorChanger = ColorChangeWidget()
wm = hiero.ui.windowManager()
wm.addWindow(colorChanger)
&quot;&quot;&quot;
____________________________________________________________________________________

  LGA_NKS_Flow_Panel v1.9 - 2024 - Lega Pugliese
  Panel con herramientas que interactuan con las tasks de Flow Production Tracking 
  que fueron descargadas previamente con la app LGA_NKS_Flow_Downloader
____________________________________________________________________________________
&quot;&quot;&quot;

import hiero.ui
import hiero.core
import sys
import os
from PySide2.QtWidgets import QWidget, QPushButton, QGridLayout, QSpacerItem, QSizePolicy, QMessageBox
from PySide2.QtGui import QColor, QKeySequence


# Variable global para activar o desactivar los prints
DEBUG = False

def debug_print(*message):
    if DEBUG:
        print(*message)


class ColorChangeWidget(QWidget):
    def __init__(self):
        super(ColorChangeWidget, self).__init__()

        self.setObjectName(&quot;com.lega.FPTPanel&quot;)
        self.setWindowTitle(&quot;Flow&quot;)

        self.layout = QGridLayout()  # Usamos QGridLayout
        self.setLayout(self.layout)

        # Crear botones y agregarlos al layout con coordenadas específicas
        self.buttons = [
            {&quot;name&quot;: &quot;Flow Pull&quot;, &quot;color&quot;: None, &quot;style&quot;: &quot;#1f1f1f&quot;, &quot;action&quot;: &quot;fpt_pull&quot;},
            {&quot;name&quot;: &quot;Sho&amp;t Info&quot;, &quot;color&quot;: None, &quot;style&quot;: &quot;#1f1f1f&quot;, &quot;action&quot;: &quot;shot_info&quot;, &quot;shortcut&quot;: &quot;Shift+T&quot;},
            {&quot;name&quot;: &quot;Clear Tag&quot;, &quot;color&quot;: None, &quot;style&quot;: &quot;#1f1f1f&quot;, &quot;action&quot;: &quot;clear_tag&quot;},  # Nuevo botón
            {&quot;name&quot;: &quot;Corrections&quot;, &quot;color&quot;: QColor(46, 119, 212), &quot;style&quot;: &quot;#2e77d4&quot;, &quot;action&quot;: &quot;color&quot;},
            #{&quot;name&quot;: &quot;Corrs_Lega&quot;, &quot;color&quot;: QColor(105, 19, 94), &quot;style&quot;: &quot;#69135e&quot;, &quot;action&quot;: &quot;color&quot;},
            {&quot;name&quot;: &quot;Rev_Sup&quot;, &quot;color&quot;: QColor(163, 85, 126), &quot;style&quot;: &quot;#a3557e&quot;, &quot;action&quot;: &quot;color&quot;},
            {&quot;name&quot;: &quot;Rev_Lega&quot;, &quot;color&quot;: QColor(105, 19, 94), &quot;style&quot;: &quot;#69135e&quot;, &quot;action&quot;: &quot;color&quot;},
            {&quot;name&quot;: &quot;Rev_Dir&quot;, &quot;color&quot;: QColor(152, 192, 84), &quot;style&quot;: &quot;#98c054&quot;, &quot;action&quot;: &quot;color&quot;},
            {&quot;name&quot;: &quot;Approved&quot;, &quot;color&quot;: QColor(36, 76, 25), &quot;style&quot;: &quot;#244c19&quot;, &quot;action&quot;: &quot;color&quot;},
            {&quot;name&quot;: &quot;Rev_Sup_D&quot;, &quot;color&quot;: QColor(82, 61, 128), &quot;style&quot;: &quot;#523d80&quot;, &quot;action&quot;: &quot;color&quot;},
            {&quot;name&quot;: &quot;Rev_Dir_D&quot;, &quot;color&quot;: QColor(77, 33, 168), &quot;style&quot;: &quot;#4d21a8&quot;, &quot;action&quot;: &quot;color&quot;},
        ]

        
        self.num_columns = 1  # Inicialmente una columna
        self.create_buttons()

        # Conectar la señal de cambio de tamaño del widget al método correspondiente
        self.adjust_columns_on_resize()
        self.resizeEvent = self.adjust_columns_on_resize

    def create_buttons(self):
        for index, button_info in enumerate(self.buttons):
            name = button_info[&quot;name&quot;]
            color = button_info[&quot;color&quot;]
            style = button_info[&quot;style&quot;]
            action = button_info[&quot;action&quot;]

            button = QPushButton(name)
            button.setStyleSheet(f&quot;background-color: {style}&quot;)
            if action == &quot;color&quot;:
                button.clicked.connect(self.handle_color_button_click(color, name))
            elif action == &quot;fpt_pull&quot;:
                button.clicked.connect(self.run_FPT_pull)
            elif action == &quot;clear_tag&quot;:
                button.clicked.connect(self.run_clear_tag_script)
            elif action == &quot;shot_info&quot;:
                button.clicked.connect(self.run_shot_info_script)
                if &quot;shortcut&quot; in button_info:
                    button.setShortcut(QKeySequence(button_info[&quot;shortcut&quot;]))

            row = index // self.num_columns
            column = index % self.num_columns
            self.layout.addWidget(button, row, column)

    def handle_color_button_click(self, color, button_name):
        def button_click_handler(_):
            confirmation = self.confirm_status_application(button_name)
            if confirmation:
                self.change_clip_color_and_push_status(color, button_name)
                if button_name in [&quot;Rev_Dir&quot;, &quot;Corrections&quot;]:
                    self.run_clear_tag_script()
        return button_click_handler

    def parse_exr_name(self, exr_name):
        # Ajustar el manejo del formato del nombre del archivo EXR
        if '%04d' in exr_name:
            exr_name = exr_name.replace('.%', '_%')  # Reemplazar patrón para análisis

        parts = exr_name.split('_')
        if len(parts) &lt; 7 or not parts[-2].startswith('v'):
            raise ValueError(f&quot;Nombre del archivo EXR no tiene el formato esperado: {exr_name}&quot;)
        base_name = '_'.join(parts[:-1])  # Todas las partes excepto la última forman el base_name
        return base_name

    def push_task_status(self, button_name, base_name):
        try:
            script_path = os.path.join(os.path.dirname(__file__), 'LGA_NKS_Flow', 'LGA_NKS_Flow_Push.py')
            if os.path.exists(script_path):
                import importlib.util
                spec = importlib.util.spec_from_file_location(&quot;LGA_NKS_Flow_Push&quot;, script_path)
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                module.Push_Task_Status(button_name, base_name)
            else:
                debug_print(f&quot;Script not found at path: {script_path}&quot;)
        except Exception as e:
            debug_print(f&quot;Error during push task status operation: {e}&quot;)

    def change_clip_color_and_push_status(self, color, button_name):
        try:
            seq = hiero.ui.activeSequence()
            if seq:
                te = hiero.ui.getTimelineEditor(seq)
                selected_items = te.selection()

                project = hiero.core.projects()[0]
                project.beginUndo(&quot;Change Clip Color&quot;)

                for item in selected_items:
                    if not isinstance(item, hiero.core.EffectTrackItem):
                        bin_item = item.source().binItem()
                        if item.source().mediaSource().isMediaPresent():
                            active_version = bin_item.activeVersion()
                            if active_version:
                                bin_item.setColor(color)

                            file_path = item.source().mediaSource().fileinfos()[0].filename() if item.source().mediaSource().fileinfos() else None
                            if not file_path or '_comp_' not in os.path.basename(file_path).lower():
                                continue
                            exr_name = os.path.basename(file_path)
                            exr_name = exr_name.replace('.%', '_%')  # Reemplazar patrón para análisis
                            try:
                                base_name = self.parse_exr_name(exr_name)
                                debug_print(f&quot;Status: {button_name}, Shot: {base_name}&quot;)
                                self.push_task_status(button_name, base_name)
                            except ValueError as e:
                                debug_print(f&quot;Error: {e}&quot;)
                project.endUndo()
            else:
                pass
        except Exception as e:
            debug_print(f&quot;Error during operation: {e}&quot;)


    def confirm_status_application(self, status):
        seq = hiero.ui.activeSequence()
        if seq:
            te = hiero.ui.getTimelineEditor(seq)
            selected_items = te.selection()
            if len(selected_items) &gt; 4:
                msg = QMessageBox()
                msg.setIcon(QMessageBox.Question)
                msg.setWindowTitle(&quot;Confirm Status Application&quot;)
                msg.setText(f&quot;Are you sure you want to apply the status '{status}' to {len(selected_items)} clips?&quot;)
                msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
                result = msg.exec_()
                return result == QMessageBox.Yes
        return True

    def adjust_columns_on_resize(self, event=None):
        # Obtener el ancho actual del widget
        panel_width = self.width()
        button_width = 100  # Ancho aproximado de cada botón
        min_button_spacing = 10  # Espacio mínimo entre botones

        # Calcular el número de columnas en función del ancho del widget
        self.num_columns = max(1, (panel_width + min_button_spacing) // (button_width + min_button_spacing))

        # Limpiar el layout actual y eliminar widgets solo si existen
        while self.layout.count():
            item = self.layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

        # Volver a crear los botones con el nuevo número de columnas
        self.create_buttons()

        # Calcular el número de filas usadas
        num_rows = (len(self.buttons) + self.num_columns - 1) // self.num_columns

        # Añadir el espaciador vertical
        spacer = QSpacerItem(20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding)
        self.layout.addItem(spacer, num_rows, 0, 1, self.num_columns)

    def run_FPT_pull(self):
        # Obtener el proyecto actual
        project = hiero.core.projects()[0] if hiero.core.projects() else None
        if project:
            project.beginUndo(&quot;Run External Script&quot;)
            try:
                # Importar y ejecutar el script de la subcarpeta
                script_path = os.path.join(os.path.dirname(__file__), 'LGA_NKS_Flow', 'LGA_NKS_Flow_Pull.py')
                if os.path.exists(script_path):
                    try:
                        import importlib.util
                        spec = importlib.util.spec_from_file_location(&quot;LGA_NKS_Flow_Pull&quot;, script_path)
                        module = importlib.util.module_from_spec(spec)
                        spec.loader.exec_module(module)
                        module.FPT_Hiero()
                        #debug_print(&quot;Script ejecutado correctamente.&quot;)
                    except Exception as e:
                        debug_print(f&quot;Error al ejecutar el script: {e}&quot;)
                else:
                    debug_print(f&quot;Script no encontrado en la ruta: {script_path}&quot;)
            finally:
                project.endUndo()

    def run_clear_tag_script(self):
        project = hiero.core.projects()[0] if hiero.core.projects() else None
        if project:
            project.beginUndo(&quot;Run External Script&quot;)
            try:
                seq = hiero.ui.activeSequence()
                if seq:
                    te = hiero.ui.getTimelineEditor(seq)
                    selected_items = te.selection()

                    for item in selected_items:
                        if not isinstance(item, hiero.core.EffectTrackItem):  # Verificación de que el clip no sea un efecto
                            # Importar y ejecutar el script de la subcarpeta para cada clip válido
                            script_path = os.path.join(os.path.dirname(__file__), 'LGA_NKS_Flow', 'LGA_NKS_Delete_ClipTags.py')
                            if os.path.exists(script_path):
                                try:
                                    import importlib.util
                                    spec = importlib.util.spec_from_file_location(&quot;LGA_H_DeleteClipTags&quot;, script_path)
                                    module = importlib.util.module_from_spec(spec)
                                    spec.loader.exec_module(module)
                                    module.delete_tags_from_clip(item)  # Pasar el clip válido como parámetro
                                    # debug_print(&quot;Script ejecutado correctamente.&quot;)
                                except Exception as e:
                                    debug_print(f&quot;Error al ejecutar el script para el clip {item}: {e}&quot;)
                            else:
                                debug_print(f&quot;Script no encontrado en la ruta: {script_path}&quot;)
            finally:
                project.endUndo()




    def run_shot_info_script(self):
        project = hiero.core.projects()[0] if hiero.core.projects() else None
        if project:
            project.beginUndo(&quot;Run External Script&quot;)
            try:
                script_path = os.path.join(os.path.dirname(__file__), 'LGA_NKS_Flow', 'LGA_NKS_Flow_Shot_info.py')
                if os.path.exists(script_path):
                    try:
                        import importlib.util
                        spec = importlib.util.spec_from_file_location(&quot;LGA_NKS_Flow_Shot_info&quot;, script_path)
                        module = importlib.util.module_from_spec(spec)
                        spec.loader.exec_module(module)
                        module.main()  # Asumimos que el script tiene un método main
                    except Exception as e:
                        debug_print(f&quot;Error al ejecutar el script: {e}&quot;)
                else:
                    debug_print(f&quot;Script no encontrado en la ruta: {script_path}&quot;)
            finally:
                project.endUndo()






# Crear la instancia del widget y añadirlo al gestor de ventanas de Hiero
colorChanger = ColorChangeWidget()
wm = hiero.ui.windowManager()
wm.addWindow(colorChanger)
&quot;&quot;&quot;
_____________________________________________________

  LGA_NKS_Flow_Shot_info v1.3 - 2024 - Lega Pugliese
  Imprime información del shot y las varsiones 
_____________________________________________________

&quot;&quot;&quot;

import hiero.core
import os
import re
import json
import sys
from PySide2.QtCore import QCoreApplication, Qt
from PySide2.QtGui import QFontMetrics, QKeySequence
from PySide2.QtWidgets import QWidget, QVBoxLayout, QTextEdit, QApplication, QShortcut


# Variable global para activar o desactivar los prints
DEBUG = False

def debug_print(*message):
    if DEBUG:
        print(*message)


app = None
window = None


class ShotGridManager:
    &quot;&quot;&quot;Clase para manejar operaciones con datos de un archivo JSON en lugar de ShotGrid.&quot;&quot;&quot;
    def __init__(self, json_path):
        with open(json_path, 'r', encoding='utf-8') as file:
            self.data = json.load(file)

    def find_project(self, project_name):
        &quot;&quot;&quot;Busca un proyecto por nombre en el JSON.&quot;&quot;&quot;
        return next((p for p in self.data['projects'] if p['project_name'] == project_name), None)

    def find_shot(self, project_name, shot_code):
        &quot;&quot;&quot;Busca un shot por nombre y código en el JSON.&quot;&quot;&quot;
        project = self.find_project(project_name)
        if project:
            return next((s for s in project['shots'] if s['shot_name'] == shot_code), None)
        return None

    def find_task(self, shot, task_name):
        &quot;&quot;&quot;Busca una tarea específica por nombre en un shot.&quot;&quot;&quot;
        return next((t for t in shot['tasks'] if t['task_type'].lower() == task_name.lower()), None)


class HieroOperations:
    &quot;&quot;&quot;Clase para manejar operaciones en Hiero.&quot;&quot;&quot;
    def __init__(self, shotgrid_manager):
        self.sg_manager = shotgrid_manager

    def parse_exr_name(self, file_name):
        &quot;&quot;&quot;Extrae el nombre base del archivo EXR y el número de versión.&quot;&quot;&quot;
        base_name = re.sub(r'_%04d\.exr$', '', file_name)
        version_match = re.search(r'_v(\d+)', base_name)
        version_number = version_match.group(1) if version_match else 'Unknown'
        return base_name, version_number

    def process_selected_clips(self):
        &quot;&quot;&quot;Procesa los clips seleccionados en el timeline de Hiero.&quot;&quot;&quot;
        debug_print(&quot;Processing selected clips...&quot;)
        seq = hiero.ui.activeSequence()
        if seq:
            te = hiero.ui.getTimelineEditor(seq)
            selected_clips = te.selection()
            results = []

            if selected_clips:
                for clip in selected_clips:
                    file_path = clip.source().mediaSource().fileinfos()[0].filename()
                    exr_name = os.path.basename(file_path)
                    base_name, version_number = self.parse_exr_name(exr_name)

                    project_name = base_name.split('_')[0]
                    parts = base_name.split('_')
                    shot_code = '_'.join(parts[:5])

                    # Realizar operación intensiva en el JSON
                    QCoreApplication.processEvents()
                    shot = self.sg_manager.find_shot(project_name, shot_code)
                    debug_print(f&quot;Shot found: {shot}&quot;)
                    
                    QCoreApplication.processEvents()
                    if shot:
                        task = self.sg_manager.find_task(shot, &quot;comp&quot;)
                        debug_print(f&quot;Task found: {task}&quot;)
                        task_description = task['task_description'] if task else &quot;No info available&quot;
                        assignee = task['task_assigned_to'] if task else &quot;No assignee&quot;
                        versions = task['versions'] if task else []
                        
                        # Obtener las tres últimas versiones
                        last_versions = sorted(versions, key=lambda v: v['version_date'], reverse=True)[:3]
                        version_info = [{'version_number': re.search(r'v(\d+)', v['version_number']).group(), 'version_description': v['version_description'] or &quot;No description&quot;, 'comments': v['comments']} for v in last_versions]
                        
                        shot_info = {
                            &quot;shot_code&quot;: shot['shot_name'],
                            &quot;description&quot;: task_description,
                            &quot;assignee&quot;: assignee,
                            &quot;versions&quot;: version_info
                        }
                        results.append(shot_info)
                    QCoreApplication.processEvents()
            debug_print(&quot;Processing completed.&quot;)
            return results
        else:
            debug_print(&quot;No se encontró una secuencia activa en Hiero.&quot;)
            return []


class GUIWindow(QWidget):
    def __init__(self, hiero_ops, parent=None):
        super(GUIWindow, self).__init__(parent)
        self.hiero_ops = hiero_ops
        self.initUI()

    def initUI(self):
        self.setWindowTitle(&quot;Info&quot;)
        layout = QVBoxLayout(self)
        self.text_edit = QTextEdit()
        self.text_edit.setReadOnly(True)
        layout.addWidget(self.text_edit)
        self.setLayout(layout)

        # Añadir evento para cerrar la ventana con la tecla ESC
        shortcut = QShortcut(QKeySequence(Qt.Key_Escape), self)
        shortcut.activated.connect(self.close)


    def display_results(self, results):
        &quot;&quot;&quot;Muestra los resultados recopilados en una ventana independiente.&quot;&quot;&quot;
        debug_print(&quot;Displaying results...&quot;)
        message = &quot;&quot;&quot;
        &lt;style&gt;
            p { line-height: 1.5; margin: 0; padding: 0; }
            b { color: #CCCC00; }
            .assignee { color: #007ACC; font-weight: bold; }
            .version { color: #007ACC; font-weight: bold; }
            .description-title { color: #009688; font-weight: bold; }
            .comment { display: inline; margin-left: 20px; }
            .comment-user { color: #AAAAAA; } /* Nuevo estilo para los nombres de comentaristas */
        &lt;/style&gt;
        &quot;&quot;&quot;
        lines = []
        total_lines = 0

        for result in results:
            debug_print(f&quot;Processing result: {result}&quot;)
            description = result['description'] if result['description'] is not None else &quot;No info available&quot;
            assignee = result['assignee'] if result['assignee'] is not None else &quot;No assignee&quot;
            versions = result['versions']

            shot_code = f&quot;&lt;b&gt;{result['shot_code']}&lt;/b&gt;&quot;
            assignee_formatted = f&quot;&lt;span class='assignee'&gt;{assignee}&lt;/span&gt;&quot;

            lines.append(f&quot;{shot_code} | {assignee_formatted}&quot;)
            message += f&quot;&lt;p&gt;{shot_code} | {assignee_formatted}&lt;br&gt;&quot;
            message += f&quot;&lt;span class='description-title'&gt;Description:&lt;/span&gt; {description}&lt;br&gt;&quot;

            total_lines += 3  # Cada resultado tiene al menos 3 líneas
            for version in versions:
                version_number = version['version_number'].split('_')[-1]
                version_line = f&quot;&lt;span class='version'&gt;{version_number}:&lt;/span&gt; {version['version_description']}&lt;br&gt;&quot;
                lines.append(version_line)
                message += version_line
                total_lines += 1

                for comment in version['comments']:
                    comment_user = comment['user']
                    comment_text = comment['text'].replace('\n', '&lt;br&gt;')
                    comment_line = f&quot;&lt;b class='comment-user'&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{comment_user}:&lt;/b&gt; {comment_text}&quot;
                    
                    # Usar span en lugar de div para evitar saltos de línea
                    lines.append(comment_line)
                    message += f&quot;&lt;span class='comment'&gt;{comment_line}&lt;/span&gt;&lt;br&gt;&quot;
                    total_lines += 1

            message += &quot;&lt;/p&gt;&quot;
            total_lines += 4  # Añadir una línea adicional por el espacio del &lt;/p&gt; y una más por margen entre shots

        self.text_edit.setHtml(message.strip())  # Eliminar cualquier espacio en blanco al final
        self.adjustSize()  # Ajusta el tamaño del diálogo según su contenido

        # Encontrar la longitud de la línea más larga
        longest_line = max(lines, key=len)
        longest_line_length = len(longest_line)
        debug_print(f&quot;Longest line: {longest_line}&quot;)
        debug_print(f&quot;Longest line length (characters): {longest_line_length}&quot;)

        # Calcular el ancho basado en la longitud de la línea más larga
        font_metrics = QFontMetrics(self.text_edit.font())
        char_width = font_metrics.averageCharWidth()
        char_height = font_metrics.height()
        debug_print(f&quot;Average character width (pixels): {char_width}&quot;)
        width = longest_line_length * char_width + 10  # Sumar un pequeño margen
        debug_print(f&quot;Calculated width (pixels): {width}&quot;)
        height = total_lines * char_height + 40  # Sumar un margen adicional para evitar cortes

        # Limitar el tamaño máximo de la ventana
        max_width = 1920
        max_height = 1080

        if width &gt; max_width:
            width = max_width
        if height &gt; max_height:
            height = max_height

        self.resize(width, height)  # Redimensiona el diálogo con el nuevo ancho y altura

        self.setWindowFlags(self.windowFlags() | Qt.Window)  # Asegurarse de que la ventana sea independiente
        self.show()  # Mostrar la ventana
        debug_print(&quot;Results displayed successfully.&quot;)
        debug_print(f&quot;Final window size - Width: {width}, Height: {height}&quot;)

def main():
    global app, window

    # Obtén el path del script actual
    script_path = os.path.dirname(__file__)

    # Genera la ruta relativa para el archivo JSON
    json_path = os.path.join(script_path, 'Data', 'LGA_NKS_Flow_Downloader_Local.json')

    # Verifica si el archivo JSON existe
    if not os.path.exists(json_path):
        debug_print(f&quot;JSON file not found at path: {json_path}&quot;)
        return

    sg_manager = ShotGridManager(json_path)
    hiero_ops = HieroOperations(sg_manager)

    if not QApplication.instance():
        app = QApplication(sys.argv)
    else:
        app = QApplication.instance()

    window = GUIWindow(hiero_ops)
    results = hiero_ops.process_selected_clips()
    debug_print(f&quot;Results: {results}&quot;)
    window.display_results(results)
    window.show()
    app.exec_()

if __name__ == &quot;__main__&quot;:
    main()
import nuke

def process_merge_nodes():
    # Obtener todos los nodos seleccionados
    selected_nodes = nuke.selectedNodes()
    print(&quot;Nodos seleccionados: &quot;, [node.name() for node in selected_nodes])
    
    # Filtrar los nodos Merge seleccionados
    merge_nodes = [node for node in selected_nodes if node.Class() == 'Merge2']
    print(&quot;Nodos Merge seleccionados: &quot;, [node.name() for node in merge_nodes])
    
    for node in merge_nodes:
        current_operation = node['operation'].value()
        current_bbox = node['bbox'].value()
        print(f&quot;Procesando nodo: {node.name()}&quot;)
        print(f&quot;  Operación actual: {current_operation}&quot;)
        print(f&quot;  Bbox actual: {current_bbox}&quot;)
        
        if current_operation == 'over':
            node['operation'].setValue('mask')
            node['bbox'].setValue('A')
            print(f&quot;  Nueva operación: mask&quot;)
            print(f&quot;  Nuevo bbox: A&quot;)
        elif current_operation == 'mask':
            node['operation'].setValue('stencil')
            node['bbox'].setValue('B')
            print(f&quot;  Nueva operación: stencil&quot;)
            print(f&quot;  Nuevo bbox: B&quot;)
        elif current_operation == 'stencil':
            node['operation'].setValue('over')
            node['bbox'].setValue('B')
            print(f&quot;  Nueva operación: over&quot;)
            print(f&quot;  Nuevo bbox: B&quot;)
        else:
            print(&quot;  Operación no reconocida, no se realizaron cambios.&quot;)
    
# Ejecuta la función
process_merge_nodes()
import importlib
import Dots
importlib.reload(Dots)

import nuke

def Dots():
    try:
        nuke.Undo().begin()  # Iniciar el undo
        nuke.Undo().name(&quot;Create Dots&quot;)
        dotList, dotListX = [], []
        Dsize = int(nuke.toNode(&quot;preferences&quot;)['dot_node_scale'].value() * 12)
        nodes = nuke.selectedNodes()
        count = 0
        same = 1
        old = &quot;&quot;
        for selected in nodes:
            selectedX, selectedY = int(selected.xpos()), int(selected.ypos())
            selectedW, selectedH = int(selected.screenWidth()), int(selected.screenHeight())

            # checking inputs and assigning variables
            try:  # check if input 0 is exist
                A = selected.input(0)
                AX = int(A.xpos())
                AY = int(A.ypos())
                AW = int(A.screenWidth())
                AH = int(A.screenHeight())
                AClass = A.Class()
                if count == 0:
                    old = A
                    count = count + 1
                else:
                    if old != A:
                        same = 0
            except:
                AX, AY = int(selected.xpos()), int(selected.ypos())
                AW, AH = int(selected.screenWidth()), int(selected.screenHeight())
                AClass = &quot;no classs&quot;
            try:  # check if input 1 is exist
                B = selected.input(1)
                BX, BY = int(B.xpos()), int(B.ypos())
                BW, BH = int(B.screenWidth()), int(B.screenHeight())
                BClass = B.Class()
                print(&quot; Input 1 found   &quot; + B['name'].value())
            except:
                BX, BY = int(selected.xpos()), int(selected.ypos())
                BW, BH = int(selected.screenWidth()), int(selected.screenHeight())
                BClass = &quot;no classs&quot;
                print(&quot; no input1 found        &quot;)
            try:  # check if input 2 is exist
                C = selected.input(2)
                CX, CY = int(C.xpos()), int(C.ypos())
                CW, CH = int(C.screenWidth()), int(C.screenHeight())
                CClass = C.Class()
                print(&quot; Input 2 found   &quot; + C['name'].value())
            except:
                print(&quot; &quot;)

            # setting position
            if B and not C:  # two inputs found

                # 'normal merge case'
                create_dot_for_B = True  # Suponemos que necesitamos crear el Dot
                # Comprobar si B ya es un Dot y está en la misma posición Y que el nuevo Dot que crearíamos
                if B is not None:
                    BY = int(B.ypos())
                    BH = int(B.screenHeight())
                    if B.Class() == &quot;Dot&quot; and BY == selectedY + selectedH / 2 - Dsize / 2:
                        create_dot_for_B = False
                    # Comprobar si el nodo B no es un Dot pero su centro en Y coincide con el centro en Y del nodo seleccionado
                    elif BY + BH / 2 == selectedY + selectedH / 2:
                        create_dot_for_B = False

                if create_dot_for_B:
                    Dot = nuke.nodes.Dot()
                    Dot.setInput(0, B)
                    selected.setInput(1, Dot)
                    Dot.setXYpos(int(BX + BW / 2 - Dsize / 2), int(selectedY + selectedH / 2 - Dsize / 2))

                if A is not None:  # Asegurarse de que A no es None
                    AX = int(A.xpos())
                    if A.Class() == &quot;Dot&quot;:
                        selected.knob(&quot;xpos&quot;).setValue(int(AX - selectedW / 2 + Dsize / 2))
                    else:
                        selected.knob(&quot;xpos&quot;).setValue(int(AX))

                print('two inputs found')

            elif C:  # three inputs found
                if &quot;Scanline&quot; in selected.Class():
                    if BClass != &quot;no classs&quot;:
                        # Establecer la posición en X del nodo seleccionado basado en B, si B es un Dot
                        if B.Class() == &quot;Dot&quot;:
                            selected.setXYpos(int(BX - selectedW / 2 + Dsize / 2), int(selectedY))
                        else:
                            selected.setXYpos(int(BX), int(selectedY))

                    # Comprobar para C antes de crear y conectar un nuevo Dot
                    create_dot_for_C = True
                    if C is not None:
                        CY = int(C.ypos())
                        CH = int(C.screenHeight())
                        if C.Class() == &quot;Dot&quot; and CY == selectedY + selectedH / 2 - Dsize / 2:
                            create_dot_for_C = False
                        elif CY + CH / 2 == selectedY + selectedH / 2:
                            create_dot_for_C = False

                    if create_dot_for_C:
                        dot = nuke.nodes.Dot(xpos=CX + CW / 2 - Dsize / 2, ypos=selectedY + selectedH / 2 - Dsize / 2)
                        dot.setInput(0, C)
                        selected.setInput(2, dot)

                    # Comprobar para A antes de crear y conectar un nuevo Dot
                    create_dot_for_A = True
                    if A is not None and AClass != &quot;no classs&quot;:
                        AY = int(A.ypos())
                        AH = int(A.screenHeight())
                        if A.Class() == &quot;Dot&quot; and AY == selectedY + selectedH / 2 - Dsize / 2:
                            create_dot_for_A = False
                        elif AY + AH / 2 == selectedY + selectedH / 2:
                            create_dot_for_A = False

                    if create_dot_for_A:
                        dot = nuke.nodes.Dot(xpos=AX + AW / 2 - Dsize / 2, ypos=selectedY + selectedH / 2 - Dsize / 2)
                        dot.setInput(0, A)
                        selected.setInput(0, dot)

                    print(&quot;Scanline&quot;)

                if &quot;Merge&quot; in selected.Class() or &quot;Roto&quot; in selected.Class() or &quot;Keymix&quot; in selected.Class():

                    if A.Class() == &quot;Dot&quot;:
                        selected.knob(&quot;xpos&quot;).setValue(int(AX - selectedW / 2 + Dsize / 2))
                    else:
                        selected.knob(&quot;xpos&quot;).setValue(int(AX))

                    # Comprobar si el nodo C es un DOT y si su posición en Y es la misma que la del nuevo DOT que estamos por crear
                    create_dot_for_C = True
                    if C.Class() == &quot;Dot&quot; and CY == selectedY + selectedH / 2 - Dsize / 2:
                        create_dot_for_C = False
                    # Además, comprobar si el nodo C no es un DOT pero su posición en Y es la misma que la del nuevo DOT
                    elif CY + CH / 2 == selectedY + selectedH / 2:
                        create_dot_for_C = False

                    if create_dot_for_C:
                        # crear el nodo DOT a la derecha
                        dot = nuke.nodes.Dot(xpos=CX + CW / 2 - Dsize / 2, ypos=selectedY + selectedH / 2 - Dsize / 2)
                        # conectar el nodo dot al output del nodo anterior
                        dot.setInput(0, C)
                        # conectar el nodo dot al input del nodo seleccionado
                        selected.setInput(2, dot)

                    # Comprobar si el nodo B es un DOT y si su posición en Y es la misma que la del nuevo DOT que estamos por crear
                    create_dot_for_B = True
                    if B.Class() == &quot;Dot&quot; and BY == selectedY + selectedH / 2 - Dsize / 2:
                        create_dot_for_B = False
                    # Comprobar si el nodo B no es un DOT y su centro en Y es el mismo que el centro del nodo seleccionado
                    elif BY + BH / 2 == selectedY + selectedH / 2:
                        create_dot_for_B = False

                    if create_dot_for_B:
                        # crear el nodo DOT a la derecha
                        dot = nuke.nodes.Dot(xpos=BX + BW / 2 - Dsize / 2, ypos=selectedY + selectedH / 2 - Dsize / 2)
                        # conectar el nodo dot al output del nodo anterior
                        dot.setInput(0, B)
                        # conectar el nodo dot al input del nodo seleccionado
                        selected.setInput(1, dot)

                    print('three input found')

            else:  # one input found
                print('one input found')
                Dot = nuke.nodes.Dot()
                Dot.setInput(0, A)
                selected.setInput(0, Dot)
                Dot.setXYpos(int(selectedX + selectedW / 2 - Dsize / 2), int(AY + AH / 2 - Dsize / 2))
                dotList.append(Dot)
                dotListX.append(Dot.xpos())
    except Exception as e:
        nuke.Undo().cancel()
        raise e
    finally:
        nuke.Undo().end()

# Ejecutar la función
Dots()
import nuke

def Dots():
    try:
        nuke.Undo().begin()  # Iniciar el undo
        nuke.Undo().name(&quot;Create Dots&quot;)
        dotList, dotListX = [], []
        Dsize = int(nuke.toNode(&quot;preferences&quot;)['dot_node_scale'].value() * 12)
        nodes = nuke.selectedNodes()
        count = 0
        same = 1
        old = &quot;&quot;
        for selected in nodes:
            selectedX, selectedY = int(selected.xpos()), int(selected.ypos())
            selectedW, selectedH = int(selected.screenWidth()), int(selected.screenHeight())

            # checking inputs and assigning variables
            try:  # check if input 0 is exist
                A = selected.input(0)
                AX = int(A.xpos())
                AY = int(A.ypos())
                AW = int(A.screenWidth())
                AH = int(A.screenHeight())
                AClass = A.Class()
                if count == 0:
                    old = A
                    count = count + 1
                else:
                    if old != A:
                        same = 0
            except:
                AX, AY = int(selected.xpos()), int(selected.ypos())
                AW, AH = int(selected.screenWidth()), int(selected.screenHeight())
                AClass = &quot;no classs&quot;
            try:  # check if input 1 is exist
                B = selected.input(1)
                BX, BY = int(B.xpos()), int(B.ypos())
                BW, BH = int(B.screenWidth()), int(B.screenHeight())
                BClass = B.Class()
                print(&quot; Input 1 found   &quot; + B['name'].value())
            except:
                BX, BY = int(selected.xpos()), int(selected.ypos())
                BW, BH = int(selected.screenWidth()), int(selected.screenHeight())
                BClass = &quot;no classs&quot;
                print(&quot; no input1 found        &quot;)
            try:  # check if input 2 is exist
                C = selected.input(2)
                CX, CY = int(C.xpos()), int(C.ypos())
                CW, CH = int(C.screenWidth()), int(C.screenHeight())
                CClass = C.Class()
                print(&quot; Input 2 found   &quot; + C['name'].value())
            except:
                print(&quot; &quot;)

            # setting position
            if B and not C:  # two inputs found

                # 'normal merge case'
                create_dot_for_B = True  # Suponemos que necesitamos crear el Dot
                # Comprobar si B ya es un Dot y está en la misma posición Y que el nuevo Dot que crearíamos
                if B is not None:
                    BY = int(B.ypos())
                    BH = int(B.screenHeight())
                    if B.Class() == &quot;Dot&quot; and BY == selectedY + selectedH / 2 - Dsize / 2:
                        create_dot_for_B = False
                    # Comprobar si el nodo B no es un Dot pero su centro en Y coincide con el centro en Y del nodo seleccionado
                    elif BY + BH / 2 == selectedY + selectedH / 2:
                        create_dot_for_B = False

                if create_dot_for_B:
                    Dot = nuke.nodes.Dot()
                    Dot.setInput(0, B)
                    selected.setInput(1, Dot)
                    Dot.setXYpos(int(BX + BW / 2 - Dsize / 2), int(selectedY + selectedH / 2 - Dsize / 2))

                if A is not None:  # Asegurarse de que A no es None
                    AX = int(A.xpos())
                    if A.Class() == &quot;Dot&quot;:
                        selected.knob(&quot;xpos&quot;).setValue(int(AX - selectedW / 2 + Dsize / 2))
                    else:
                        selected.knob(&quot;xpos&quot;).setValue(int(AX))

                print('two inputs found')

            elif C:  # three inputs found
                if &quot;Scanline&quot; in selected.Class():
                    if BClass != &quot;no classs&quot;:
                        # Establecer la posición en X del nodo seleccionado basado en B, si B es un Dot
                        if B.Class() == &quot;Dot&quot;:
                            selected.setXYpos(int(BX - selectedW / 2 + Dsize / 2), int(selectedY))
                        else:
                            selected.setXYpos(int(BX), int(selectedY))

                    # Comprobar para C antes de crear y conectar un nuevo Dot
                    create_dot_for_C = True
                    if C is not None:
                        CY = int(C.ypos())
                        CH = int(C.screenHeight())
                        if C.Class() == &quot;Dot&quot; and CY == selectedY + selectedH / 2 - Dsize / 2:
                            create_dot_for_C = False
                        elif CY + CH / 2 == selectedY + selectedH / 2:
                            create_dot_for_C = False

                    if create_dot_for_C:
                        dot = nuke.nodes.Dot(xpos=CX + CW / 2 - Dsize / 2, ypos=selectedY + selectedH / 2 - Dsize / 2)
                        dot.setInput(0, C)
                        selected.setInput(2, dot)

                    # Comprobar para A antes de crear y conectar un nuevo Dot
                    create_dot_for_A = True
                    if A is not None and AClass != &quot;no classs&quot;:
                        AY = int(A.ypos())
                        AH = int(A.screenHeight())
                        if A.Class() == &quot;Dot&quot; and AY == selectedY + selectedH / 2 - Dsize / 2:
                            create_dot_for_A = False
                        elif AY + AH / 2 == selectedY + selectedH / 2:
                            create_dot_for_A = False

                    if create_dot_for_A:
                        dot = nuke.nodes.Dot(xpos=AX + AW / 2 - Dsize / 2, ypos=selectedY + selectedH / 2 - Dsize / 2)
                        dot.setInput(0, A)
                        selected.setInput(0, dot)

                    print(&quot;Scanline&quot;)

                if &quot;Merge&quot; in selected.Class() or &quot;Roto&quot; in selected.Class() or &quot;Keymix&quot; in selected.Class():

                    if A.Class() == &quot;Dot&quot;:
                        selected.knob(&quot;xpos&quot;).setValue(int(AX - selectedW / 2 + Dsize / 2))
                    else:
                        selected.knob(&quot;xpos&quot;).setValue(int(AX))

                    # Comprobar si el nodo C es un DOT y si su posición en Y es la misma que la del nuevo DOT que estamos por crear
                    create_dot_for_C = True
                    if C.Class() == &quot;Dot&quot; and CY == selectedY + selectedH / 2 - Dsize / 2:
                        create_dot_for_C = False
                    # Además, comprobar si el nodo C no es un DOT pero su posición en Y es la misma que la del nuevo DOT
                    elif CY + CH / 2 == selectedY + selectedH / 2:
                        create_dot_for_C = False

                    if create_dot_for_C:
                        # crear el nodo DOT a la derecha
                        dot = nuke.nodes.Dot(xpos=CX + CW / 2 - Dsize / 2, ypos=selectedY + selectedH / 2 - Dsize / 2)
                        # conectar el nodo dot al output del nodo anterior
                        dot.setInput(0, C)
                        # conectar el nodo dot al input del nodo seleccionado
                        selected.setInput(2, dot)

                    # Comprobar si el nodo B es un DOT y si su posición en Y es la misma que la del nuevo DOT que estamos por crear
                    create_dot_for_B = True
                    if B.Class() == &quot;Dot&quot; and BY == selectedY + selectedH / 2 - Dsize / 2:
                        create_dot_for_B = False
                    # Comprobar si el nodo B no es un DOT y su centro en Y es el mismo que el centro del nodo seleccionado
                    elif BY + BH / 2 == selectedY + selectedH / 2:
                        create_dot_for_B = False

                    if create_dot_for_B:
                        # crear el nodo DOT a la derecha
                        dot = nuke.nodes.Dot(xpos=BX + BW / 2 - Dsize / 2, ypos=selectedY + selectedH / 2 - Dsize / 2)
                        # conectar el nodo dot al output del nodo anterior
                        dot.setInput(0, B)
                        # conectar el nodo dot al input del nodo seleccionado
                        selected.setInput(1, dot)

                    print('three input found')

            else:  # one input found
                print('one input found')
                Dot = nuke.nodes.Dot()
                Dot.setInput(0, A)
                selected.setInput(0, Dot)
                Dot.setXYpos(int(selectedX + selectedW / 2 - Dsize / 2), int(AY + AH / 2 - Dsize / 2))
                dotList.append(Dot)
                dotListX.append(Dot.xpos())
    except Exception as e:
        nuke.Undo().cancel()
        raise e
    finally:
        nuke.Undo().end()

# Ejecutar la función
Dots()
import importlib
import Dots
importlib.reload(Dots)&quot;&quot;&quot;
   
   Imprime la versión en Hiero, versión en ShotGrid (SG), estado de la versión en SG, 
   descripción y URLs de las tareas asociadas para los clips seleccionados en el timeline.
   
&quot;&quot;&quot;


import hiero.core
import os
import re
import shotgun_api3
import sys

class ShotGridManager:
    def __init__(self, url, login, password):
        self.sg = shotgun_api3.Shotgun(url, login=login, password=password)

    def find_shot_and_tasks(self, project_name, shot_code):
        projects = self.sg.find(&quot;Project&quot;, [['name', 'is', project_name]], ['id', 'name'])
        if projects:
            project_id = projects[0]['id']
            filters = [
                ['project', 'is', {'type': 'Project', 'id': project_id}],
                ['code', 'is', shot_code]
            ]
            fields = ['id', 'code', 'description']
            shots = self.sg.find(&quot;Shot&quot;, filters, fields)
            if shots:
                shot_id = shots[0]['id']
                tasks = self.find_tasks_for_shot(shot_id)
                return shots[0], tasks
            else:
                print(&quot;No se encontró el shot.&quot;)
        else:
            print(&quot;No se encontró el proyecto en ShotGrid.&quot;)
        return None, None

    def find_tasks_for_shot(self, shot_id):
        filters = [['entity', 'is', {'type': 'Shot', 'id': shot_id}]]
        fields = ['id', 'content', 'sg_status_list']
        return self.sg.find(&quot;Task&quot;, filters, fields)

    def find_highest_version_for_shot(self, shot_id):
        filters = [['entity', 'is', {'type': 'Shot', 'id': shot_id}]]
        fields = ['code', 'created_at', 'user', 'sg_status_list', 'description']  # Incluye 'description'
        versions = self.sg.find(&quot;Version&quot;, filters, fields)
        comp_versions = [v for v in versions if &quot;_comp_&quot; in v['code'].lower()]
        if comp_versions:
            highest_version = max(comp_versions, key=lambda v: int(re.search(r'_v(\d+)', v['code']).group(1)))
            version_number = re.search(r'_v(\d+)', highest_version['code']).group(1)
            return highest_version, version_number
        return None, None

    def get_task_url(self, task_id):
        return f&quot;{self.sg.base_url}/detail/Task/{task_id}&quot;

class HieroOperations:
    def __init__(self, shotgrid_manager):
        self.sg_manager = shotgrid_manager

    def parse_exr_name(self, file_name):
        base_name = re.sub(r'_%04d\.exr$', '', file_name)
        version_match = re.search(r'_v(\d+)', base_name)
        version_number = version_match.group(1) if version_match else 'Unknown'
        return base_name, version_number

    def process_selected_clips(self):
        seq = hiero.ui.activeSequence()
        if seq:
            te = hiero.ui.getTimelineEditor(seq)
            selected_clips = te.selection()
            if selected_clips:
                for clip in selected_clips:
                    file_path = clip.source().mediaSource().fileinfos()[0].filename()
                    exr_name = os.path.basename(file_path)
                    base_name, hiero_version_number = self.parse_exr_name(exr_name)
                    project_name = base_name.split('_')[0]
                    parts = base_name.split('_')
                    shot_code = '_'.join(parts[:5])

                    shot, tasks = self.sg_manager.find_shot_and_tasks(project_name, shot_code)
                    if shot:
                        sg_highest_version, sg_version_number = self.sg_manager.find_highest_version_for_shot(shot['id'])
                        if sg_highest_version:
                            print(f&quot;- Shot name: {shot['code']}&quot;)
                            print(f&quot;- Version Hiero: v{hiero_version_number}&quot;)
                            print(f&quot;- Version SG: v{sg_version_number}&quot;)
                            print(f&quot;- Version SG status: {sg_highest_version['sg_status_list']}&quot;)
                            print(f&quot;- Description: {sg_highest_version['description']}&quot;)  # Imprime la descripción
                            for task in tasks:
                                task_url = self.sg_manager.get_task_url(task['id'])
                                print(f&quot;  - Task: {task['content']} (Status: {task['sg_status_list']}) URL: {task_url}&quot;)
                    else:
                        print(&quot;No se encontró el shot correspondiente en ShotGrid.&quot;)
            else:
                print(&quot;No se han seleccionado clips en el timeline.&quot;)
        else:
            print(&quot;No se encontró una secuencia activa en Hiero.&quot;)

def main():
    global msg_manager
    sg_url = os.getenv('SHOTGRID_URL')
    sg_login = os.getenv('SHOTGRID_LOGIN')
    sg_password = os.getenv('SHOTGRID_PASSWORD')

    if not sg_url or not sg_login or not sg_password:
        print(&quot;Las variables de entorno SHOTGRID_URL, SHOTGRID_LOGIN y SHOTGRID_PASSWORD deben estar configuradas.&quot;)
        return

    sg_manager = ShotGridManager(sg_url, sg_login, sg_password)
    hiero_ops = HieroOperations(sg_manager)
    hiero_ops.process_selected_clips()

if __name__ == &quot;__main__&quot;:
    main()
import os
import re
import shotgun_api3
import nuke
import webbrowser
import threading

# Variables globales
browser_path = 'C:/Program Files/Google/Chrome/Application/chrome.exe %s'
use_default_browser = True  # Si está en ON, usa el navegador por defecto, si está en OFF, usa browser_path

class ShotGridManager:
    def __init__(self, url, login, password):
        self.sg = shotgun_api3.Shotgun(url, login=login, password=password)

    def find_shot_and_tasks(self, project_name, shot_code):
        print(f&quot;Buscando proyecto: {project_name}, shot: {shot_code}&quot;)
        projects = self.sg.find(&quot;Project&quot;, [['name', 'is', project_name]], ['id', 'name'])
        if projects:
            project_id = projects[0]['id']
            print(f&quot;Proyecto encontrado: {project_id}&quot;)
            filters = [
                ['project', 'is', {'type': 'Project', 'id': project_id}],
                ['code', 'is', shot_code]
            ]
            fields = ['id', 'code', 'description']
            shots = self.sg.find(&quot;Shot&quot;, filters, fields)
            if shots:
                shot_id = shots[0]['id']
                print(f&quot;Shot encontrado: {shot_id}&quot;)
                tasks = self.find_tasks_for_shot(shot_id)
                return shots[0], tasks
            else:
                print(&quot;No se encontró el shot.&quot;)
        else:
            print(&quot;No se encontró el proyecto en ShotGrid.&quot;)
        return None, None

    def find_tasks_for_shot(self, shot_id):
        print(f&quot;Buscando tareas para el shot: {shot_id}&quot;)
        filters = [['entity', 'is', {'type': 'Shot', 'id': shot_id}]]
        fields = ['id', 'content', 'sg_status_list']
        tasks = self.sg.find(&quot;Task&quot;, filters, fields)
        print(f&quot;Tareas encontradas: {tasks}&quot;)
        return tasks

    def get_task_url(self, task_id):
        return f&quot;{self.sg.base_url}/detail/Task/{task_id}&quot;

class NukeOperations:
    def __init__(self, shotgrid_manager):
        self.sg_manager = shotgrid_manager

    def parse_nuke_script_name(self, file_name):
        base_name = re.sub(r'_%04d\.nk$', '', file_name)
        version_match = re.search(r'_v(\d+)', base_name)
        version_number = version_match.group(1) if version_match else 'Unknown'
        return base_name, version_number

    def process_current_script(self):
        file_path = nuke.root().name()
        print(f&quot;Nuke script file path: {file_path}&quot;)
        if file_path:
            nuke_script_name = os.path.basename(file_path)
            print(f&quot;Nuke script name: {nuke_script_name}&quot;)
            base_name, nuke_version_number = self.parse_nuke_script_name(nuke_script_name)
            print(f&quot;Parsed base name: {base_name}, version number: {nuke_version_number}&quot;)
            project_name = base_name.split('_')[0]
            parts = base_name.split('_')
            shot_code = '_'.join(parts[:5])
            print(f&quot;Project name: {project_name}, shot code: {shot_code}&quot;)

            shot, tasks = self.sg_manager.find_shot_and_tasks(project_name, shot_code)
            if shot:
                for task in tasks:
                    if task['content'] == 'Comp':
                        task_url = self.sg_manager.get_task_url(task['id'])
                        print(f&quot;  - Task: {task['content']} (Status: {task['sg_status_list']}) URL: {task_url}&quot;)
                        if use_default_browser:
                            webbrowser.open(task_url)
                        else:
                            webbrowser.get(browser_path).open(task_url)
            else:
                print(&quot;No se encontró el shot correspondiente en ShotGrid.&quot;)
        else:
            print(&quot;No se encontró un script activo en Nuke.&quot;)

def threaded_function():
    sg_url = os.getenv('SHOTGRID_URL')
    sg_login = os.getenv('SHOTGRID_LOGIN')
    sg_password = os.getenv('SHOTGRID_PASSWORD')

    if not sg_url or not sg_login or not sg_password:
        print(&quot;Las variables de entorno SHOTGRID_URL, SHOTGRID_LOGIN y SHOTGRID_PASSWORD deben estar configuradas.&quot;)
        return

    sg_manager = ShotGridManager(sg_url, sg_login, sg_password)
    nuke_ops = NukeOperations(sg_manager)
    nuke_ops.process_current_script()

def main():
    thread = threading.Thread(target=threaded_function)
    thread.start()

if __name__ == &quot;__main__&quot;:
    main()
import nuke

def create_invert_node():
    try:
        # Obtener el nodo actualmente seleccionado
        selected_node = nuke.selectedNode()
        
        # Crear el nodo Invert y asignarlo a una variable
        invert_node = nuke.createNode('Invert', inpanel=False)
        
        # Obtener las coordenadas del nodo seleccionado
        xpos = selected_node.xpos()
        ypos = selected_node.ypos()
        
        # Posicionar el nodo Invert debajo del nodo seleccionado
        invert_node.setXpos(xpos)
        invert_node.setYpos(ypos + 100)  # Ajusta la distancia vertical según sea necesario
        
        # Conectar el nodo Invert al nodo seleccionado
        invert_node.setInput(0, selected_node)
        
        # Verificar y conectar el nodo siguiente
        if selected_node.dependencies():
            next_node = selected_node.dependent(nuke.INPUTS)[0]
            next_node.setInput(0, invert_node)
    except:
        nuke.message(&quot;No node selected or other error. Please select a node first.&quot;)

# Asigna el atajo Shift+I en el contexto del nodegraph
nuke.menu('Node Graph').addCommand('Invert Node', create_invert_node, 'Shift+I')
import nuke
import nukescripts

def apply_colorspace(colorspace):
    # Obtener el nodo seleccionado
    selected_nodes = nuke.selectedNodes()
    if len(selected_nodes) != 1:
        nuke.message(&quot;Selecciona un único nodo de tipo Read o Write.&quot;)
        return
    
    node = selected_nodes[0]
    if node.Class() in ['Read', 'Write']:
        node['colorspace'].setValue(colorspace)
    else:
        nuke.message(&quot;El nodo seleccionado no es de tipo Read o Write.&quot;)

    # Cerrar la ventana después de aplicar el colorspace
    nuke.thisPanel().finishModalDialog(True)

class ColorspacePanel(nukescripts.PythonPanel):
    def __init__(self):
        nukescripts.PythonPanel.__init__(self, &quot;Seleccionar Colorspace&quot;)
        
        # Añadir botones simulando una lista
        self.default_btn = nuke.PyScript_Knob(&quot;default_btn&quot;, &quot;Default&quot;)
        self.addKnob(self.default_btn)
        
        self.aces_2065_1_btn = nuke.PyScript_Knob(&quot;aces_2065_1_btn&quot;, &quot;ACES 2065-1&quot;)
        self.addKnob(self.aces_2065_1_btn)
        
        self.acescg_btn = nuke.PyScript_Knob(&quot;acescg_btn&quot;, &quot;ACEScg&quot;)
        self.addKnob(self.acescg_btn)
        
        self.output_rec_709_btn = nuke.PyScript_Knob(&quot;output_rec_709_btn&quot;, &quot;Output - Rec.709&quot;)
        self.addKnob(self.output_rec_709_btn)
        
    def knobChanged(self, knob):
        if knob == self.default_btn:
            apply_colorspace('Default')
        elif knob == self.aces_2065_1_btn:
            apply_colorspace('ACES 2065-1')
        elif knob == self.acescg_btn:
            apply_colorspace('ACEScg')
        elif knob == self.output_rec_709_btn:
            apply_colorspace('Output - Rec.709')

# Ejecutar la función para abrir la ventana de diálogo
panel = ColorspacePanel()
panel.showModalDialog()
import nuke
import nukescripts
from PySide2.QtWidgets import QApplication, QWidget, QVBoxLayout, QTableWidget, QTableWidgetItem
from PySide2.QtGui import QColor, QBrush, QCursor
from PySide2.QtCore import Qt

def apply_colorspace(colorspace):
    selected_nodes = nuke.selectedNodes()
    if len(selected_nodes) != 1:
        nuke.message(&quot;Selecciona un único nodo de tipo Read o Write.&quot;)
        return
    
    node = selected_nodes[0]
    if node.Class() in ['Read', 'Write']:
        node['colorspace'].setValue(colorspace)
    else:
        nuke.message(&quot;El nodo seleccionado no es de tipo Read o Write.&quot;)
    
    # Cerrar la ventana después de aplicar el colorspace
    app.quit()

class ColorspacePanel(QWidget):
    def __init__(self):
        super(ColorspacePanel, self).__init__()
        self.setWindowTitle(&quot;Seleccionar Colorspace&quot;)
        self.setStyleSheet(&quot;background-color: #0000FF;&quot;)  # Fondo azul

        layout = QVBoxLayout()
        self.table = QTableWidget(4, 1)
        self.table.setHorizontalHeaderLabels(['Colorspace'])
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.verticalHeader().setVisible(False)
        self.table.setSelectionMode(QTableWidget.NoSelection)

        colorspaces = [&quot;Default&quot;, &quot;ACES 2065-1&quot;, &quot;ACEScg&quot;, &quot;Output - Rec.709&quot;]
        for i, colorspace in enumerate(colorspaces):
            item = QTableWidgetItem(colorspace)
            item.setTextAlignment(Qt.AlignCenter)
            item.setForeground(QBrush(QColor(255, 255, 255)))  # Texto blanco
            self.table.setItem(i, 0, item)
        
        self.table.cellClicked.connect(self.cell_clicked)
        layout.addWidget(self.table)
        self.setLayout(layout)
        self.adjust_window_size()

    def cell_clicked(self, row, column):
        colorspaces = [&quot;Default&quot;, &quot;ACES 2065-1&quot;, &quot;ACEScg&quot;, &quot;Output - Rec.709&quot;]
        apply_colorspace(colorspaces[row])

    def adjust_window_size(self):
        self.table.resizeColumnsToContents()
        width = self.table.verticalHeader().width() + self.table.columnWidth(0) + 2 * self.table.frameWidth()
        height = self.table.horizontalHeader().height() + self.table.rowHeight(0) * self.table.rowCount() + 2 * self.table.frameWidth()
        
        self.resize(width, height)
        cursor_pos = QCursor.pos()
        self.move(cursor_pos.x() - width // 2, cursor_pos.y() - height // 2)

app = QApplication.instance() or QApplication([])
window = ColorspacePanel()
window.show()
app.exec_()
import nuke
import nukescripts
from PySide2.QtWidgets import QApplication, QWidget, QVBoxLayout, QTableWidget, QTableWidgetItem
from PySide2.QtGui import QColor, QBrush, QCursor
from PySide2.QtCore import Qt

def apply_colorspace(colorspace):
    selected_nodes = nuke.selectedNodes()
    if len(selected_nodes) != 1:
        nuke.message(&quot;Selecciona un único nodo de tipo Read o Write.&quot;)
        return
    
    node = selected_nodes[0]
    if node.Class() in ['Read', 'Write']:
        node['colorspace'].setValue(colorspace)
    else:
        nuke.message(&quot;El nodo seleccionado no es de tipo Read o Write.&quot;)
    
    # Cerrar la ventana después de aplicar el colorspace
    app.quit()

class ColorspacePanel(QWidget):
    def __init__(self):
        super(ColorspacePanel, self).__init__()
        self.setWindowTitle(&quot;Seleccionar Colorspace&quot;)
        self.setStyleSheet(&quot;background-color: #0000FF;&quot;)  # Fondo azul

        layout = QVBoxLayout()
        self.table = QTableWidget(4, 1)
        self.table.setHorizontalHeaderLabels(['Colorspace'])
        self.table.horizontalHeader().setStretchLastSection(True)
        self.table.verticalHeader().setVisible(False)
        self.table.setSelectionMode(QTableWidget.NoSelection)

        colorspaces = [&quot;Default&quot;, &quot;ACES 2065-1&quot;, &quot;ACEScg&quot;, &quot;Output - Rec.709&quot;]
        for i, colorspace in enumerate(colorspaces):
            item = QTableWidgetItem(colorspace)
            item.setTextAlignment(Qt.AlignCenter)
            item.setForeground(QBrush(QColor(255, 255, 255)))  # Texto blanco
            self.table.setItem(i, 0, item)
        
        self.table.cellClicked.connect(self.cell_clicked)
        layout.addWidget(self.table)
        self.setLayout(layout)
        self.adjust_window_size()

    def cell_clicked(self, row, column):
        colorspaces = [&quot;Default&quot;, &quot;ACES 2065-1&quot;, &quot;ACEScg&quot;, &quot;Output - Rec.709&quot;]
        apply_colorspace(colorspaces[row])

    def adjust_window_size(self):
        self.table.resizeColumnsToContents()
        width = self.table.verticalHeader().width() + self.table.columnWidth(0) + 2 * self.table.frameWidth()
        height = self.table.horizontalHeader().height() + self.table.rowHeight(0) * self.table.rowCount() + 2 * self.table.frameWidth()
        
        self.resize(width, height)
        cursor_pos = QCursor.pos()
        self.move(cursor_pos.x() - width // 2, cursor_pos.y() - height // 2)

app = QApplication.instance() or QApplication([])
window = ColorspacePanel()
window.show()
app.exec_()
&quot;&quot;&quot;
______________________________________________

  LGA_outputRec709 v1.0 - 2024 - Lega Pugliese
______________________________________________

&quot;&quot;&quot;

import nuke

def change_color_space(node):
    # Verificar si el nodo es un Read o un Write
    if node.Class() == 'Read':
        node['colorspace'].setValue('Output - Rec.709')
    elif node.Class() == 'Write':
        node['colorspace'].setValue('Output - Rec.709')
    else:
        #print(&quot;El nodo seleccionado no es un nodo Read ni Write.&quot;)
        pass

def main():
    # Obtener el nodo seleccionado
    selected_nodes = nuke.selectedNodes()

    if selected_nodes:
        for node in selected_nodes:
            change_color_space(node)&quot;&quot;&quot;
________________________________________________________________________________

  LGA_ocio_RnW v1.1 - 2024 - Lega Pugliese
  Tool for applying OCIO color spaces to selected Read and Write nodes.
________________________________________________________________________________

&quot;&quot;&quot;

from PySide2.QtWidgets import QApplication, QWidget, QVBoxLayout, QTableWidget, QTableWidgetItem, QHeaderView, QPushButton, QHBoxLayout
from PySide2.QtCore import Qt, QRect
from PySide2.QtGui import QCursor, QPalette, QColor

import nuke

class SelectedNodeInfo(QWidget):
    def __init__(self, parent=None):
        super(SelectedNodeInfo, self).__init__(parent)
        self.initUI()

    def initUI(self):
        self.setWindowFlags(Qt.FramelessWindowHint)  # Quitar la barra de título estándar
        self.setWindowTitle(&quot;Node Information&quot;)
        layout = QVBoxLayout(self)

        # Create a custom title bar
        title_bar = QWidget(self)
        title_bar.setFixedHeight(20)  # Hacer la barra de título más pequeña
        title_bar_layout = QHBoxLayout(title_bar)
        title_bar_layout.setContentsMargins(0, 0, 0, 0)
        
        # Add a spacer to push the close button to the right
        title_bar_layout.addStretch(1)
        
        # Add the custom close button
        close_button = QPushButton('X', self)
        close_button.setFixedSize(20, 20)
        close_button.setStyleSheet(&quot;background-color: none; color: white; border: none;&quot;)
        close_button.clicked.connect(self.close)
        title_bar_layout.addWidget(close_button)
        
        layout.addWidget(title_bar)

        # Create the table with 1 column and 5 rows
        self.table = QTableWidget(5, 1, self)
        self.table.setHorizontalHeaderLabels(['Output Transf'])
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        
        # Eliminar números de las filas
        self.table.verticalHeader().setVisible(False)
        
        # Centrar los títulos de la columna
        self.table.horizontalHeaderItem(0).setTextAlignment(Qt.AlignCenter)

        # Set the palette for the table to change the selection color to light gray
        palette = self.table.palette()
        palette.setColor(QPalette.Highlight, QColor(230, 230, 230))  # Gris claro
        palette.setColor(QPalette.HighlightedText, QColor(Qt.black))
        self.table.setPalette(palette)

        # Set the style for the table
        self.table.setStyleSheet(&quot;&quot;&quot;
            QTableView::item:selected {
                background-color: rgb(230, 230, 230);  # Gris claro
                color: black;
            }
        &quot;&quot;&quot;)

        # Set selection behavior to select entire rows
        self.table.setSelectionBehavior(QTableWidget.SelectRows)

        # Load data into the table
        self.load_data()

        # Connect cell click event to change color space function
        self.table.cellClicked.connect(self.change_color_space)

        layout.addWidget(self.table)
        self.setLayout(layout)
        
        # Adjust window size and position to be centered
        self.adjust_window_size()





    def load_data(self):
        node_names = [
            &quot;Default&quot;,
            &quot;ACES - ACES2065-1&quot;,
            &quot;ACES - ACEScg&quot;,
            &quot;ACES - ACEScct&quot;,
            &quot;Output - Rec.709&quot;
        ]

        for row, name in enumerate(node_names):
            node_item = QTableWidgetItem(name)
            self.table.setItem(row, 0, node_item)

        self.table.resizeColumnsToContents()

    def adjust_window_size(self):
        # Desactivar temporalmente el estiramiento de la última columna
        self.table.horizontalHeader().setStretchLastSection(False)

        # Ajustar las columnas al contenido
        self.table.resizeColumnsToContents()

        # Calcular el ancho de la ventana basado en el ancho de las columnas y el texto más ancho
        width = self.table.verticalHeader().width()  # Un poco de relleno para estética
        for i in range(self.table.columnCount()):
            width += self.table.columnWidth(i) + 50  # Un poco más de relleno entre columnas

        # Ajustar el ancho adicional basado en el texto más ancho
        longest_text = max([&quot;Default&quot;, &quot;ACES - ACES2065-1&quot;, &quot;ACES - ACEScg&quot;, &quot;ACES - ACEScct&quot;, &quot;Output - Rec.709&quot;], key=len)
        font_metrics = self.table.fontMetrics()
        text_width = font_metrics.width(longest_text) + 50  # Un poco de relleno adicional
        width = max(width, text_width)

        # Asegurarse de que el ancho no supera el 80% del ancho de pantalla
        screen = QApplication.primaryScreen()
        screen_rect = screen.availableGeometry()
        max_width = screen_rect.width() * 0.8
        final_width = min(width, max_width)

        # Calcular la altura basada en la altura de los headers y las filas
        height = self.table.horizontalHeader().height() + 20
        for i in range(self.table.rowCount()):
            height += self.table.rowHeight(i)

        # Agregar un relleno total de 6 píxeles
        height += 10

        # Incluir la altura de la barra de título personalizada
        title_bar_height = 20
        height += title_bar_height

        # Asegurarse de que la altura no supera el 80% del alto de pantalla
        max_height = screen_rect.height() * 0.8
        final_height = min(height, max_height)

        # Reactivar el estiramiento de la última columna
        self.table.horizontalHeader().setStretchLastSection(True)

        # Ajustar el tamaño de la ventana
        self.resize(final_width, final_height)

        # Obtener la posición actual del puntero del mouse
        cursor_pos = QCursor.pos()

        # Mover la ventana para que se centre en la posición actual del puntero del mouse
        self.move(cursor_pos.x() - final_width // 2, cursor_pos.y() - final_height // 2)


    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Escape:
            self.close()
        elif event.key() in (Qt.Key_Return, Qt.Key_Enter):
            current_row = self.table.currentRow()
            if current_row &gt;= 0:
                self.change_color_space(current_row, 0)
        else:
            super(SelectedNodeInfo, self).keyPressEvent(event)

    def change_color_space(self, row, column):
        color_spaces = [
            &quot;Default&quot;,
            &quot;ACES - ACES2065-1&quot;,
            &quot;ACES - ACEScg&quot;,
            &quot;ACES - ACEScct&quot;,
            &quot;Output - Rec.709&quot;
        ]
        selected_color_space = color_spaces[row]
        
        # Obtener los nodos seleccionados
        selected_nodes = nuke.selectedNodes()

        if selected_nodes:
            for node in selected_nodes:
                if node.Class() == 'Read' or node.Class() == 'Write':
                    try:
                        node['colorspace'].setValue(selected_color_space)
                    except Exception as e:
                        print(f&quot;Error al cambiar el espacio de color: {e}&quot;)
        
        # Cerrar la ventana después de aplicar los cambios
        self.close()

app = None
window = None

def main():
    global app, window
    # Check if there's already an instance of QApplication
    app = QApplication.instance() or QApplication([])
    window = SelectedNodeInfo()
    window.show()

# Llamar a main() para iniciar la aplicación
main()
&quot;&quot;&quot;
Utility script to merge transforms in Nuke
Author: Erwan Leroy
&quot;&quot;&quot;

import threading
import math
import nuke
import nukescripts

class NodeMatrixWrapper(object):
    &quot;&quot;&quot;
    Wrap nuke Node to unify the method used to set matrices on these nodes.
    Supported node classes: Transform, CornerPin2D, Tracker4, Roto, RotoPaint, SplineWarp3
    &quot;&quot;&quot;
    def __init__(self, node=None):
        self._supported_out_types = ['Transform', 'CornerPin2D', 'Tracker4', 'Roto', 'RotoPaint', 'SplineWarp3']
        self.type = None
        self.node = node
        self._set_type()

    def _set_type(self):
        if not self.node:
            self.type = None
        else:
            node_type = self.node.Class()
            if node_type in self._supported_out_types:
                self.type = node_type
            else:
                self.type = None
                raise ValueError(&quot;NodeMatrixWrapper does not support %s nodes&quot; % node_type)

    def set_node(self, node):
        self.node = node
        self._set_type()

    def set_matrix_at(self, matrix, frame, set_animated=True):
        node = self.node
        if self.type == 'Transform':
            if set_animated:
                for knob_name in ['translate', 'rotate', 'scale', 'skewX']:
                    knob = node[knob_name]
                    if not knob.isAnimated():
                        knob.setAnimated()
            center_x = node['center'].getValueAt(frame, 0)
            center_y = node['center'].getValueAt(frame, 1)
            translate_x, translate_y, rotation, scale_x, scale_y, skew_x = decompose_matrix(matrix, center_x, center_y)
            node['translate'].setValueAt(translate_x, frame, 0)
            node['translate'].setValueAt(translate_y, frame, 1)
            node['rotate'].setValueAt(rotation, frame)
            node['scale'].setValueAt(scale_x, frame, 0)
            node['scale'].setValueAt(scale_y, frame, 1)
            node['skewX'].setValueAt(skew_x, frame)
        elif self.type in ['Roto', 'RotoPaint', 'SplineWarp3']:
            layer = self._get_rp_layer('Tracked_Layer1')
            transform = layer.getTransform()
            matrix.transpose()
            for y_index in range(4):
                for x_index in range(4):
                    index = 4 * x_index + y_index
                    curve = transform.getExtraMatrixAnimCurve(x_index, y_index)
                    if set_animated:
                        curve.addKey(frame, matrix[index])
                    else:
                        curve.constantValue = matrix[index]
                    transform.setExtraMatrixAnimCurve(x_index, y_index, curve)
        elif self.type == 'Tracker4':
            points = matrix_to_corners(matrix, self.node.width(), self.node.height())
            self.set_points_at(points, frame, set_animated)
        elif self.type == 'CornerPin2D':
            matrix_knob = node['transform_matrix']
            if set_animated and not matrix_knob.isAnimated():
                matrix_knob.setAnimated()
            matrix.transpose()
            for index in range(16):
                matrix_knob.setValueAt(matrix[index], frame, index)

    def set_points_at(self, points, frame, set_animated=True):
        if self.type in ['Transform', 'Roto', 'RotoPaint', 'SplineWarp3']:
            matrix = corners_to_matrix(points, self.node.width(), self.node.height())
            self.set_matrix_at(matrix, frame, set_animated)
        elif self.type == 'CornerPin2D':
            for index, point in enumerate(points[0:4]):
                knob = self.node['to%d' % (index + 1)]
                if set_animated and not knob.isAnimated():
                    knob.setAnimated()
                knob.setValueAt(point.x, frame, 0)
                knob.setValueAt(point.y, frame, 1)
        elif self.type == &quot;Tracker4&quot;:
            for index, point in enumerate(points):
                set_value_on_tracker(self.node, point, index, frame, set_animated)

    def _get_rp_layer(self, name):
        if self.type not in ['Roto', 'RotoPaint', 'SplineWarp3']:
            raise TypeError(&quot;Node doesn't support rotopaint layers&quot;)
        curve_knob = self.node['curves']
        layer = curve_knob.toElement(name)
        if layer is None:
            layer = nuke.rotopaint.Layer(curve_knob)
            layer.name = name
            curve_knob.rootLayer.append(layer)
        return layer

def decompose_matrix(matrix, center_x=0, center_y=0):
    vector = nuke.math.Vector3(center_x, center_y, 0)
    vector_trans = matrix.transform(vector)
    translate_x = vector_trans[0] - center_x
    translate_y = vector_trans[1] - center_y
    delta = (matrix[0] * matrix[5]) - (matrix[4] * matrix[1])
    ratio = pow(matrix[0], 2) + pow(matrix[1], 2)
    rotation = math.degrees(math.atan2(matrix[1], matrix[0]))
    scale_x = math.sqrt(ratio)
    scale_y = delta / scale_x
    skew_x = (matrix[0] * matrix[4] + matrix[1] * matrix[5]) / delta
    return translate_x, translate_y, rotation, scale_x, scale_y, skew_x

def matrix_to_corners(matrix, frame_width, frame_height):
    vec1 = nuke.math.Vector4(0, 0, 0, 1)
    vec1 = matrix.transform(vec1)
    vec1 /= vec1.w
    vec2 = nuke.math.Vector4(frame_width, 0, 0, 1)
    vec2 = matrix.transform(vec2)
    vec2 /= vec2.w
    vec3 = nuke.math.Vector4(frame_width, frame_height, 0, 1)
    vec3 = matrix.transform(vec3)
    vec3 /= vec3.w
    vec4 = nuke.math.Vector4(0, frame_height, 0, 1)
    vec4 = matrix.transform(vec4)
    vec4 /= vec4.w
    return [vec1, vec2, vec3, vec4]

def get_matrix_at_frame(node, frame):
    matrix = None
    if node.Class() == 'Transform' or node.Class() == 'Tracker4':
        k = node.knob('matrix')
        context = nuke.OutputContext()
        context.setFrame(frame)
        matrix = k.value(context)
    elif node.Class() == 'CornerPin2D':
        to_matrix = nuke.math.Matrix4()
        to1x = node['to1'].getValueAt(frame)[0]
        to1y = node['to1'].getValueAt(frame)[1]
        to2x = node['to2'].getValueAt(frame)[0]
        to2y = node['to2'].getValueAt(frame)[1]
        to3x = node['to3'].getValueAt(frame)[0]
        to3y = node['to3'].getValueAt(frame)[1]
        to4x = node['to4'].getValueAt(frame)[0]
        to4y = node['to4'].getValueAt(frame)[1]
        to_matrix.mapUnitSquareToQuad(to1x, to1y, to2x, to2y, to3x, to3y, to4x, to4y)
        from_matrix = nuke.math.Matrix4()
        from1x = node['from1'].getValueAt(frame)[0]
        from1y = node['from1'].getValueAt(frame)[1]
        from2x = node['from2'].getValueAt(frame)[0]
        from2y = node['from2'].getValueAt(frame)[1]
        from3x = node['from3'].getValueAt(frame)[0]
        from3y = node['from3'].getValueAt(frame)[1]
        from4x = node['from4'].getValueAt(frame)[0]
        from4y = node['from4'].getValueAt(frame)[1]
        from_matrix.mapUnitSquareToQuad(from1x, from1y, from2x, from2y, from3x, from3y, from4x, from4y)
        k = node.knob('transform_matrix')
        values = k.getValueAt(frame)
        extra_matrix = nuke.math.Matrix4()
        for index in range(len(values)):
            extra_matrix[index] = values[index]
        extra_matrix.transpose()
        matrix = extra_matrix * (to_matrix * from_matrix.inverse())
        if node['invert'].getValueAt(frame):
            matrix = matrix.inverse()
    return matrix

def set_value_on_tracker(tracker, point, point_index, frame, set_animated):
    tracker.showControlPanel()
    tracks = tracker['tracks']
    columns = 31
    if tracks.fullyQualifiedName(point_index * columns).endswith('.tracks'):
        count = 0
        while not tracks.fullyQualifiedName(count * columns).endswith('.tracks'):
            count += 1
        tracker['add_track'].execute()
        point_index = count
    x_knob_index = point_index * columns + 2
    y_knob_index = point_index * columns + 3
    if set_animated and not tracks.isAnimated(x_knob_index):
        tracks.setAnimated(x_knob_index)
    if set_animated and not tracks.isAnimated(y_knob_index):
        tracks.setAnimated(y_knob_index)
    tracks.setValueAt(point.x, frame, x_knob_index)
    tracks.setValueAt(point.y, frame, y_knob_index)

def merge_transforms(transform_list, first, last, cornerpin=False, force_matrix=False):
    task = nuke.ProgressTask(&quot;Merging Transforms&quot;)
    task.setMessage(&quot;Checking Settings&quot;)
    for node in transform_list:
        if node.Class() == 'CornerPin2D':
            cornerpin = True
            break
    height = transform_list[0].height()
    width = transform_list[0].width()
    if cornerpin:
        new_node = nuke.nodes.CornerPin2D(inputs=[transform_list[0].input(0)])
    else:
        new_node = nuke.nodes.Transform(inputs=[transform_list[0].input(0)])
        new_node['center'].setValue(width / 2, 0)
        new_node['center'].setValue(height / 2, 1)
    new_node.setXpos(transform_list[0].xpos() + 100)
    new_node.setYpos(transform_list[0].ypos())
    new_node['label'].setValue(&quot;Merged Transforms&quot;)
    wrapped_node = NodeMatrixWrapper(new_node)
    animated = first != last
    task.setMessage(&quot;Merging transforms&quot;)
    try:
        for frame in range(first, last + 1):
            if task.isCancelled():
                break
            current_matrix = get_matrix_at_frame(transform_list[0], frame)
            for index in range(1, len(transform_list)):
                transform_matrix = get_matrix_at_frame(transform_list[index], frame)
                current_matrix = transform_matrix * current_matrix
            if force_matrix or not cornerpin:
                wrapped_node.set_matrix_at(current_matrix, frame, animated)
            else:
                points = matrix_to_corners(current_matrix, width, height)
                wrapped_node.set_points_at(points, frame, animated)
            task.setProgress(int((frame - first) / ((last - first) * 0.01)))
    finally:
        task.setProgress(100)
        del task

class MergeTransformsPanel(nukescripts.PythonPanel):
    def __init__(self):
        nukescripts.PythonPanel.__init__(self, 'Merge Transforms')
        self.first = nuke.Int_Knob('first', 'First Frame')
        self.first.setValue(int(nuke.root()['first_frame'].value()))
        self.last = nuke.Int_Knob('last', 'Last Frame')
        self.last.setValue(int(nuke.root()['last_frame'].value()))
        self.force_cp = nuke.Boolean_Knob('force_cp', 'Force Merge as CornerPin')
        self.force_cp.setFlag(nuke.STARTLINE)
        self.force_cp.setTooltip('Tool will merge transforms as a new Transform if possible, or Cornerpin if necessary.'
                                 '\nChecking this box will force a corner pin output')
        self.force_matrix = nuke.Boolean_Knob('force_matrix', 'CornerPin as extra_matrix')
        self.force_matrix.setTooltip(&quot;Uses the cornerpin's extra_matrix to match the transform rather than the corners&quot;)
        self.force_matrix.setEnabled(False)
        self.force_matrix.setFlag(nuke.STARTLINE)
        for k in (self.first, self.last, self.force_cp, self.force_matrix):
            self.addKnob(k)
    def knobChanged(self, knob):
        if knob is self.force_cp:
            self.force_matrix.setEnabled(self.force_cp.value())

def run_merge_transforms():
    nodes = nuke.selectedNodes()
    valid_nodes = check_classes(nodes, ['Transform', 'CornerPin2D', 'Tracker4'])
    if valid_nodes:
        transform_list = sort_nodes(nodes)
    else:
        return
    if len(transform_list) &lt; 2:
        nuke.message(&quot;You need at least 2 transforms selected&quot;)
        return
    elif len(transform_list) != len(nodes):
        nuke.message(&quot;Please make sure all nodes form a single Branch&quot;)
        return
    panel = MergeTransformsPanel()
    if panel.showModalDialog():
        first = panel.first.value()
        last = panel.last.value()
        cornerpin = panel.force_cp.value()
        force_matrix = panel.force_matrix.value()
        exec_thread = threading.Thread(target=merge_transforms, args=(transform_list, first, last, cornerpin, force_matrix))
        exec_thread.start()

def check_classes(nodes, allowed_classes):
    valid = True
    for node in nodes:
        if node.Class() not in allowed_classes:
            nuke.message(&quot;Please select only supported Nodes: &quot; + ', '.join(allowed_classes))
            valid = False
            break
    return valid

def sort_nodes(node_list):
    nodes_in_list = 0
    sorted_list = []
    for node in node_list:
        has_parents = True
        number_of_nodes = 1
        list_of_nodes = [node]
        while has_parents:
            parent = node.input(0)
            if parent:
                if parent['selected'].value():
                    node = parent
                    number_of_nodes += 1
                    list_of_nodes.append(node)
                else:
                    has_parents = False
            else:
                has_parents = False
        if number_of_nodes &gt; nodes_in_list:
            nodes_in_list = number_of_nodes
            sorted_list = list_of_nodes
    sorted_list.reverse()
    return sorted_list
import importlib
import LGA_RnW_ColorSpace_Favs
importlib.reload(LGA_RnW_ColorSpace_Favs)import os
import sys
import subprocess
import nuke
import time

def close_current_nuke():
    # Guardar los cambios en la escena actual
    if nuke.Root().modified():
        if nuke.ask(&quot;Do you want to save your changes before exiting?&quot;):
            nuke.scriptSave()

    # Cerrar Nuke
    nuke.scriptExit()

def open_new_nukeX():
    # Obtener la ruta del ejecutable de NukeX desde un archivo
    def get_nuke_path_from_file():
        # Obtiene la ruta del directorio donde se encuentra el ejecutable.
        directory_of_exe = os.path.dirname(sys.executable)
        filepath = os.path.join(directory_of_exe, 'nukeXpath.txt')

        try:
            with open(filepath, 'r') as file:
                return file.readline().strip()
        except FileNotFoundError as e:
            print(f&quot;Error: Nuke path file not found in the executable's directory. {e}&quot;)
            return None
        except Exception as e:
            print(f&quot;Error reading Nuke path from file: {e}&quot;)
            return None

    # Abrir una nueva instancia de NukeX
    nuke_executable_path = get_nuke_path_from_file()
    if nuke_executable_path:
        command = f'&quot;{nuke_executable_path}&quot; --nukex'
        try:
            subprocess.Popen(command, shell=True)  # Abre NukeX
        except Exception as e:
            print(f&quot;Failed to open NukeX: {e}&quot;)

# Primero abrir una nueva instancia de NukeX
open_new_nukeX()

# Esperar un tiempo para asegurarse de que la nueva instancia se inicie
time.sleep(5)

# Luego cerrar la instancia actual de Nuke
close_current_nuke()
import os
import sys
import subprocess
import nuke
from platform import system
from distutils.spawn import find_executable
import time

def is_not_exec(name):
    # Check whether terminal program exists
    return find_executable(name) is None

def find_terminal():
    term_list = [&quot;x-terminal-emulator&quot;, &quot;konsole&quot;, &quot;gnome-terminal&quot;, &quot;urxvt&quot;, &quot;rxvt&quot;, &quot;termit&quot;, &quot;terminator&quot;, &quot;Eterm&quot;, &quot;aterm&quot;, &quot;uxterm&quot;, &quot;xterm&quot;, &quot;roxterm&quot;, &quot;xfce4-terminal&quot;, &quot;termite&quot;, &quot;lxterminal&quot;, &quot;mate-terminal&quot;, &quot;terminology&quot;, &quot;st&quot;, &quot;qterminal&quot;, &quot;lilyterm&quot;, &quot;tilix&quot;, &quot;terminix&quot;, &quot;kitty&quot;, &quot;guake&quot;, &quot;tilda&quot;, &quot;alacritty&quot;, &quot;hyper&quot;]
    for term in term_list:
        if not is_not_exec(term):
            return term
    return None

def close_current_nuke():
    # Save changes in the current script
    if nuke.Root().modified():
        if nuke.ask(&quot;Do you want to save your changes before exiting?&quot;):
            nuke.scriptSave()
    # Close Nuke
    nuke.scriptExit()

def get_nuke_path_from_file():
    # Get the path of the NukeX executable from a file
    directory_of_exe = os.path.dirname(sys.executable)
    filepath = os.path.join(directory_of_exe, 'nukeXpath.txt')
    
    try:
        with open(filepath, 'r') as file:
            return file.readline().strip()
    except FileNotFoundError as e:
        print(f&quot;Error: Nuke path file not found in the executable's directory. {e}&quot;)
        return None
    except Exception as e:
        print(f&quot;Error reading Nuke path from file: {e}&quot;)
        return None

def open_new_nukeX():
    # Open a new instance of NukeX
    nuke_executable_path = get_nuke_path_from_file()
    if nuke_executable_path:
        command = f'&quot;{nuke_executable_path}&quot; --nukex'
        try:
            subprocess.Popen(command, shell=True)  # Open NukeX
        except Exception as e:
            print(f&quot;Failed to open NukeX: {e}&quot;)

def main():
    # First, open a new instance of NukeX
    open_new_nukeX()
    # Wait some time to ensure the new instance starts
    time.sleep(5)
    # Then, close the current instance of Nuke
    close_current_nuke()

if __name__ == &quot;__main__&quot;:
    main()
import nuke
import os
import subprocess
from platform import system
from distutils.spawn import find_executable

def isNot_exec(name):
    #check whether terminal program exists
    return find_executable(name) is None

def findTerminal():
    termList = [&quot;x-terminal-emulator&quot;, &quot;konsole&quot;, &quot;gnome-terminal&quot;, &quot;urxvt&quot;, &quot;rxvt&quot;, &quot;termit&quot;, &quot;terminator&quot;, &quot;Eterm&quot;, &quot;aterm&quot;, &quot;uxterm&quot;, &quot;xterm&quot;, &quot;roxterm&quot;, &quot;xfce4-terminal&quot;, &quot;termite&quot;, &quot;lxterminal&quot;, &quot;mate-terminal&quot;, &quot;terminology&quot;, &quot;st&quot;, &quot;qterminal&quot;, &quot;lilyterm&quot;, &quot;tilix&quot;, &quot;terminix&quot;, &quot;kitty&quot;, &quot;guake&quot;, &quot;tilda&quot;, &quot;alacritty&quot;, &quot;hyper&quot;]
    #list taken from https://github.com/i3/i3/blob/next/i3-sensible-terminal
    for term in termList:
        if not isNot_exec(term):
            return term
    return None

def cmdLaunch(XS):
    defineNuke = '&quot;' + nuke.env[&quot;ExecutablePath&quot;] + '&quot;'
    if XS == 1:
        defineNuke += &quot; --nukex&quot;
    elif XS == 2:
        defineNuke += &quot; --studio&quot;

    try:
        subprocess.Popen(defineNuke, shell=True)
    except Exception as e:
        print(f&quot;Failed to open NukeX: {e}&quot;)

    # Cerrar Nuke actual
    nuke.scriptExit()

# Ejecutar la función cmdLaunch con XS = 1 para abrir NukeX
cmdLaunch(1)
import nuke
import os
import subprocess
from platform import system
from distutils.spawn import find_executable

def isNot_exec(name):
    #check whether terminal program exists
    return find_executable(name) is None

def findTerminal():
    termList = [&quot;x-terminal-emulator&quot;, &quot;konsole&quot;, &quot;gnome-terminal&quot;, &quot;urxvt&quot;, &quot;rxvt&quot;, &quot;termit&quot;, &quot;terminator&quot;, &quot;Eterm&quot;, &quot;aterm&quot;, &quot;uxterm&quot;, &quot;xterm&quot;, &quot;roxterm&quot;, &quot;xfce4-terminal&quot;, &quot;termite&quot;, &quot;lxterminal&quot;, &quot;mate-terminal&quot;, &quot;terminology&quot;, &quot;st&quot;, &quot;qterminal&quot;, &quot;lilyterm&quot;, &quot;tilix&quot;, &quot;terminix&quot;, &quot;kitty&quot;, &quot;guake&quot;, &quot;tilda&quot;, &quot;alacritty&quot;, &quot;hyper&quot;]
    #list taken from https://github.com/i3/i3/blob/next/i3-sensible-terminal
    for term in termList:
        if not isNot_exec(term):
            return term
    return None

def cmdLaunch(XS):
    defineNuke = '&quot;' + nuke.env[&quot;ExecutablePath&quot;] + '&quot;'
    if XS == 1:
        defineNuke += &quot; --nukex&quot;
    elif XS == 2:
        defineNuke += &quot; --studio&quot;

    try:
        subprocess.Popen(defineNuke, shell=True)
    except Exception as e:
        print(f&quot;Failed to open NukeX: {e}&quot;)

    # Cerrar Nuke actual
    nuke.scriptExit()

# Ejecutar la función cmdLaunch con XS = 1 para abrir NukeX
cmdLaunch(1)
import nuke
import os
import subprocess
from platform import system
from distutils.spawn import find_executable

def isNot_exec(name):
    #check whether terminal program exists
    return find_executable(name) is None

def findTerminal():
    termList = [&quot;x-terminal-emulator&quot;, &quot;konsole&quot;, &quot;gnome-terminal&quot;, &quot;urxvt&quot;, &quot;rxvt&quot;, &quot;termit&quot;, &quot;terminator&quot;, &quot;Eterm&quot;, &quot;aterm&quot;, &quot;uxterm&quot;, &quot;xterm&quot;, &quot;roxterm&quot;, &quot;xfce4-terminal&quot;, &quot;termite&quot;, &quot;lxterminal&quot;, &quot;mate-terminal&quot;, &quot;terminology&quot;, &quot;st&quot;, &quot;qterminal&quot;, &quot;lilyterm&quot;, &quot;tilix&quot;, &quot;terminix&quot;, &quot;kitty&quot;, &quot;guake&quot;, &quot;tilda&quot;, &quot;alacritty&quot;, &quot;hyper&quot;]
    #list taken from https://github.com/i3/i3/blob/next/i3-sensible-terminal
    for term in termList:
        if not isNot_exec(term):
            return term
    return None

def cmdLaunch(XS):
    defineNuke = '&quot;' + nuke.env[&quot;ExecutablePath&quot;] + '&quot;'
    if XS == 1:
        defineNuke += &quot; --nukex&quot;
    elif XS == 2:
        defineNuke += &quot; --studio&quot;

    try:
        subprocess.Popen(defineNuke, shell=True)
    except Exception as e:
        print(f&quot;Failed to open NukeX: {e}&quot;)

    # Cerrar Nuke actual
    nuke.scriptExit()

# Ejecutar la función cmdLaunch con XS = 1 para abrir NukeX
cmdLaunch(1)
import nuke
import os
import subprocess
import sys

def isNot_exec(name):
    #check whether terminal program exists
    return find_executable(name) is None

def findTerminal():
    termList = [&quot;x-terminal-emulator&quot;, &quot;konsole&quot;, &quot;gnome-terminal&quot;, &quot;urxvt&quot;, &quot;rxvt&quot;, &quot;termit&quot;, &quot;terminator&quot;, &quot;Eterm&quot;, &quot;aterm&quot;, &quot;uxterm&quot;, &quot;xterm&quot;, &quot;roxterm&quot;, &quot;xfce4-terminal&quot;, &quot;termite&quot;, &quot;lxterminal&quot;, &quot;mate-terminal&quot;, &quot;terminology&quot;, &quot;st&quot;, &quot;qterminal&quot;, &quot;lilyterm&quot;, &quot;tilix&quot;, &quot;terminix&quot;, &quot;kitty&quot;, &quot;guake&quot;, &quot;tilda&quot;, &quot;alacritty&quot;, &quot;hyper&quot;]
    for term in termList:
        if not isNot_exec(term):
            return term
    return None

def cmdLaunch(XS):
    # Verificar si hay cambios no guardados y preguntar si se desea guardar
    if nuke.Root().modified():
        if nuke.ask(&quot;Do you want to save your changes before exiting?&quot;):
            nuke.scriptSave()

    defineNuke = '&quot;' + nuke.env[&quot;ExecutablePath&quot;] + '&quot;'
    if XS == 1:
        defineNuke += &quot; --nukex&quot;
    elif XS == 2:
        defineNuke += &quot; --studio&quot;

    try:
        subprocess.Popen(defineNuke, shell=True)
    except Exception as e:
        print(f&quot;Failed to open NukeX: {e}&quot;)

    # Cerrar Nuke actual
    nuke.scriptExit()

# Ejecutar la función cmdLaunch con XS = 1 para abrir NukeX
cmdLaunch(1)
import nuke
import os
import subprocess
import sys

def isNot_exec(name):
    #check whether terminal program exists
    return find_executable(name) is None

def findTerminal():
    termList = [&quot;x-terminal-emulator&quot;, &quot;konsole&quot;, &quot;gnome-terminal&quot;, &quot;urxvt&quot;, &quot;rxvt&quot;, &quot;termit&quot;, &quot;terminator&quot;, &quot;Eterm&quot;, &quot;aterm&quot;, &quot;uxterm&quot;, &quot;xterm&quot;, &quot;roxterm&quot;, &quot;xfce4-terminal&quot;, &quot;termite&quot;, &quot;lxterminal&quot;, &quot;mate-terminal&quot;, &quot;terminology&quot;, &quot;st&quot;, &quot;qterminal&quot;, &quot;lilyterm&quot;, &quot;tilix&quot;, &quot;terminix&quot;, &quot;kitty&quot;, &quot;guake&quot;, &quot;tilda&quot;, &quot;alacritty&quot;, &quot;hyper&quot;]
    for term in termList:
        if not isNot_exec(term):
            return term
    return None

def save_and_exit():
    if nuke.Root().modified():
        if nuke.ask(&quot;Do you want to save your changes before exiting?&quot;):
            nuke.scriptSave()
    nuke.scriptExit()

def cmdLaunch(XS):
    defineNuke = '&quot;' + nuke.env[&quot;ExecutablePath&quot;] + '&quot;'
    if XS == 1:
        defineNuke += &quot; --nukex&quot;
    elif XS == 2:
        defineNuke += &quot; --studio&quot;

    try:
        subprocess.Popen(defineNuke, shell=True)
    except Exception as e:
        print(f&quot;Failed to open NukeX: {e}&quot;)

    # Llamar a save_and_exit después de abrir el nuevo NukeX
    save_and_exit()

# Ejecutar la función cmdLaunch con XS = 1 para abrir NukeX
cmdLaunch(1)
import nuke
import os
import subprocess
import sys

def isNot_exec(name):
    #check whether terminal program exists
    return find_executable(name) is None

def findTerminal():
    termList = [&quot;x-terminal-emulator&quot;, &quot;konsole&quot;, &quot;gnome-terminal&quot;, &quot;urxvt&quot;, &quot;rxvt&quot;, &quot;termit&quot;, &quot;terminator&quot;, &quot;Eterm&quot;, &quot;aterm&quot;, &quot;uxterm&quot;, &quot;xterm&quot;, &quot;roxterm&quot;, &quot;xfce4-terminal&quot;, &quot;termite&quot;, &quot;lxterminal&quot;, &quot;mate-terminal&quot;, &quot;terminology&quot;, &quot;st&quot;, &quot;qterminal&quot;, &quot;lilyterm&quot;, &quot;tilix&quot;, &quot;terminix&quot;, &quot;kitty&quot;, &quot;guake&quot;, &quot;tilda&quot;, &quot;alacritty&quot;, &quot;hyper&quot;]
    for term in termList:
        if not isNot_exec(term):
            return term
    return None

def save_and_exit():
    if nuke.Root().modified():
        if nuke.ask(&quot;Do you want to save your changes before exiting?&quot;):
            nuke.scriptSave()
    nuke.scriptExit()

def cmdLaunch(XS):
    defineNuke = '&quot;' + nuke.env[&quot;ExecutablePath&quot;] + '&quot;'
    if XS == 1:
        defineNuke += &quot; --nukex&quot;
    elif XS == 2:
        defineNuke += &quot; --studio&quot;

    try:
        subprocess.Popen(defineNuke, shell=True)
    except Exception as e:
        print(f&quot;Failed to open NukeX: {e}&quot;)

    # Llamar a save_and_exit después de abrir el nuevo NukeX
    save_and_exit()

# Ejecutar la función cmdLaunch con XS = 1 para abrir NukeX
cmdLaunch(1)
import nuke
import os
import subprocess
import time

def is_nuke_ready_to_exit():
    # Verifica si hay cambios no guardados y pregunta si se desea guardar
    if nuke.Root().modified():
        if nuke.ask(&quot;Do you want to save your changes before exiting?&quot;):
            nuke.scriptSave()
    # Verifica si no hay scripts abiertos
    return not nuke.Root().modified()

def check_and_exit(XS):
    # Verifica cada medio segundo si Nuke está listo para cerrarse
    while not is_nuke_ready_to_exit():
        time.sleep(0.5)
    
    # Cerrar Nuke y abrir una nueva instancia de NukeX
    defineNuke = '&quot;' + nuke.env[&quot;ExecutablePath&quot;] + '&quot;'
    if XS == 1:
        defineNuke += &quot; --nukex&quot;
    elif XS == 2:
        defineNuke += &quot; --studio&quot;

    try:
        subprocess.Popen(defineNuke, shell=True)
    except Exception as e:
        print(f&quot;Failed to open NukeX: {e}&quot;)
    
    nuke.scriptExit()

# Ejecutar la función check_and_exit con XS = 1 para abrir NukeX
check_and_exit(1)
import nuke
import os
import subprocess
import time

def is_nuke_ready_to_exit():
    # Verifica si no hay cambios no guardados
    return not nuke.Root().modified()

def close_script():
    # Cerrar el script actual de Nuke
    nuke.scriptClose()

def check_and_exit(XS):
    # Cierra el script actual
    close_script()

    # Verifica cada medio segundo si Nuke está listo para cerrarse
    while not is_nuke_ready_to_exit():
        time.sleep(0.5)
    
    # Cerrar Nuke y abrir una nueva instancia de NukeX
    defineNuke = '&quot;' + nuke.env[&quot;ExecutablePath&quot;] + '&quot;'
    if XS == 1:
        defineNuke += &quot; --nukex&quot;
    elif XS == 2:
        defineNuke += &quot; --studio&quot;

    try:
        subprocess.Popen(defineNuke, shell=True)
    except Exception as e:
        print(f&quot;Failed to open NukeX: {e}&quot;)
    
    nuke.scriptExit()

# Ejecutar la función check_and_exit con XS = 1 para abrir NukeX
check_and_exit(1)
&quot;&quot;&quot;
_____________________________________________________

  LGA_NKS_Flow_Shot_info v1.4 - 2024 - Lega Pugliese
  Imprime información del shot y las varsiones 
_____________________________________________________

&quot;&quot;&quot;

import hiero.core
import os
import re
import json
import sys
from PySide2.QtCore import QCoreApplication, Qt
from PySide2.QtGui import QFontMetrics, QKeySequence
from PySide2.QtWidgets import QWidget, QVBoxLayout, QTextEdit, QApplication, QShortcut


# Variable global para activar o desactivar los prints
DEBUG = True

def debug_print(*message):
    if DEBUG:
        print(*message)


app = None
window = None


class ShotGridManager:
    &quot;&quot;&quot;Clase para manejar operaciones con datos de un archivo JSON en lugar de ShotGrid.&quot;&quot;&quot;
    def __init__(self, json_path):
        with open(json_path, 'r', encoding='utf-8') as file:
            self.data = json.load(file)

    def find_project(self, project_name):
        &quot;&quot;&quot;Busca un proyecto por nombre en el JSON.&quot;&quot;&quot;
        return next((p for p in self.data['projects'] if p['project_name'] == project_name), None)

    def find_shot(self, project_name, shot_code):
        &quot;&quot;&quot;Busca un shot por nombre y código en el JSON.&quot;&quot;&quot;
        project = self.find_project(project_name)
        if project:
            return next((s for s in project['shots'] if s['shot_name'] == shot_code), None)
        return None

    def find_task(self, shot, task_name):
        &quot;&quot;&quot;Busca una tarea específica por nombre en un shot.&quot;&quot;&quot;
        return next((t for t in shot['tasks'] if t['task_type'].lower() == task_name.lower()), None)


class HieroOperations:
    &quot;&quot;&quot;Clase para manejar operaciones en Hiero.&quot;&quot;&quot;
    def __init__(self, shotgrid_manager):
        self.sg_manager = shotgrid_manager

    def parse_exr_name(self, file_name):
        &quot;&quot;&quot;Extrae el nombre base del archivo EXR y el número de versión.&quot;&quot;&quot;
        base_name = re.sub(r'_%04d\.exr$', '', file_name)
        version_match = re.search(r'_v(\d+)', base_name)
        version_number = version_match.group(1) if version_match else 'Unknown'
        return base_name, version_number

    def process_selected_clips(self):
        &quot;&quot;&quot;Procesa los clips seleccionados en el timeline de Hiero.&quot;&quot;&quot;
        debug_print(&quot;Processing selected clips...&quot;)
        seq = hiero.ui.activeSequence()
        if seq:
            te = hiero.ui.getTimelineEditor(seq)
            selected_clips = te.selection()
            results = []

            if selected_clips:
                for clip in selected_clips:
                    if isinstance(clip, hiero.core.EffectTrackItem):
                        continue  # Pasar de largo los clips que sean efectos

                    file_path = clip.source().mediaSource().fileinfos()[0].filename()
                    exr_name = os.path.basename(file_path)
                    base_name, version_number = self.parse_exr_name(exr_name)

                    project_name = base_name.split('_')[0]
                    parts = base_name.split('_')
                    shot_code = '_'.join(parts[:5])

                    # Realizar operación intensiva en el JSON
                    QCoreApplication.processEvents()
                    shot = self.sg_manager.find_shot(project_name, shot_code)
                    debug_print(f&quot;Shot found: {shot}&quot;)
                    
                    QCoreApplication.processEvents()
                    if shot:
                        task = self.sg_manager.find_task(shot, &quot;comp&quot;)
                        debug_print(f&quot;Task found: {task}&quot;)
                        task_description = task['task_description'] if task else &quot;No info available&quot;
                        assignee = task['task_assigned_to'] if task else &quot;No assignee&quot;
                        versions = task['versions'] if task else []
                        
                        # Obtener las tres últimas versiones
                        last_versions = sorted(versions, key=lambda v: v['version_date'], reverse=True)[:3]
                        version_info = [{'version_number': re.search(r'v(\d+)', v['version_number']).group(), 'version_description': v['version_description'] or &quot;No description&quot;, 'comments': v['comments']} for v in last_versions]
                        
                        shot_info = {
                            &quot;shot_code&quot;: shot['shot_name'],
                            &quot;description&quot;: task_description,
                            &quot;assignee&quot;: assignee,
                            &quot;versions&quot;: version_info
                        }
                        results.append(shot_info)
                    QCoreApplication.processEvents()
            debug_print(&quot;Processing completed.&quot;)
            return results
        else:
            debug_print(&quot;No se encontró una secuencia activa en Hiero.&quot;)
            return []



class GUIWindow(QWidget):
    def __init__(self, hiero_ops, parent=None):
        super(GUIWindow, self).__init__(parent)
        self.hiero_ops = hiero_ops
        self.initUI()

    def initUI(self):
        self.setWindowTitle(&quot;Info&quot;)
        layout = QVBoxLayout(self)
        self.text_edit = QTextEdit()
        self.text_edit.setReadOnly(True)
        layout.addWidget(self.text_edit)
        self.setLayout(layout)

        # Añadir evento para cerrar la ventana con la tecla ESC
        shortcut = QShortcut(QKeySequence(Qt.Key_Escape), self)
        shortcut.activated.connect(self.close)


    def display_results(self, results):
        &quot;&quot;&quot;Muestra los resultados recopilados en una ventana independiente.&quot;&quot;&quot;
        debug_print(&quot;Displaying results...&quot;)
        message = &quot;&quot;&quot;
        &lt;style&gt;
            p { line-height: 1.5; margin: 0; padding: 0; }
            b { color: #CCCC00; }
            .assignee { color: #007ACC; font-weight: bold; }
            .version { color: #007ACC; font-weight: bold; }
            .description-title { color: #009688; font-weight: bold; }
            .comment { display: inline; margin-left: 20px; }
            .comment-user { color: #AAAAAA; } /* Nuevo estilo para los nombres de comentaristas */
        &lt;/style&gt;
        &quot;&quot;&quot;
        lines = []
        total_lines = 0

        for result in results:
            debug_print(f&quot;Processing result: {result}&quot;)
            description = result['description'] if result['description'] is not None else &quot;Sin descripción&quot;
            assignee = result['assignee'] if result['assignee'] is not None else &quot;No assignee&quot;
            versions = result['versions']

            shot_code = f&quot;&lt;b&gt;{result['shot_code']}&lt;/b&gt;&quot;
            assignee_formatted = f&quot;&lt;span class='assignee'&gt;{assignee}&lt;/span&gt;&quot;

            lines.append(f&quot;{shot_code} | {assignee_formatted}&quot;)
            message += f&quot;&lt;p&gt;{shot_code} | {assignee_formatted}&lt;br&gt;&quot;
            message += f&quot;&lt;span class='description-title'&gt;Description:&lt;/span&gt; {description}&lt;br&gt;&quot;

            total_lines += 3  # Cada resultado tiene al menos 3 líneas
            for version in versions:
                version_number = version['version_number'].split('_')[-1]
                version_line = f&quot;&lt;span class='version'&gt;{version_number}:&lt;/span&gt; {version['version_description']}&lt;br&gt;&quot;
                lines.append(version_line)
                message += version_line
                total_lines += 1

                for comment in version['comments']:
                    comment_user = comment['user']
                    comment_text = re.sub(r'\n\n+', '&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;', comment['text'])
                    comment_text = re.sub(r'\n', '&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;', comment_text)
                    comment_line = f&quot;&lt;b class='comment-user'&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;{comment_user}:&lt;/b&gt; {comment_text}&quot;
                    
                    # Usar span en lugar de div para evitar saltos de línea
                    lines.append(comment_line)
                    message += f&quot;&lt;span class='comment'&gt;{comment_line}&lt;/span&gt;&lt;br&gt;&quot;

                    # Contar el número de &lt;br&gt; para calcular el número de líneas
                    br_count = comment_text.count('&lt;br&gt;')
                    total_lines += br_count + 1  # Añadir el número de &lt;br&gt; más una línea por el comentario

            message += &quot;&lt;/p&gt;&quot;
            total_lines += 4  # Añadir una línea adicional por el espacio del &lt;/p&gt; y una más por margen entre shots

        self.text_edit.setHtml(message.strip())  # Eliminar cualquier espacio en blanco al final
        self.adjustSize()  # Ajusta el tamaño del diálogo según su contenido

        # Encontrar la longitud de la línea más larga en texto plano
        def strip_html_tags(text):
            clean = re.compile('&lt;.*?&gt;')
            return re.sub(clean, '', text)

        # Dividir las líneas que contienen &lt;br&gt; antes de quitar las etiquetas HTML
        plain_text_lines = []
        for line in lines:
            split_lines = line.split('&lt;br&gt;')
            for split_line in split_lines:
                plain_text_lines.append(strip_html_tags(split_line))

        longest_line = max(plain_text_lines, key=len)
        longest_line_length = len(longest_line)
        debug_print(f&quot;Longest plain text line: {longest_line}&quot;)
        debug_print(f&quot;Longest plain text line length (characters): {longest_line_length}&quot;)

        # Calcular el ancho basado en la longitud de la línea más larga en texto plano
        font_metrics = QFontMetrics(self.text_edit.font())
        char_width = font_metrics.averageCharWidth()
        char_height = font_metrics.height()
        debug_print(f&quot;Average character width (pixels): {char_width}&quot;)
        width = longest_line_length * char_width + 10  # Sumar un pequeño margen
        debug_print(f&quot;Calculated width (pixels): {width}&quot;)
        height = total_lines * char_height + 40  # Sumar un margen adicional para evitar cortes

        # Limitar el tamaño máximo de la ventana
        max_width = 1920
        max_height = 1080

        if width &gt; max_width:
            width = max_width
        if height &gt; max_height:
            height = max_height

        self.resize(width, height)  # Redimensiona el diálogo con el nuevo ancho y altura

        self.setWindowFlags(self.windowFlags() | Qt.Window)  # Asegurarse de que la ventana sea independiente
        self.show()  # Mostrar la ventana
        debug_print(&quot;Results displayed successfully.&quot;)
        debug_print(f&quot;Final window size - Width: {width}, Height: {height}&quot;)

def main():
    global app, window

    # Obtén el path del script actual
    script_path = os.path.dirname(__file__)

    # Genera la ruta relativa para el archivo JSON
    json_path = os.path.join(script_path, 'Data', 'LGA_NKS_Flow_Downloader_Local.json')

    # Verifica si el archivo JSON existe
    if not os.path.exists(json_path):
        debug_print(f&quot;JSON file not found at path: {json_path}&quot;)
        return

    sg_manager = ShotGridManager(json_path)
    hiero_ops = HieroOperations(sg_manager)

    if not QApplication.instance():
        app = QApplication(sys.argv)
    else:
        app = QApplication.instance()

    window = GUIWindow(hiero_ops)
    results = hiero_ops.process_selected_clips()
    debug_print(f&quot;Results: {results}&quot;)
    window.display_results(results)
    window.show()
    app.exec_()


main()
import os
import re
import hiero.core
import hiero.ui

def extract_version_number(version_str):
    &quot;&quot;&quot;Extrae el número de versión numérico de un string de versión.&quot;&quot;&quot;
    match = re.search(r'_v(\d+)', version_str)
    if match:
        return int(match.group(1))
    return 0

def print_push_format(base_name):
    project_name = base_name.split('_')[0]
    parts = base_name.split('_')
    shot_code = '_'.join(parts[:5])

    version_number_str = None
    for part in parts:
        if part.startswith('v') and part[1:].isdigit():
            version_number_str = part
            break

    if version_number_str:
        version_number = int(version_number_str.replace('v', ''))
        print(f&quot;Push Format:&quot;)
        print(f&quot;Shot code: {shot_code}, Version number: {version_number}&quot;)
    else:
        print(&quot;Error: No valid version number found in the file name.&quot;)
        return

    version_index = parts.index(version_number_str)
    task_name = parts[version_index - 1].lower()

    print(f&quot;Project Name: {project_name}&quot;)
    print(f&quot;Shot Code: {shot_code}&quot;)
    print(f&quot;Task Name: {task_name}&quot;)
    print(f&quot;Base Name: {base_name}&quot;)
    print(f&quot;Version Number: {version_number_str}&quot;)

def print_pull_format(file_path):
    base_name = re.sub(r'_%04d\.exr$', '', os.path.basename(file_path))
    version_match = re.search(r'(_v\d+)', base_name)
    version_str = version_match.group(1) if version_match else '_vUnknown'

    project_name = base_name.split('_')[0]
    parts = base_name.split('_')
    shot_code = '_'.join(parts[:5])
    version_number = extract_version_number(version_str)

    # Utilizar la misma lógica que en Push para obtener el nombre de la task
    version_index = parts.index(version_str[1:])
    task_name = parts[version_index - 1].lower()

    print(f&quot;Pull Format:&quot;)
    print(f&quot;Project Name: {project_name}&quot;)
    print(f&quot;Shot Code: {shot_code}&quot;)
    print(f&quot;Task Name: {task_name}&quot;)
    print(f&quot;Base Name: {base_name}&quot;)
    print(f&quot;Version String: {version_str}&quot;)
    print(f&quot;Version Number: {version_number}&quot;)

def process_clips():
    seq = hiero.ui.activeSequence()
    if not seq:
        print(&quot;No active sequence found in Hiero.&quot;)
        return

    te = hiero.ui.getTimelineEditor(seq)
    selected_clips = te.selection()
    if not selected_clips:
        print(&quot;No clips selected on the timeline.&quot;)
        return

    for clip in selected_clips:
        if isinstance(clip, hiero.core.EffectTrackItem):  # Verificar si es un efecto
            continue

        file_path = clip.source().mediaSource().fileinfos()[0].filename() if clip.source().mediaSource().fileinfos() else None
        if not file_path or '_comp_' not in os.path.basename(file_path).lower():
            continue

        base_name = os.path.basename(file_path).replace('.exr', '')

        print_push_format(base_name)
        print_pull_format(file_path)

process_clips()
import nuke
from collections import defaultdict

# Variable global para activar o desactivar los prints
DEBUG = False

def debug_print(*message):
    if DEBUG:
        print(message)

def arrange_nodes():
    # Obtener nodos seleccionados
    selected_nodes = nuke.selectedNodes()

    # Iniciar el undo
    undo = nuke.Undo()
    undo.begin(&quot;Arrange Nodes&quot;)

    # Crear una lista con todos los nodos seleccionados que no sean backdrops ni viewers
    regular_nodes = [node for node in selected_nodes if node.Class() not in [&quot;BackdropNode&quot;, &quot;Viewer&quot;]]

    # Paso 0: Almacenar posiciones originales
    original_positions = {
        node: (
            node.xpos() + node.screenWidth() / 2,  # Centro horizontal
            node.ypos() + node.screenHeight() / 2  # Centro vertical
        ) for node in regular_nodes
    }

    debug_print(&quot;___________________________&quot;)
    debug_print(&quot;\n++Posicion original de los nodos:\n&quot;)
    for node, pos in original_positions.items():
        debug_print(f&quot;{node.name()}: Posición X = {pos[0]}, Posición Y = {pos[1]}&quot;)

    # Crear columnGroups basados en la proximidad en X
    debug_print(&quot;___________________________&quot;)
    debug_print(&quot;\n++Analizando que nodos pertenecen a cada columna:\n&quot;)
    columnGroups = defaultdict(list)
    toleranciaY = 0  # valor en Y de tolerancia
    toleranciaX = 55  # valor en X de tolerancia para agrupar los nodos en distintas columnas

    for node in sort_nodes_by_position(regular_nodes):
        pos = original_positions[node][0]  # Usar la posición X almacenada en original_positions
        found_group = False
        # debug_print(f&quot;Procesando nodo {node.name()} en posición X: {pos}&quot;)
        for group_pos in columnGroups.keys():
            distance = abs(pos - group_pos)
            # debug_print(f&quot;Comparando con grupo en {group_pos}, distancia: {distance}&quot;)
            if distance &lt;= toleranciaX:
                columnGroups[group_pos].append(node)
                found_group = True
                debug_print(f&quot;Agrupando {node.name()} en grupo {group_pos}&quot;)
                break
        if not found_group:
            columnGroups[pos].append(node)
            debug_print(f&quot;Creando nuevo grupo para {node.name()} en posición {pos}&quot;)

    # Determinar la altura de cada grupo y encontrar la columna (grupo) principal
    columnGroupHeights = {}
    for group_pos, nodes in columnGroups.items():
        highest_node = max(nodes, key=lambda n: n.ypos())
        lowest_node = min(nodes, key=lambda n: n.ypos())
        columnGroupHeights[group_pos] = highest_node.ypos() - lowest_node.ypos()

    max_height = 0
    principalGroup = None

    for group_pos, group_nodes in columnGroups.items():
        subgroups, subgroup_heights = subdivide_column_and_get_heights(group_nodes)
        local_max_height = max(subgroup_heights, default=0)
        
        if local_max_height &gt; max_height:
            max_height = local_max_height
            principalGroup = group_pos

    # Verifica si la principalGroup es None
    if principalGroup is None:
        debug_print(&quot;No se encontró una columna principal.&quot;)
        undo.end()  # Cierra el grupo de Undo
        return  # Termina la ejecución del método si no hay una columna principal                 

    # Numerar columnas secundarias según su distancia a la principal
    column_order = sorted(columnGroups.keys())
    principal_index = column_order.index(principalGroup)
    column_numbers = {pos: idx - principal_index for idx, pos in enumerate(column_order)}

    # Imprimir la numeración y los nodos de cada columna
    debug_print(&quot;___________________________&quot;)
    debug_print(&quot;\n++Columnas con sus Nodos Contenidos:\n&quot;)
    for pos, index in column_numbers.items():
        nodes_in_column = [node.name() for node in columnGroups[pos]]
        debug_print(f&quot;Columna {pos} (Num: {index}) contiene los nodos: {nodes_in_column}&quot;)

    # Ordenar las posiciones de las columnas en base a su distancia relativa, priorizando la proximidad a la columna principal
    sorted_column_positions = sorted(columnGroups.keys(), key=lambda x: (abs(column_numbers[x]), column_numbers[x]))

    # Paso 1: Distribuir la columna principal y almacenar las posiciones current.
    current_positions = original_positions
    for group_pos in sorted_column_positions:
        if group_pos == principalGroup:
            debug_print(&quot;___________________________&quot;)
            debug_print(&quot;\n++Columna Principal:\n&quot;)
            distribute_columns(columnGroups[group_pos], toleranciaY, 0, current_positions)
            align_nodes_in_column(columnGroups[group_pos])  # Alinear los nodos a la derecha   

            # Filtrar para obtener solo los nodos en la columna principal de original_positions
            principal_nodes_positions = {node: pos for node, pos in original_positions.items() if node in columnGroups[group_pos]}
            # Identificar el nodo con la posición en Y más baja (más alto en la pantalla) entre los nodos de la columna principal
            topTopNode = min(principal_nodes_positions, key=lambda node: principal_nodes_positions[node][1])
            topTopNodeY = principal_nodes_positions[topTopNode][1]
            # debug_print(f&quot;Nodo más alto en la columna principal: {topTopNode.name()}, Posición Y: {principal_nodes_positions[topTopNode][1]}&quot;)

    # Paso 2 y 3: Ajustar y distribuir columnas secundarias.
    &quot;&quot;&quot;
    Las columnas segundarias vamos a dividirlas en:
            Subgrupos: Partes de esta columna compuestas por nodos conectados entre sí
            SubSubGrupos: Son partes del Subgrupo. Son temporales. Se buscan de abajo hacia arriba los nodos conectados con otra columna.
                         Cuando se encuentra alguno, se genera un subsubgrupo desde este nodo hacia al más alto del subgrupo
            SubSubGruposOld: Es una variable temporal que guarda al subsubgrupo anterior. Se crea para generar una nueva ditribución
                             de este luego de haber offseteado el nodo inferior del subsubgrupo.
            potential_columns: incluye a la columna principal y todas las columnas entre la columna actual y la principal
                             
            Antes de aplicar el offset/ y distribución del subsubgrupo nuevo, tenemos que ver si existe un SubSubGruposOld.
            Si existe, tenemos que evaluar cual será el valor para el lowest_node con offset de align. 
            Este valor lo tomaremos viendo el current_position del nodo + el offset_y. 
            Lo almacenaremos en una variable llamada lowest_temp_y
            Esto nos dará el valor en Y al que quedará este lowest_node luego de su distribución con offset.

            Luego, tendremos que analizar cuales son los nodos del SubSubGruposOld. Y de arriba hacia abajo hacer lo siguiente:
            Al más alto, no lo moveremos (porque es el mismo nodo que el lowest_node del subsubgroup.
            Al que le siga, lo moveremos 10 pixeles hacia abajo del valor lowest_temp_y (es decir lowest_temp_y + 10)
            Al que le siga, lo moveremos 10 pixeles * 2 hacia abajo del valor lowest_temp_y (es decir lowest_temp_y + 10*2)
            y así hasta llegar al más bajo del Old, al que no moveremos.

    &quot;&quot;&quot;
    for group_pos, group_nodes in columnGroups.items():
        if group_pos == principalGroup:
            continue  # Omitir la columna principal

        # Subdividir la columna secundaria en subgrupos basados en las conexiones
        debug_print(&quot;___________________________&quot;)
        debug_print(&quot;\n++Columna Secundaria:\n&quot;)
        subgroups = subdivide_column(group_nodes)  # Uso la funcion subdivide_column para dividir a la columna en subgrupos
        subSubgroupOld = None  # Inicializar la variable para guardar el subSubgrupo anterior

        for subgroup in subgroups:
            # Ordenar los nodos de este subgrupo de abajo hacia arriba y luego invertir para comenzar desde el más bajo
            sorted_subgroup = sorted(subgroup, key=lambda n: n.ypos(), reverse=True)
            any_connected_node = False  # Variable para rastrear si se encontró alguna conexión en el subgrupo

            for node in sorted_subgroup:
                connected_node = None

                # Crear una lista de columnas con potenciales nodos conectados al nodo actual
                # incluye a la columna principal y todas las columnas entre la columna actual y la principal
                potential_columns = [columnGroups[principalGroup]]  # Siempre incluir la columna principal
                if column_numbers[group_pos] &gt; 0:  # Si la columna actual está a la derecha de la principal
                    potential_columns += [columnGroups[col] for col in sorted_column_positions if 0 &lt;= column_numbers[col] &lt; column_numbers[group_pos]]
                elif column_numbers[group_pos] &lt; 0:  # Si la columna actual está a la izquierda de la principal
                    potential_columns += [columnGroups[col] for col in sorted_column_positions if column_numbers[group_pos] &lt; column_numbers[col] &lt;= 0]

                # Verificar si este nodo está conectado a algun nodo de las columnas potenciales
                for column in potential_columns:
                    for target_node in column:
                        # Usar la funcion is_connected_to_any_node para detectar si el node está conectado al grupo de nodos target_node
                        if is_connected_to_any_node(node, [target_node]): 
                            connected_node = target_node
                            break
                    if connected_node:
                        break




                # Determinar las columnas que están más lejos de la principal que la columna actual
                next_columns = []
                if column_numbers[group_pos] &gt; 0:  # Si la columna actual está a la derecha de la principal
                    next_columns = [columnGroups[col] for col in sorted_column_positions if column_numbers[col] &gt; column_numbers[group_pos]]
                elif column_numbers[group_pos] &lt; 0:  # Si la columna actual está a la izquierda de la principal
                    next_columns = [columnGroups[col] for col in sorted_column_positions if column_numbers[col] &lt; column_numbers[group_pos]]

                # Imprimir la columna actual y las columnas que están más lejos de la principal
                debug_print(f&quot;Columna actual: {group_pos} (Nodos: {[node.name() for node in columnGroups[group_pos]]})&quot;)
                debug_print(&quot;Columnas más lejos de la principal seleccionadas:&quot;)
                for col in next_columns:
                    if col:  # Asegurarse de que la lista no esté vacía
                        debug_print(f&quot;Columna {col[0].name()} (Nodos: {[node.name() for node in col]})&quot;)
                    else:
                        debug_print(&quot;No hay columnas más lejos de la principal.&quot;)


                if connected_node:
                    any_connected_node = True

                    # Buscar la posicion en Y del connected_node
                    current_y_connected = current_positions[connected_node][1]

                    # Crear una lista plana de todos los nodos en potential_columns
                    node_set_potential = [node for column in potential_columns for node in column]
                    # Crear una lista plana de todos los nodos en next_columns
                    node_set_next = [node for column in next_columns for node in column]

                    # Llamar a la funcion que detecta si algun nodo de las potential column esta conectado a alguno de las next_columns
                    next_connected_nodeY = is_connected_to_any_column(current_y_connected, node_set_potential, node_set_next, current_positions)
                    debug_print(f&quot;+++++++++******---+++++++next_connected_nodeY {next_connected_nodeY}&quot;)

                    # Buscar el nodo conectado directamente en este subgroup comparando nombres
                    node_position = None
                    for i, sub_node in enumerate(subgroup):
                        if sub_node.name() == node.name():
                            node_position = i
                            break

                    debug_print(f&quot;- Nodos en el  sub grupo: {[node.name() for node in subgroup]}&quot;)

                    if node_position is not None:
                        debug_print(f&quot;Match encontrado para {node.name()} en la posición {node_position} del subgroup.&quot;)
                        # Crear subSubgroup desde el nodo encontrado hacia arriba (hasta el final de la lista)
                        subSubgroup = subgroup[node_position:]
                        debug_print(f&quot;- Nodos en el subSubgroup: {[n.name() for n in subSubgroup]}&quot;)

                    else:
                        subSubgroup = subgroup
                        subSubgroupOld = None
                        debug_print(f&quot;No se encontró un match para {node.name()} en el subgroup.&quot;)

                    original_y_connected = original_positions[connected_node][1]
                    current_y = current_positions[node][1]
                    current_y_connected = current_positions[connected_node][1]
                    offset_y = current_y_connected - original_y_connected

                    # Aplicar offset a todo el subgrupo basado en la conexión encontrada
                    debug_print(&quot;/n-------      Offseteando el Sub Sub Grupo:   ----------------&quot;)
                    debug_print(f&quot;Nodo {node.name()} conectado a: {connected_node.name()}&quot;)
                    debug_print(f&quot;Posición Y original de {connected_node.name()}: {original_y_connected}&quot;)
                    debug_print(f&quot;Posición Y current de {connected_node.name()}: {current_y_connected}&quot;)
                    debug_print(f&quot;Offset Y sin align: {offset_y}&quot;)

                    debug_print(f&quot;Calculando el offset extra para alinear usando actual y {current_y}&quot;)
                    offset_align = original_y_connected - current_y
                    debug_print(f&quot;offset necesitad para align: {offset_align}&quot;)
                    offset_y += offset_align
                    debug_print(f&quot;Offset Y total incluyendo align: {offset_y}&quot;)

                    # Si ya existia un subSubgroupOld, entonces tenemos que fijarnos que los nodos de este queden
                    # todos por debajo del lowest_node del subsubgroup. Sino nos pueden quedar desordenados.
                    # Los mandamos a distribuir cerca uno de otro y después los distribuimos bien
                    if subSubgroupOld:
                        lowest_temp_y = current_y_connected
                        connected_node_position = next((i for i, n in enumerate(subSubgroupOld) if n.name() == node.name()), None)
                        debug_print(f&quot;connected_node_position: {connected_node_position}&quot;)
                        debug_print(f&quot;node name: {node.name()}&quot;)
                        if connected_node_position is not None:
                            # Crear subSubgroupOldTrim hasta el nodo conectado actual
                            subSubgroupOldTrim = subSubgroupOld[:connected_node_position + 1]
                            debug_print(f&quot;Nodos en subSubgroupOldTrim: {[n.name() for n in subSubgroupOldTrim]}&quot;)
                        else:
                            subSubgroupOldTrim = subSubgroupOld  # En caso de no encontrarlo, usamos el grupo completo

                        debug_print(f&quot;Vamos a mandar a distribuir el subSubgroupOldTrim: {[n.name() for n in subSubgroupOldTrim]} debajo de {connected_node.name()} en {lowest_temp_y}&quot;)
                        distribute_subSubgroupOld(subSubgroupOldTrim, lowest_temp_y, current_positions)

                    debug_print(f&quot;Vamos a mandar a distribuir el subSubgroup: {[n.name() for n in subSubgroup]}&quot;)
                    distribute_columns(subSubgroup, toleranciaY, offset_y, current_positions)

                    if subSubgroupOld:
                        # Buscar la posición del nodo actualmente conectado en subSubgroupOld
                        connected_node_position = next((i for i, n in enumerate(subSubgroupOld) if n.name() == node.name()), None)
                        debug_print(f&quot;connected_node_position: {connected_node_position}&quot;)
                        debug_print(f&quot;node name: {node.name()}&quot;)
                        if connected_node_position is not None:
                            # Crear subSubgroupOldTrim hasta el nodo conectado actual
                            subSubgroupOldTrim = subSubgroupOld[:connected_node_position + 1]
                            debug_print(f&quot;Nodos en subSubgroupOldTrim: {[n.name() for n in subSubgroupOldTrim]}&quot;)
                        else:
                            subSubgroupOldTrim = subSubgroupOld  # En caso de no encontrarlo, usamos el grupo completo

                        debug_print(f&quot;- + + + Distribuyendo sin offset subSubgroupOldTrim: {[n.name() for n in subSubgroupOldTrim]}&quot;)
                        distribute_columns(subSubgroupOldTrim, toleranciaY, 0, current_positions)

                    subSubgroupOld = subSubgroup  # Guardar el subSubgrupo actual para la próxima iteración
                    debug_print(f&quot;- + + + Se guardó subSubgroupOld: {[n.name() for n in subSubgroupOld]}&quot;)

                else:  # Si el nodo no está conectado
                    &quot;&quot;&quot;
                    si no encontramos más nodos conectados tenemos que hacer un chequeo de los nodos de abajo hacia arriba (esto pasa automaticamente)
                    y ver si el último nodo no conectado supera en altura (o sea su valor de Y es menor) al nodo más alto de la columna principal
                    en ese caso vamos a mandar a distribuir con distribute_lastSubSubgroupOld
                    &quot;&quot;&quot;
                    if subSubgroupOld is not None and len(subSubgroupOld) &gt; 0:
                        debug_print(&quot;\nChequeando si el nodo mas alto está mas arriba que el más alto de la columna principal:&quot;)
                        if node == subSubgroupOld[-1]:  # Verigicamos si es el último nodo del subSubgroupOld
                            debug_print(f&quot;*****Nodo {node.name()} es el último del subSubgroupOld (y no está conectado).&quot;)
                            # Verificamos si este nodo no esté más alto que el topTopNode
                            if current_positions[node][1] &lt; topTopNodeY:
                                debug_print(f&quot;*****El nodo {node.name()} {current_positions[node][1]} está más alto que el topTopNodeY {topTopNodeY}.&quot;)
                                # Los tenemos que mandar a distribuir cerca uno de otro y después los distribuimos bien
                                distribute_lastSubSubgroupOld(subSubgroupOld, topTopNodeY, current_positions)
                            else:
                                debug_print(f&quot;*****El nodo {node.name()} {current_positions[node][1]} NO está más alto que el topTopNodeY {topTopNodeY}.&quot;)
                            &quot;&quot;&quot;
                            Si es el último nodo, también tenemos que chequear que su altura no sea mayor al nodo siguiente en altura 
                            &quot;&quot;&quot;
                            debug_print(&quot;\nTambién tenemos que chequear que su altura no sea mayor al nodo que le sigue:&quot;)
                            debug_print(f&quot;++++next_connected_nodeY {next_connected_nodeY}&quot;)
                            debug_print(f&quot;++++current_positions[node][1] {current_positions[node][1]}&quot;)
                            current_node_y_margin = current_positions[node][1] - 30
                            if next_connected_nodeY is not None and current_node_y_margin &lt; next_connected_nodeY:
                                debug_print(f&quot;*****El nodo {node.name()} en Y {current_node_y_margin} incluyendo margen de 30 está más alto que el next_connected_nodeY {next_connected_nodeY}.&quot;)
                                # Los tenemos que mandar a distribuir cerca uno de otro y después los distribuimos bien
                                distribute_lastSubSubgroupOld(subSubgroupOld, next_connected_nodeY, current_positions)
                        else:
                            debug_print(f&quot;*****Nodo {node.name()} sin conexión.&quot;)
                        debug_print(f&quot;*****Nodos en subSubgroupOld: {[n.name() for n in subSubgroupOld]}&quot;)

            if not any_connected_node:
                debug_print(&quot;no conectados&quot;)
                distribute_columns(subgroup, toleranciaY, 0, current_positions)  # Distribuir si no se encontraron conexiones

            align_nodes_in_column(subgroup)  # Alinear los nodos a la derecha después de la distribución

        undo.end()

def sort_nodes_by_position(nodes, reverse=False):
    # Solo lo uso para ordenarlos en X
    return sorted(nodes, key=lambda n: (node_center(n)[0], node_center(n)[1]), reverse=reverse)

def is_connected_to_any_column(current_y_connected, node_set_potential, node_set_next, current_positions):
    &quot;&quot;&quot;
    Busca nodos en las potential_columns que estén desde current_y_connected hacia arriba,
    y verifica si tienen alguna conexión con nodos en las next_columns.
    &quot;&quot;&quot;
    # Extraemos los nombres de los nodos en node_set_next para facilitar la comparación.
    next_node_names = {node.name() for node in node_set_next}

    # Filtrar nodos en potential_columns que estén desde current_y_connected hacia arriba
    filtered_nodes = [node for node in node_set_potential if current_positions[node][1] &lt;= current_y_connected]

    # Ordenar nodos por su posición Y de menor a mayor (más alto a más bajo)
    filtered_nodes.sort(key=lambda node: current_positions[node][1])

    # Iterar sobre los nodos filtrados para verificar conexiones
    for node in filtered_nodes:
        # Verificar conexiones de salida hacia nodos en next_columns
        for i in range(node.inputs()):
            input_node = node.input(i)
            if input_node and input_node.name() in next_node_names:
                next_connected_nodeY = current_positions[node][1]
                debug_print(f&quot;Conexión encontrada desde {node.name()} en {next_connected_nodeY} hacia {input_node.name()} en next_columns&quot;)
                return next_connected_nodeY

    debug_print(&quot;No se encontraron conexiones desde nodos altos de potential_columns hacia next_columns.&quot;)
    return None

def distribute_lastSubSubgroupOld(group_nodes, topTopNodeY, current_positions=None):
    &quot;&quot;&quot; 
    Baja el primer nodo (nodo no conectado más alto) 35 pixeles por debajo del nodo más alto de la columna principal 
    Después baja el resto de 10 en 10
    Después los distribuye
    &quot;&quot;&quot;
    debug_print(f&quot;\n+ - + - Arranca el distribute_lastSubSubgroupOld: {[node.name() for node in group_nodes]}&quot;)  # Imprime los nombres de los nodos en group_nodes

    if current_positions is None:
        current_positions = {}  # Inicializa si no se proporciona ningún diccionario
        debug_print(&quot;*****Sin current position&quot;)
    else:
        pass

    # Definir o actualizar las current_positions con la posición central actual de cada nodo
    for node in group_nodes:
        if node not in current_positions:
            current_x = node.xpos() + node.screenWidth() / 2
            current_y = node.ypos() + node.screenHeight() / 2
            current_positions[node] = (current_x, current_y)
        else:
            pass

    # Ubicar al nodo más alto 30 pixeles por debajo del topTopNodeY
    highest_node = min(group_nodes, key=lambda n: current_positions[n][1])
    new_y = topTopNodeY + 30
    nodo_height = highest_node.screenHeight() / 2
    highest_node.setYpos(round(new_y - nodo_height))  # Para el valor de pos real hay que restar la mitad de la altura del nodo
    current_positions[highest_node] = (current_positions[highest_node][0], new_y)

    # 2 - Distribuir en caso de que haya más de 1 nodo en el grupo / columna
    if len(group_nodes) &gt; 1:
        debug_print(&quot;+ - + -hay más de 1 nodo, vamos a distribuir de a 10 el lastSubSubgroupOld&quot;)

        # Identificar el nodo más alto y el más bajo usando current_positions
        highest_node = min(group_nodes, key=lambda n: current_positions[n][1])
        lowest_node = max(group_nodes, key=lambda n: current_positions[n][1])

        # Calcular el nuevo espaciado basado en los nodos extremos
        top_position = topTopNodeY + 30
        bottom_position = current_positions[lowest_node][1]
        spacing = 10

        debug_print(f&quot;+ - + -top_position {top_position}&quot;)
        debug_print(f&quot;+ - + -spacing {spacing}&quot;)
        debug_print(f&quot;+ - + -Nodo más alto FI POS: {highest_node.name()}&quot;)
        debug_print(f&quot;+ - + -Nodo más bajo FI POS: {lowest_node.name()}&quot;)

        current_position = topTopNodeY + 30
        debug_print(f&quot;current_position fuera {current_position}&quot;)

        for node in sorted(group_nodes, key=lambda n: current_positions[n][1], reverse=False):
            if node not in (highest_node, lowest_node):
                debug_print(f&quot;+ - + -current_position {current_position} del nodo {node.name()} &quot;)
                new_y = current_position
                nodo_height = node.screenHeight() / 2
                node.setYpos(round(new_y - nodo_height))  # Para el valor de pos real hay que restar la mitad de la altura del nodo
                current_positions[node] = (current_positions[node][0], new_y)
                debug_print(f&quot;+ - + -Posición actualizada de B {node.name()}: Y = {new_y}&quot;)  # El valor de fina_pos siempre es el centro del nodo
            else:
                debug_print(f&quot;+ - + -Posición de {node.name()} no cambia (nodo mas alto o mas bajo).&quot;)
                pass
            current_position += spacing

    if len(group_nodes) &gt; 2:
        debug_print(&quot;hay más de 2 nodos, vamos a distribuir (sino solo se aplicaría offset&quot;)

        # Identificar el nodo más alto y el más bajo usando current_positions
        highest_node = min(group_nodes, key=lambda n: current_positions[n][1])
        lowest_node = max(group_nodes, key=lambda n: current_positions[n][1])

        # Calcular el nuevo espaciado basado en los nodos extremos
        top_position = current_positions[highest_node][1]
        bottom_position = current_positions[lowest_node][1]
        spacing = (top_position - bottom_position) / (len(group_nodes) - 1) if len(group_nodes) &gt; 1 else 0

        debug_print(f&quot;top_position {top_position}&quot;)
        debug_print(f&quot;spacing {spacing}&quot;)
        debug_print(f&quot;Nodo más alto FI POS: {highest_node.name()} - Y: {top_position}&quot;)
        debug_print(f&quot;Nodo más bajo FI POS: {lowest_node.name()} - Y: {bottom_position}&quot;)

        current_position = current_positions[lowest_node][1]

        for node in sorted(group_nodes, key=lambda n: current_positions[n][1], reverse=True):
            if node not in (highest_node, lowest_node):
                debug_print(f&quot;current_position {current_position} del nodo {node.name()} &quot;)
                new_y = current_position
                nodo_height = node.screenHeight() / 2
                node.setYpos(round(new_y - nodo_height))  # Para el valor de pos real hay que restar la mitad de la altura del nodo
                current_positions[node] = (current_positions[node][0], new_y)
                debug_print(f&quot;Posición actualizada de B {node.name()}: Y = {new_y}&quot;)  # El valor de fina_pos siempre es el centro del nodo
            else:
                debug_print(f&quot;Posición de {node.name()} no cambia (nodo mas alto o mas bajo).&quot;)
                pass
            current_position += spacing

    return current_positions  # Retorna el diccionario actualizado

def distribute_subSubgroupOld(group_nodes, lowest_temp_y, current_positions=None):
    debug_print(f&quot;\n+ - + - Arranca distribute_subSubgroupOld para el distribute_subSubgroupOld: {[node.name() for node in group_nodes]}&quot;)  # Imprime los nombres de los nodos en group_nodes

    if current_positions is None:
        current_positions = {}  # Inicializa si no se proporciona ningún diccionario
        pass

    # Definir o actualizar las current_positions con la posición central actual de cada nodo
    for node in group_nodes:
        if node not in current_positions:
            current_x = node.xpos() + node.screenWidth() / 2
            current_y = node.ypos() + node.screenHeight() / 2
            current_positions[node] = (current_x, current_y)
        else:
            pass

    # 2 - Distribuir en caso de que haya más de 2 nodos en el grupo / columna
    if len(group_nodes) &gt; 2:
        debug_print(&quot;+ - + -hay más de 2 nodos, vamos a distribuir cortito el subSubgroupOld&quot;)

        # Identificar el nodo más alto y el más bajo usando current_positions
        highest_node = min(group_nodes, key=lambda n: current_positions[n][1])
        lowest_node = max(group_nodes, key=lambda n: current_positions[n][1])

        # Calcular el nuevo espaciado basado en los nodos extremos
        top_position = lowest_temp_y
        bottom_position = current_positions[lowest_node][1]
        spacing = 10

        debug_print(f&quot;+ - + -top_position {top_position}&quot;)
        debug_print(f&quot;+ - + -spacing {spacing}&quot;)
        debug_print(f&quot;+ - + -Nodo más alto FI POS: {highest_node.name()}&quot;)
        debug_print(f&quot;+ - + -Nodo más bajo FI POS: {lowest_node.name()}&quot;)

        current_position = lowest_temp_y
        debug_print(f&quot;current_position fuera {current_position}&quot;)

        for node in sorted(group_nodes, key=lambda n: current_positions[n][1], reverse=False):
            if node not in (highest_node, lowest_node):
                debug_print(f&quot;+ - + -current_position {current_position} del nodo {node.name()} &quot;)
                new_y = current_position
                nodo_height = node.screenHeight() / 2
                node.setYpos(round(new_y - nodo_height))  # Para el valor de pos real hay que restar la mitad de la altura del nodo
                current_positions[node] = (current_positions[node][0], new_y)
                debug_print(f&quot;+ - + -Posición actualizada de B {node.name()}: Y = {new_y}&quot;)  # El valor de fina_pos siempre es el centro del nodo
            else:
                debug_print(f&quot;+ - + -Posición de {node.name()} no cambia (nodo mas alto o mas bajo).&quot;)
                pass
            current_position += spacing

    return current_positions  # Retorna el diccionario actualizado

def distribute_columns(group_nodes, toleranciaY, offset_y=0, current_positions=None):
    debug_print(f&quot;\n-- Arranca distribute_columns para el grupo: {[node.name() for node in group_nodes]}&quot;)  # Imprime los nombres de los nodos en group_nodes

    if current_positions is None:
        current_positions = {}  # Inicializa si no se proporciona ningún diccionario
        pass

    # Definir o actualizar las current_positions con la posición central actual de cada nodo
    for node in group_nodes:
        if node not in current_positions:
            current_x = node.xpos() + node.screenWidth() / 2
            current_y = node.ypos() + node.screenHeight() / 2
            current_positions[node] = (current_x, current_y)
        else:
            pass

    debug_print(&quot;paso 1&quot;)
    # 1 - Aplicar el offset para las columnas secundarias si es necesario
    if offset_y != 0:
        for node in group_nodes:
            old_new_y = round(node.ypos() + offset_y)
            # Obtener la posición Y central actual desde current_positions
            current_currentY = current_positions[node][1]
            # Calcular la nueva posición Y basada en el offset
            new_y_pos = round(current_currentY + offset_y)  # Este es el que se pasa a los valores current
            nodo_height = node.screenHeight() / 2
            new_y = round(current_currentY + offset_y - nodo_height)  # Este es el que se pasa para mover el nodo
            debug_print(f&quot;Offset para el nodo {node.name()}&quot;)
            debug_print(f&quot;Posicion current en Y actual {current_currentY}&quot;)
            debug_print(f&quot;Nueva posicion current con offset: {current_currentY} + {offset_y} = {new_y_pos}&quot;)
            node.setXYpos(round(node.xpos()), new_y)  # Actualiza la posición Y del nodo

            # Actualizar las posiciones current después de aplicar el offset
            current_x = current_positions[node][0] if node in current_positions else node.xpos() + node.screenWidth() / 2
            if current_positions is not None:
                current_positions[node] = (
                    current_x,  # Centro horizontal
                    new_y_pos  # Centro vertical con el offset aplicado
                )

    # 2 - Distribuir en caso de que haya más de 2 nodos en el grupo / columna
    if len(group_nodes) &gt; 2:
        debug_print(&quot;hay más de 2 nodos, vamos a distribuir (sino solo se aplicaría offset&quot;)

        # Identificar el nodo más alto y el más bajo usando current_positions
        highest_node = min(group_nodes, key=lambda n: current_positions[n][1])
        lowest_node = max(group_nodes, key=lambda n: current_positions[n][1])

        # Calcular el nuevo espaciado basado en los nodos extremos
        top_position = current_positions[highest_node][1]
        bottom_position = current_positions[lowest_node][1]
        spacing = (top_position - bottom_position) / (len(group_nodes) - 1) if len(group_nodes) &gt; 1 else 0

        debug_print(f&quot;top_position {top_position}&quot;)
        debug_print(f&quot;bottom_position {bottom_position}&quot;)
        debug_print(f&quot;spacing {spacing}&quot;)
        debug_print(f&quot;Nodo más alto FI POS: {highest_node.name()} - Y: {top_position}&quot;)
        debug_print(f&quot;Nodo más bajo FI POS: {lowest_node.name()} - Y: {bottom_position}&quot;)

        current_position = current_positions[lowest_node][1]

        for node in sorted(group_nodes, key=lambda n: current_positions[n][1], reverse=True):
            if node not in (highest_node, lowest_node):
                debug_print(f&quot;current_position {current_position} del nodo {node.name()} &quot;)
                new_y = current_position
                nodo_height = node.screenHeight() / 2
                node.setYpos(round(new_y - nodo_height))  # Para el valor de pos real hay que restar la mitad de la altura del nodo
                current_positions[node] = (current_positions[node][0], new_y)
                debug_print(f&quot;Posición actualizada de B {node.name()}: Y = {new_y}&quot;)  # El valor de fina_pos siempre es el centro del nodo
            else:
                debug_print(f&quot;Posición de {node.name()} no cambia (nodo mas alto o mas bajo).&quot;)
                pass
            current_position += spacing

    return current_positions  # Retorna el diccionario actualizado

def subdivide_column(group_nodes):
    # Divide a cada columna en subgrupos. Cada subgrupo se compone de nodos que están conectados entre sí.
    # Ordenar los nodos de abajo hacia arriba
    sorted_nodes = sorted(group_nodes, key=lambda n: n.ypos(), reverse=True)
    subgroups = []
    current_subgroup = []
    subgroup_number = 1

    for node in sorted_nodes:
        connected_nodes = [node.input(i) for i in range(node.inputs()) if node.input(i)]

        if not connected_nodes:
            if current_subgroup:
                current_subgroup.append(node)  # agrega el nodo actual al subgrupo actual
                subgroups.append(current_subgroup.copy())  # agrega una copia del subgrupo actual a subgroups
                subgroup_number += 1
                current_subgroup = []  # Empieza un nuevo subgrupo vacio
            else:
                subgroups.append([node])
        else:
            for connected_node in connected_nodes:
                if not current_subgroup or any(connected_node in subgroup for subgroup in subgroups):
                    current_subgroup.append(node)
                    break
            else:
                current_subgroup.append(node)

    if current_subgroup:
        subgroups.append(current_subgroup)

    return subgroups

def is_connected_to_any_node(check_node, nodes_set):
    # Verifica y detalla si alguna de las entradas de los nodos en nodes_set coincide con check_node.
    # y después verifica si alguna de las entradas del check_node coincide con alguno de los nombres en nodes_set
    # De esta forma verifica conexiones de entrada y de salida del check_node con alguno del nodes_set

    for node in nodes_set:
        has_input = False

        for i in range(node.inputs()):
            input_node = node.input(i)
            if input_node:
                has_input = True
                if input_node.name() == check_node.name():
                    return True

        if not has_input:
            pass

    node_set_names = {node.name() for node in nodes_set}

    for i in range(check_node.inputs()):
        input_node = check_node.input(i)
        if input_node and input_node.name() in node_set_names:
            return True

    return False

def subdivide_column_and_get_heights(group_nodes):
    # Función para buscar la altura de todos los subgrupos de cada columna, 
    # y en base a eso luego se determina cuál es la columna principal
    sorted_nodes = sorted(group_nodes, key=lambda n: n.ypos(), reverse=True)
    subgroups = []
    heights = []
    current_subgroup = []

    for node in sorted_nodes:
        connected_nodes = [node.input(i) for i in range(node.inputs()) if node.input(i)]
        if not connected_nodes:
            if current_subgroup:
                current_subgroup.append(node)
                subgroups.append(current_subgroup.copy())
                heights.append(max(current_subgroup, key=lambda n: n.ypos()).ypos() - min(current_subgroup, key=lambda n: n.ypos()).ypos())
                current_subgroup = []
        else:
            for connected_node in connected_nodes:
                if not current_subgroup or any(connected_node in subgroup for subgroup in subgroups):
                    current_subgroup.append(node)
                    break
            else:
                current_subgroup.append(node)

    if current_subgroup:
        subgroups.append(current_subgroup)
        heights.append(max(current_subgroup, key=lambda n: n.ypos()).ypos() - min(current_subgroup, key=lambda n: n.ypos()).ypos())

    return subgroups, heights

def align_nodes_in_column(nodes):
    reference_node = max(nodes, key=lambda n: n.xpos() + n.screenWidth())
    reference_pos = reference_node.xpos() + reference_node.screenWidth()

    # Alinear todos los nodos con el nodo de referencia en el eje X
    for n in nodes:
        if n != reference_node:
            offset = (reference_node.screenWidth() / 2) - (n.screenWidth() / 2)
            n.setXpos(int(reference_pos - n.screenWidth() - offset))

def node_center(node):
    return (node.xpos() + node.screenWidth() / 2, node.ypos() + node.screenHeight() / 2)

# Llamar a la función principal
arrange_nodes()
import nuke
from PySide2 import QtCore, QtGui, QtWidgets, QtOpenGL
import re
from collections import namedtuple

DAG_TITLE = &quot;Node Graph&quot;
DAG_OBJECT_NAME = &quot;DAG&quot;

Direction = namedtuple('Direction', 'axis, descending, center')
AXIS_X = 0
AXIS_Y = 1
RIGHT = Direction(axis=AXIS_X, descending=False, center=False)
LEFT = Direction(axis=AXIS_X, descending=True, center=False)
DOWN = Direction(axis=AXIS_Y, descending=False, center=False)
UP = Direction(axis=AXIS_Y, descending=True, center=False)
CENTER_X = Direction(axis=AXIS_X, descending=False, center=True)
CENTER_Y = Direction(axis=AXIS_Y, descending=False, center=True)

class NodeWrapper(object):
    &quot;&quot;&quot; Wraps a nuke node with its bounds, and exposes all the methods from QRectF to be used on the node &quot;&quot;&quot;

    def __init__(self, node):
        &quot;&quot;&quot;
        Args:
            node (nuke.Node): Node to wrap
        &quot;&quot;&quot;
        self.bounds = get_node_bounds(node)
        self.node = node
        self.is_backdrop = node.Class() == &quot;BackdropNode&quot;
        self._nodes_and_margins = None  # For backdrops only

    def __getattr__(self, item):
        try:
            attr = getattr(self.bounds, item)
        except AttributeError:
            return getattr(self.node, item)
        if callable(attr):
            return self._wrapped(attr)
        return attr

    def _wrapped(self, func):
        def wrapper(*args, **kwargs):
            before_size = self.bounds.size()
            result = func(*args, **kwargs)
            self._commit_move()
            if self.bounds.size() != before_size:
                self._commit_resize()
            return result
        return wrapper

    def _commit_move(self):
        new_pos = self.bounds.topLeft().toPoint()
        self.node.setXYpos(new_pos.x(), new_pos.y())

    def _commit_resize(self):
        if not self.is_backdrop:
            raise NotImplementedError(
                &quot;Tried to resize a node other than a backdrop, which is not supported. You may get unexpected results.&quot;
            )
        self._commit_move()
        self.node['bdwidth'].setValue(int(self.bounds.width()))
        self.node['bdheight'].setValue(int(self.bounds.height()))

    def normalize(self):
        self.bounds = self.bounds.normalized()
        self._commit_move()
        self._commit_resize()

    def move_center(self, value, axis):
        &quot;&quot;&quot; Extra method to allow moving a node center based on a single axis

        Args:
            value (int): New center position
            axis (int): Axis index, 0 for X, 1 for Y
        &quot;&quot;&quot;
        current_center = list(self.center().toTuple())
        t = current_center[:]
        current_center[axis] = value
        self.moveCenter(QtCore.QPoint(*current_center))

    def store_margins(self):
        if not self.is_backdrop:
            raise NotImplementedError(&quot;Tried to calculate margins on a non-backdrop node&quot;)
        nodes = self.node.getNodes()
        nodes_bounds = get_nodes_bounds(nodes)
        margins = calculate_bounds_adjustment(nodes_bounds, self)
        self._nodes_and_margins = {'nodes': nodes, 'margins': margins}

    def restore_margins(self):
        if not self.is_backdrop:
            raise NotImplementedError(&quot;Tried to set margins on a non-backdrop node&quot;)
        if not self._nodes_and_margins:
            raise RuntimeError(&quot;No margins were saved for this backdrop, can't restore&quot;)
        nodes_bounds = get_nodes_bounds(self._nodes_and_margins['nodes'])
        nodes_bounds.adjust(*self._nodes_and_margins['margins'])
        self.setCoords(*nodes_bounds.getCoords())

    def place_around_nodes(self, nodes, padding=50):
        if not self.is_backdrop:
            raise NotImplementedError(&quot;Can only place backdrops around nodes&quot;)
        if not nodes:
            return
        label_height = get_label_size(self.node).height()
        nodes_bounds = get_nodes_bounds(nodes)
        nodes_bounds.adjust(-padding, -(padding+label_height), padding, padding)
        self.setCoords(*nodes_bounds.getCoords())

# Group Dags
def get_dag_widgets(visible=True):
    &quot;&quot;&quot;
    Gets all Qt objects with DAG in the object name

    Args:
        visible (bool): Whether or not to return only visible widgets.

    Returns:
        list[QtWidgets.QWidget]
    &quot;&quot;&quot;
    dags = []
    all_widgets = QtWidgets.QApplication.instance().allWidgets()
    for widget in all_widgets:
        if DAG_OBJECT_NAME in widget.objectName():
            if not visible or (visible and widget.isVisible()):
                dags.append(widget)
    return dags

def get_current_dag():
    &quot;&quot;&quot;
    Returns:
        QtWidgets.QWidget: The currently active DAG
    &quot;&quot;&quot;
    visible_dags = get_dag_widgets(visible=True)
    for dag in visible_dags:
        if dag.hasFocus():
            return dag

    # IF None had focus, and we have at least one, use the first one
    if visible_dags:
        return visible_dags[0]
    return None

def get_dag_node(dag_widget):
    &quot;&quot;&quot; Get a DAG node for a given dag widget. &quot;&quot;&quot;
    title = str(dag_widget.windowTitle())
    if DAG_TITLE not in title:
        return None
    if title == DAG_TITLE:
        return nuke.root()
    return nuke.toNode(title.replace(&quot; &quot; + DAG_TITLE, &quot;&quot;))

# Bounds functions
def get_node_bounds(node):
    &quot;&quot;&quot;
    Return a QRectF corresponding to the node dag bounding box / position

    Note: There is a bug in nuke when a freshly created node is being moved where the width/height
    collapses to 0:

        node = nuke.nodes.Grade()
        node.setXYpos(0, 0)
        print node.screenWidth(), node.screenHeight()
        # Result: 0 0
        # Result should be: 80 20

    We handle this in the code

    :param nuke.Node node: Nuke node to get bounds for
    :rtype: QtCore.QRectF
    &quot;&quot;&quot;
    if isinstance(node, NodeWrapper):
        return node.bounds
    if node.Class() == &quot;BackdropNode&quot;:
        width = node['bdwidth'].value()
        height = node['bdheight'].value()
    else:
        width = node.screenWidth()
        height = node.screenHeight()

    if width == 0:  # Handle a bug as mentioned in docstring
        temp_node = getattr(nuke.nodes, node.Class())()  # Make temp node with same class as corrupted node
        try:
            return get_node_bounds(temp_node)
        finally:
            nuke.delete(temp_node)

    return QtCore.QRectF(node.xpos(), node.ypos(), width, height)

def get_nodes_bounds(nodes, center_only=False):
    &quot;&quot;&quot;
    Get the combined DAG bounding box of all the nodes in the list

    Args:
        nodes (list): List of nuke nodes to get bounds for
        center_only (bool): If True, get the bounding rectangle that encompasses the center points of the nodes

    Returns:
        QtCore.QRectF
    &quot;&quot;&quot;
    if not nodes:
        raise ValueError(&quot;No nodes provided to get_nodes_bounds()&quot;)
    all_bounds = [get_node_bounds(n) for n in nodes]
    if center_only:
        poly = QtGui.QPolygon([n.center().toPoint() for n in all_bounds])
        return poly.boundingRect()
    bounds = QtCore.QRectF(all_bounds[0])  # Make a new rect so we don't modify the initial one
    for bound in all_bounds[1:]:
        bounds |= bound
    return bounds

def calculate_bounds_adjustment(bounds, target_bounds):
    &quot;&quot;&quot; Calculate adjust values to apply to 'bounds' in order to match 'target_bounds'

    Args:
        bounds (QtCore.QRectF or NodeWrapper): Original Bounds
        target_bounds (QtCore.QRectF or NodeWrapper): Desired Bounds

    Returns:
        tuple[int, int, int, int]: Bounds adjustments
    &quot;&quot;&quot;
    bounds_coords = bounds.getCoords()
    target_coords = target_bounds.getCoords()
    return tuple(target_coords[i] - bounds_coords[i] for i in range(4))

def get_label_size(node):
    &quot;&quot;&quot; Calculate the size of a label for a nuke Node

    Args:
        node (nuke.Node):

    Returns:
        QtCore.QSize: Size of the label
    &quot;&quot;&quot;
    regex = r'^(.+?)( Bold)?( Italic)?$'
    match = re.match(regex, node['note_font'].value())
    font = QtGui.QFont(match.group(1))
    font.setBold(bool(match.group(2)))
    font.setItalic(bool(match.group(3)))
    font.setPixelSize(node['note_font_size'].value())
    metrics = QtGui.QFontMetrics(font)
    return metrics.size(0, node['label'].value())

class ScaleWidget(QtWidgets.QWidget):
    class _VectorWrapper(object):
        def __init__(self, node, bounds, corner=None):
            &quot;&quot;&quot;
            Store a NodeWrapper and its relative position to the bounds for simplified manipulation.

            :param dag_utils.dag.NodeWrapper node:
            :param QtCore.QRectF bounds: bounds to calculating relative position to
            :param int corner: (Optional)
            &quot;&quot;&quot;
            def _clamp(v):
                &quot;&quot;&quot; Clamp vector between 0 and 1 &quot;&quot;&quot;
                return QtGui.QVector2D(0 if v.x() &lt; 0 else 1 if v.x() &gt; 1 else v.x(),
                                       0 if v.y() &lt; 0 else 1 if v.y() &gt; 1 else v.y())
            self.node_wrapper = node
            self.corner = corner
            self.original_point = self.get_point()
            # Store the corner coordinates relative to the bounds, saves us from calculating it in event loop
            bs = QtGui.QVector2D(bounds.size().width(), bounds.size().height())  # bounds size
            vector = (QtGui.QVector2D(self.get_point()) - QtGui.QVector2D(bounds.topLeft())) / bs
            self.vector = _clamp(vector)
            self.offset = (vector - self.vector) * bs

        def get_point(self):
            &quot;&quot;&quot; Return QPoint corresponding to one of the 4 corners or the center of the node &quot;&quot;&quot;
            if self.corner is None:
                return self.node_wrapper.center()
            elif self.corner == 0:
                return self.node_wrapper.topLeft()
            elif self.corner == 1:
                return self.node_wrapper.topRight()
            elif self.corner == 2:
                return self.node_wrapper.bottomRight()
            return self.node_wrapper.bottomLeft()

        def move(self, new_point, grid_size=None):
            &quot;&quot;&quot; Apply the transformation to the node &quot;&quot;&quot;
            if grid_size:
                new_point = self._snap_to_grid(new_point, grid_size)
            if self.corner is None:
                self.node_wrapper.moveCenter(new_point)
            elif self.corner == 0:
                self.node_wrapper.setTopLeft(new_point)
            elif self.corner == 1:
                self.node_wrapper.setTopRight(new_point)
            elif self.corner == 2:
                self.node_wrapper.setBottomRight(new_point)
            else:
                self.node_wrapper.setBottomLeft(new_point)
                self.node_wrapper.normalize()  # We've moved all corners, normalize the backdrop

        def _snap_to_grid(self, new_point, grid_size):
            old = QtGui.QVector2D(self.original_point)
            new = QtGui.QVector2D(new_point)
            offset = (new - old) / grid_size
            return (old + QtGui.QVector2D(offset.toPoint()) * grid_size).toPoint()

    handles_cursors = (QtCore.Qt.SizeFDiagCursor,
                       QtCore.Qt.SizeVerCursor,
                       QtCore.Qt.SizeBDiagCursor,
                       QtCore.Qt.SizeHorCursor)

    def __init__(self, dag_widget):
        super(ScaleWidget, self).__init__(parent=dag_widget)

        # Group context
        self.dag_node = get_dag_node(self.parent())  # 'dag_widget', but it's garbage collected..

        # Make Widget transparent
        self.setWindowFlags(QtCore.Qt.Window | QtCore.Qt.FramelessWindowHint)
        self.setAttribute(QtCore.Qt.WA_TranslucentBackground)
        self.setAttribute(QtCore.Qt.WA_DeleteOnClose)
        self.setFocusPolicy(QtCore.Qt.NoFocus)

        # Enable mouse tracking so we can get move move events
        self.setMouseTracking(True)

        # Overlay it with the DAG exactly
        dag_rect = dag_widget.geometry()
        dag_rect.moveTopLeft(dag_widget.parentWidget().mapToGlobal(dag_rect.topLeft()))
        self.setGeometry(dag_rect)

        # Attributes
        self.transform = None
        self.grabbed_handle = None
        with self.dag_node:
            self.nodes = nuke.selectedNodes()
        self.bounds = get_nodes_bounds(self.nodes, center_only=True)
        visual_bounds = get_nodes_bounds(self.nodes) + (QtCore.QMargins() + 10)
        adjustment = calculate_bounds_adjustment(self.bounds, visual_bounds)
        self.margins = QtCore.QMargins(adjustment[0] * -1, adjustment[1] * -1, adjustment[2], adjustment[3])
        self.coordinates = self.store_coordinates()
        self.undo = None

        self.translate_mode = False
        self.move_all = False
        prefs = nuke.toNode('preferences')

        self.snap_to_grid = prefs['SnapToGrid'].value()
        self.grid_size = QtGui.QVector2D(max(prefs['GridWidth'].value(), 1),
                                         max(prefs['GridHeight'].value(), 1))

    def store_coordinates(self):
        &quot;&quot;&quot; Get the coordinates of all nodes and store them in a VectorWrapper &quot;&quot;&quot;
        all_coords = []
        with self.dag_node:
            for node in nuke.allNodes():
                node_wrapper = NodeWrapper(node)
                if node_wrapper.is_backdrop:
                    all_coords += [self._VectorWrapper(node_wrapper, self.bounds, corner) for corner in range(4)]
                else:
                    all_coords.append(self._VectorWrapper(node_wrapper, self.bounds))
        return all_coords

    def reset_state(self):
        &quot;&quot;&quot; Re-grab the coordinates of all the nodes &quot;&quot;&quot;
        self.grabbed_handle = None
        self.coordinates = self.store_coordinates()

    def paintEvent(self, event):
        &quot;&quot;&quot; Draw The widget &quot;&quot;&quot;
        painter = QtGui.QPainter(self)
        painter.save()

        # Calculate the proper place to draw the stuff
        local_rect = self.geometry()
        local_rect.moveTopLeft(QtCore.QPoint(0, 0))
        with self.dag_node:
            scale = nuke.zoom()
            offset = local_rect.center()/scale - QtCore.QPoint(*nuke.center())
        painter.scale(scale, scale)
        painter.translate(offset)
        self.transform = painter.combinedTransform()

        # Draw the bounds rectangle
        black_pen = QtGui.QPen()
        black_pen.setColor(QtGui.QColor('black'))
        black_pen.setWidth(3)
        black_pen.setCosmetic(True)

        painter.setPen(black_pen)
        painter.drawRect(self.bounds.marginsAdded(self.margins))

        # Draw the handles
        yellow_brush = QtGui.QBrush()
        yellow_brush.setColor(QtGui.QColor('yellow'))
        yellow_brush.setStyle(QtCore.Qt.SolidPattern)

        handle_size = int(16/scale)
        handle = QtCore.QRectF(0, 0, handle_size, handle_size)
        painter.setBrush(yellow_brush)
        for point in self.get_handles_points():
            handle.moveCenter(point)
            painter.drawRect(handle)

        # Add a text hint for usage
        painter.restore()
        local_rect.setTop(local_rect.bottom() - 70)
        text = 'Resize Mode enabled'
        if self.snap_to_grid:
            text += ' (Snap to Grid: ON)'
        text += &quot;\nDrag any handle to affect the spacing between your nodes.&quot;
        text += &quot;\nCtrl+Drag: affect all nodes, Shift+Drag: Translate, 'S': Toggle Snap to grid, 'Esc': Cancel, &quot;
        text += &quot;Any other key: Confirm and close&quot;
        painter.setPen(black_pen)
        painter.drawText(local_rect,  QtCore.Qt.AlignCenter, text)
        painter.setPen(QtGui.QPen(QtGui.QColor('white')))
        painter.drawText(local_rect.translated(1, -1), QtCore.Qt.AlignCenter, text)

    def get_handles_points(self):
        &quot;&quot;&quot; Return a list of 8 QPoints representing the 8 handles we want to draw &quot;&quot;&quot;
        bounds = self.bounds.marginsAdded(self.margins)
        return [
            bounds.topLeft(),
            QtCore.QPoint(bounds.center().x(), bounds.top()),
            bounds.topRight(),
            QtCore.QPoint(bounds.right(), bounds.center().y()),
            bounds.bottomRight(),
            QtCore.QPoint(bounds.center().x(), bounds.bottom()),
            bounds.bottomLeft(),
            QtCore.QPoint(bounds.left(),bounds.center().y())
        ]

    def get_handle_at_pos(self, pos):
        &quot;&quot;&quot; Get the handle nearest the provided position &quot;&quot;&quot;
        handles = self.get_handles_points()
        nearest = (0, None)  # index, distance
        for i, handle in enumerate(handles):
            transformed = self.transform.map(handle)
            transformed -= pos
            dist = transformed.manhattanLength()
            if nearest[1] is None or dist &lt; nearest[1]:
                nearest = (i, dist)
        return nearest[0]

    def resize_bounds(self, handle, pos):
        &quot;&quot;&quot; Resize the QRectF representing the bounding box controller based on the clicked handle &quot;&quot;&quot;
        if handle is None:
            return
        # As the user interacts with the visual bounds rather than the computed ones, we need to take this into account
        bounds = self.bounds.marginsAdded(self.margins)
        invert_matrix, _invert_success = self.transform.inverted()
        pos = invert_matrix.map(pos)
        attr_prefix = 'move' if self.translate_mode else 'set'
        if handle == 0:
            getattr(bounds, '{}TopLeft'.format(attr_prefix))(pos)
        elif handle == 1:
            getattr(bounds, '{}Top'.format(attr_prefix))(pos.y())
        elif handle == 2:
            getattr(bounds, '{}TopRight'.format(attr_prefix))(pos)
        elif handle == 3:
            getattr(bounds, '{}Right'.format(attr_prefix))(pos.x())
        elif handle == 4:
            getattr(bounds, '{}BottomRight'.format(attr_prefix))(pos)
        elif handle == 5:
            getattr(bounds, '{}Bottom'.format(attr_prefix))(pos.y())
        elif handle == 6:
            getattr(bounds, '{}BottomLeft'.format(attr_prefix))(pos)
        elif handle == 7:
            getattr(bounds, '{}Left'.format(attr_prefix))(pos.x())
        self.bounds = bounds.marginsRemoved(self.margins)
        self.repaint()

    def scale_nodes(self, handle, pos, all_nodes=False):
        &quot;&quot;&quot; Moves either the selected nodes or all the nodes to their relative space to the bounding box controller &quot;&quot;&quot;
        if not self.undo:
            # Start undo stack so that the operation can be reverted cleanly
            self.undo = nuke.Undo()
            self.undo.begin('Scale Nodes')

        self.resize_bounds(handle, pos)
        new_size = QtGui.QVector2D(self.bounds.size().width(), self.bounds.size().height())
        new_top_left = QtGui.QVector2D(self.bounds.topLeft())

        for coord in self.coordinates:
            if not all_nodes and coord.node_wrapper.node not in self.nodes:
                continue
            new_relative_pos = coord.vector * new_size
            new_pos = new_top_left + new_relative_pos + coord.offset
            coord.move(new_pos.toPoint(), self.grid_size if self.snap_to_grid else None)

    def mouseMoveEvent(self, event):
        &quot;&quot;&quot; Check which handle is nearest the mouse and set the appropriate cursor &quot;&quot;&quot;
        if QtWidgets.QApplication.keyboardModifiers() &amp; QtCore.Qt.ShiftModifier:
            self.setCursor(QtCore.Qt.SizeAllCursor)
        else:
            handle_index = self.get_handle_at_pos(event.pos())
            self.setCursor(self.handles_cursors[handle_index % 4])

    def eventFilter(self, widget, event):
        &quot;&quot;&quot; Filter all the events happening while the bounding box controller is shown &quot;&quot;&quot;
        if event.type() in [QtCore.QEvent.MouseButtonPress]:
            if not self.geometry().contains(event.globalPos()):
                # Clicked outside the widget
                self.close()
                return False

            if event.button() == QtCore.Qt.LeftButton:
                if widget is self:
                    # Clicked on one of the opaque areas of the widget
                    self.grabbed_handle = self.get_handle_at_pos(event.pos())
                    self.move_all = bool(QtWidgets.QApplication.keyboardModifiers() &amp; QtCore.Qt.ControlModifier)
                    self.translate_mode = bool(QtWidgets.QApplication.keyboardModifiers() &amp; QtCore.Qt.ShiftModifier)
                    return True

                # Left mouse button was clicked, outside the widget.
                if not QtWidgets.QApplication.keyboardModifiers() and event.buttons() == event.button():
                    # The mouse press event had no other button pressed at the same time
                    # However, events can happen on other widgets, so check click position
                    if isinstance(widget, QtOpenGL.QGLWidget):
                        self.close()
                    return False

        elif event.type() in [QtCore.QEvent.MouseButtonRelease]:
            if event.button() == QtCore.Qt.LeftButton and widget is self:
                self.reset_state()
                return True

        elif event.type() in [QtCore.QEvent.MouseMove]:
            # Mouse moved, if we had a handle grabbed, resize nodes.
            if self.grabbed_handle is not None:
                self.scale_nodes(self.grabbed_handle, event.pos(), all_nodes=self.move_all)
                return True

            # Otherwise, if a button is pressed, we might be moving the dag, so repaint.
            if event.buttons():
                self.repaint()

        elif event.type() == QtCore.QEvent.KeyPress:
            if event.key() == QtCore.Qt.Key_Escape:
                self.cancel()
            elif event.key() == QtCore.Qt.Key_S:
                # toggle snap to grid
                self.snap_to_grid = not self.snap_to_grid
                self.repaint()
            # close and accept on any non modifier key
            elif event.key() not in [QtCore.Qt.Key_Control, QtCore.Qt.Key_Alt, QtCore.Qt.Key_Shift]:
                self.close()

            return True

        # Due to a QT bug, out transparent widget is swallowing wheel events, pass them back to DAG
        # See https://bugreports.qt.io/browse/QTBUG-53418
        elif event.type() == QtCore.QEvent.Wheel and widget is self:
            dag = get_dag_widgets()[0]
            gl_widget = dag.findChild(QtOpenGL.QGLWidget)
            if gl_widget:
                QtWidgets.QApplication.sendEvent(gl_widget, event)
                self.repaint()
                return True

        return False

    def show(self):
        if len(self.nodes) &lt; 2:
            # self.restore_context()
            return
        # self.dag_node.begin()
        super(ScaleWidget, self).show()
        # Install Event filter
        QtWidgets.QApplication.instance().installEventFilter(self)

    def cancel(self):
        if self.undo:
            self.undo.cancel()
            self.undo = None
        self.close()

    def close(self):
        if self.undo:
            self.undo.end()
        QtWidgets.QApplication.instance().removeEventFilter(self)
        super(ScaleWidget, self).close()

def scale_tree():
    &quot;&quot;&quot; Scale nodes with a bounding widget. &quot;&quot;&quot;
    this_dag = get_current_dag()
    scale_tree_widget = ScaleWidget(this_dag)
    scale_tree_widget.show()


scale_tree()import importlib
import scale_widget
importlib.reload(scale_widget)import importlib
from nuke_move_nodes import pull_nodes
importlib.reload(pull_nodes)import importlib
from nuke_move_nodes import pull_nodes
importlib.reload(pull_nodes)import importlib
import oz_backdrop
importlib.reload(oz_backdrop)# Para eliminar toda una pestaña de preferencias
p = nuke.toNode('preferences')
if p.knob(&quot;W_hotbox&quot;):
    p.removeKnob(p.knob(&quot;W_hotbox&quot;))p = nuke.toNode('preferences')

# Eliminar todos los knobs dentro de la pestaña W_hotbox
knobs_to_remove = [knob for knob in p.knobs() if knob.startswith(&quot;W_hotbox&quot;)]
for knob in knobs_to_remove:
    p.removeKnob(p.knob(knob))

# Luego, eliminar la pestaña W_hotbox si aún existe
if p.knob(&quot;W_hotbox&quot;):
    p.removeKnob(p.knob(&quot;W_hotbox&quot;))p = nuke.toNode('preferences')

# Eliminar todas las preferencias relacionadas con W_hotbox y MyTool
knobs_to_remove = [knob for knob in p.knobs() if knob.startswith(&quot;W_hotbox&quot;) or knob.startswith(&quot;MyTool&quot;)]
for knob in knobs_to_remove:
    p.removeKnob(p.knob(knob))

# Eliminar las pestañas si aún existen
if p.knob(&quot;W_hotbox&quot;):
    p.removeKnob(p.knob(&quot;W_hotbox&quot;))
if p.knob(&quot;MyTool&quot;):
    p.removeKnob(p.knob(&quot;MyTool&quot;))
p = nuke.toNode('preferences')

# Eliminar todas las preferencias relacionadas con W_hotbox y MyTool
knobs_to_remove = [knob for knob in p.knobs() if knob.startswith(&quot;W_hotbox&quot;) or knob.startswith(&quot;MyTool&quot;)]
for knob in knobs_to_remove:
    p.removeKnob(p.knob(knob))

# Eliminar las pestañas si aún existen
if p.knob(&quot;W_hotbox&quot;):
    p.removeKnob(p.knob(&quot;W_hotbox&quot;))
if p.knob(&quot;MyTool&quot;):
    p.removeKnob(p.knob(&quot;MyTool&quot;))
import importlib
import oz_backdrop
importlib.reload(oz_backdrop)import importlib
import oz_backdrop
importlib.reload(oz_backdrop)import nuke
import time

def get_preference_value(pref_name, default_value):
    preferences = nuke.toNode('preferences')
    if preferences:
        try:
            return preferences[pref_name].value()
        except:
            return default_value
    else:
        return default_value

# Intentar obtener el nodo de preferencias varias veces con un retraso
preferences = None
for _ in range(5):  # Intentar 5 veces
    preferences = nuke.toNode('preferences')
    if preferences:
        break
    time.sleep(0.5)  # Esperar medio segundo antes de intentar nuevamente

# Si no se pudo obtener el nodo de preferencias, usar valores por defecto
if preferences:
    try:
        appearance_value = preferences['Oz_Backdrop_Appearance'].value()
        default_color = preferences['Oz_Backdrop_color'].value()
        alignment_value = preferences['Oz_Backdrop_text_alignment'].value()
        note_font_size = int(preferences['Oz_Backdrop_font_size'].value())
        margin_value = int(preferences['Oz_Backdrop_margin'].value())
        bold_value = preferences['Oz_Backdrop_bold'].value()
        print(&quot;Appearance:&quot;, appearance_value)
        print(&quot;Default Color:&quot;, default_color)
        print(&quot;Alignment:&quot;, alignment_value)
        print(&quot;Font Size:&quot;, note_font_size)
        print(&quot;Margin:&quot;, margin_value)
        print(&quot;Bold:&quot;, bold_value)
    except Exception as e:
        print(&quot;Error reading preferences:&quot;, e)
else:
    print(&quot;Preferences node not found&quot;)
import importlib
import oz_backdrop
importlib.reload(oz_backdrop)import importlib
import oz_backdrop
importlib.reload(oz_backdrop)import importlib
import oz_backdrop
importlib.reload(oz_backdrop)import importlib
import oz_backdrop
importlib.reload(oz_backdrop)
import importlib
import oz_backdrop
importlib.reload(oz_backdrop)
import importlib
import oz_backdrop
importlib.reload(oz_backdrop)
import importlib
import oz_backdrop
importlib.reload(oz_backdrop)
import importlib
import oz_backdrop
importlib.reload(oz_backdrop)
import importlib
import oz_backdrop
importlib.reload(oz_backdrop)
import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_encompassScript
importlib.reload(oz_encompassScript)

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_backdrop
import oz_encompassScript

# Recargar ambos scripts
importlib.reload(oz_encompassScript)
importlib.reload(oz_backdrop)import importlib
import oz_backdrop
import oz_encompassScript

# Recargar ambos scripts
importlib.reload(oz_encompassScript)
importlib.reload(oz_backdrop)import importlib
import oz_backdrop
import oz_encompassScript

# Recargar ambos scripts
importlib.reload(oz_encompassScript)
importlib.reload(oz_backdrop)import importlib
import oz_backdrop
import oz_encompassScript

# Recargar ambos scripts
importlib.reload(oz_encompassScript)
importlib.reload(oz_backdrop)import importlib
import oz_backdrop
import oz_encompassScript

# Recargar ambos scripts
importlib.reload(oz_encompassScript)
importlib.reload(oz_backdrop)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import os
print(os.environ.get('SHOTGRID_URL'))
print(os.environ.get('SHOTGRID_LOGIN'))
print(os.environ.get('SHOTGRID_PASSWORD'))
print(os.environ.get('SHOTGRID_SCRIPT_NAME'))
print(os.environ.get('SHOTGRID_API_KEY'))import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_disable_A_B
importlib.reload(LGA_disable_A_B)import importlib
import LGA_revealFlow
importlib.reload(LGA_revealFlow)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_arrangeNodes
importlib.reload(LGA_arrangeNodes)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_RnW_ColorSpace_Favs
importlib.reload(LGA_RnW_ColorSpace_Favs)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_RnW_ColorSpace_Favs
importlib.reload(LGA_RnW_ColorSpace_Favs)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_knobChangedScript
importlib.reload(oz_knobChangedScript)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_knobChangedScript
importlib.reload(oz_knobChangedScript)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_knobChangedScript
importlib.reload(oz_knobChangedScript)
import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_knobChangedScript
importlib.reload(oz_knobChangedScript)
import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_knobChangedScript
importlib.reload(oz_knobChangedScript)
import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_knobChangedScript
importlib.reload(oz_knobChangedScript)
import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_knobChangedScript
importlib.reload(oz_knobChangedScript)
import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_knobChangedScript
importlib.reload(oz_knobChangedScript)

import importlib
import LGA_oz_backdropReplacer
importlib.reload(LGA_oz_backdropReplacer)
import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_knobChangedScript
importlib.reload(oz_knobChangedScript)

import importlib
import LGA_oz_backdropReplacer
importlib.reload(LGA_oz_backdropReplacer)
import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_knobChangedScript
importlib.reload(oz_knobChangedScript)

import importlib
import LGA_oz_backdropReplacer
importlib.reload(LGA_oz_backdropReplacer)
import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_knobChangedScript
importlib.reload(oz_knobChangedScript)

import importlib
import LGA_oz_backdropReplacer
importlib.reload(LGA_oz_backdropReplacer)
import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_knobChangedScript
importlib.reload(oz_knobChangedScript)

import importlib
import LGA_oz_backdropReplacer
importlib.reload(LGA_oz_backdropReplacer)
import nuke
undo = nuke.Undo()
undo.end()

import importlib
import oz_backdrop
importlib.reload(oz_backdrop)

import importlib
import oz_knobChangedScript
importlib.reload(oz_knobChangedScript)

import importlib
import LGA_oz_backdropReplacer
importlib.reload(LGA_oz_backdropReplacer)
import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_mediaManager
importlib.reload(LGA_mediaManager)

import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_mediaManager
importlib.reload(LGA_mediaManager)

import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_mediaManager
importlib.reload(LGA_mediaManager)

import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_mediaManager
importlib.reload(LGA_mediaManager)

import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_mediaManager
importlib.reload(LGA_mediaManager)

import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_mediaManager
importlib.reload(LGA_mediaManager)

import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_mediaManager
importlib.reload(LGA_mediaManager)

import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_mediaManager
importlib.reload(LGA_mediaManager)

import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_mediaManager
importlib.reload(LGA_mediaManager)

import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_mediaManager
importlib.reload(LGA_mediaManager)

import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_mediaManager
importlib.reload(LGA_mediaManager)

import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_mediaManager
importlib.reload(LGA_mediaManager)

import nuke
undo = nuke.Undo()
undo.end()

import importlib
import Dots
importlib.reload(Dots)

import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_mediaManager
importlib.reload(LGA_mediaManager)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_mediaManager
importlib.reload(LGA_mediaManager)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_mediaManager
importlib.reload(LGA_mediaManager)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_mediaManager
importlib.reload(LGA_mediaManager)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_mediaManager
importlib.reload(LGA_mediaManager)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import Dots
importlib.reload(Dots)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import Dots
importlib.reload(Dots)&quot;&quot;&quot;
__________________________________________________________

  LGA_gradeHI v1.4 | 2024 | Lega   
  Crea un Dot debajo del nodo seleccionado, otro Dot a la derecha, 
  seguido por un Keyer, un Shuffle y un Dot debajo del Dot derecho. 
  También crea un Grade debajo del primer Dot en la columna principal, 
  alineado en X al primer Dot y centrado en Y con el nodo más bajo de la 
  columna derecha. La distribución en la columna derecha sigue la lógica
  de distribución del script proporcionado. El nodo Shuffle está configurado
  para conectar el canal alpha de rgba al output de todos los canales rgba.
__________________________________________________________

&quot;&quot;&quot;

import nuke

# Variable global para activar o desactivar los prints
DEBUG = False

def debug_print(message):
    if DEBUG:
        print(message)

def gradeHI():
    # Definir las distancias entre los nodos
    distanciaY = 30  # Espacio libre entre nodos en la columna derecha
    distanciaX = 180
    dot_width = int(nuke.toNode(&quot;preferences&quot;)['dot_node_scale'].value() * 12)
    
    # Obtener el nodo seleccionado
    try:
        selected_node = nuke.selectedNode()
    except ValueError:
        nuke.message(&quot;No node selected.&quot;)
        return

    current_node = selected_node
    current_node_center_x = current_node.xpos() + (current_node.screenWidth() / 2)
    current_node_center_y = current_node.ypos() + (current_node.screenHeight() / 2)

    # Buscar el primer nodo que esté debajo del nodo seleccionado con una tolerancia en X
    all_nodes = [n for n in nuke.allNodes() if n != current_node and n.Class() != 'Root' and n.Class() != 'BackdropNode']
    nodo_siguiente_en_columna = None
    distMedia_NodoSiguiente = float('inf')

    for node in all_nodes:
        node_center_x = node.xpos() + (node.screenWidth() / 2)
        node_center_y = node.ypos() + (node.screenHeight() / 2)

        if abs(node_center_x - current_node_center_x) &lt;= 120 and node_center_y &gt; current_node_center_y:
            distance = node_center_y - current_node_center_y
            if distance &gt; 0 and distance &lt; distMedia_NodoSiguiente:
                distMedia_NodoSiguiente = distance
                nodo_siguiente_en_columna = node

    # Ajustar la distancia Y si es necesario
    if distMedia_NodoSiguiente != float('inf') and distMedia_NodoSiguiente &lt; distanciaY * 2:
        distanciaY = distMedia_NodoSiguiente / 2 - (dot_width / 2) - 6

    # Crear el primer Dot debajo del nodo seleccionado
    dot_below = nuke.nodes.Dot()
    dot_below.setXpos(int(current_node.xpos() + (current_node.screenWidth() / 2) - (dot_width / 2)))
    dot_below.setYpos(int(current_node.ypos() + current_node.screenHeight() + distanciaY))
    dot_below.setInput(0, current_node)

    # Si hay un nodo siguiente en la misma columna, ajustar las conexiones
    if nodo_siguiente_en_columna and current_node in nodo_siguiente_en_columna.dependencies(nuke.INPUTS):
        for i in range(nodo_siguiente_en_columna.inputs()):
            if nodo_siguiente_en_columna.input(i) == current_node:
                nodo_siguiente_en_columna.setInput(i, dot_below)
                break
    
    # Crear el Dot a la derecha del primer Dot
    dot_right = nuke.nodes.Dot()
    dot_right.setXpos(dot_below.xpos() + distanciaX)
    dot_right.setYpos(dot_below.ypos())
    dot_right.setInput(0, dot_below)

    # Crear un Keyer debajo del Dot derecho
    keyer = nuke.nodes.Keyer(operation=&quot;luminance key&quot;)
    keyer.setXpos(dot_right.xpos() - (keyer.screenWidth() // 2) + (dot_width // 2))
    keyer.setYpos(dot_right.ypos() + distanciaY)
    keyer.setInput(0, dot_right)

    # Crear un Shuffle debajo del Keyer
    shuffle = nuke.nodes.Shuffle2(label=&quot;[value in1] --&gt; [value out1]&quot;)
    shuffle['fromInput1'].setValue('rgba')
    shuffle['fromInput2'].setValue('rgba')
    shuffle['mappings'].setValue(&quot;4 rgba.alpha 0 3 rgba.red 0 0 rgba.alpha 0 3 rgba.green 0 1 rgba.alpha 0 3 rgba.blue 0 2 rgba.alpha 0 3&quot;)
    shuffle.setXpos(keyer.xpos())
    shuffle.setYpos(keyer.ypos() + keyer.screenHeight() + distanciaY)
    shuffle.setInput(0, keyer)

    # Crear un Dot debajo del Shuffle
    dot_bottom = nuke.nodes.Dot()
    dot_bottom.setXpos(shuffle.xpos() - (dot_width // 2) + (shuffle.screenWidth() // 2))
    dot_bottom.setYpos(shuffle.ypos() + shuffle.screenHeight() + distanciaY)
    dot_bottom.setInput(0, shuffle)

    # Distribuir los nodos en la columna derecha
    distribute_nodes_in_column([dot_right, keyer, shuffle, dot_bottom], 'v', distanciaY)

    # Crear un Grade debajo del primer Dot y conectarlo
    grade = nuke.nodes.Grade()
    grade.setXpos(dot_below.xpos() - (grade.screenWidth() // 2) + (dot_width // 2))

    # Alinear el nodo Grade centrado en Y al último nodo de la columna derecha
    grade.setYpos(int(dot_bottom.ypos() + (dot_bottom.screenHeight() // 2) - (grade.screenHeight() // 2)))
    
    grade.setInput(0, dot_below)
    grade.setInput(1, dot_bottom)  # Conectar la máscara al último Dot

    # Si había un nodo siguiente, conectarlo al nodo Grade
    if nodo_siguiente_en_columna:
        for i in range(nodo_siguiente_en_columna.inputs()):
            if nodo_siguiente_en_columna.input(i) == dot_below:
                nodo_siguiente_en_columna.setInput(i, grade)
                break

def distribute_nodes_in_column(nodes, direction, spacing):
    nodes.sort(key=lambda node: node.ypos() if direction == 'v' else node.xpos())
    positions = [node.ypos() for node in nodes] if direction == 'v' else [node.xpos() for node in nodes]
    nodes_info = [(node, node.screenHeight() if direction == 'v' else node.screenWidth(), pos) for node, pos in zip(nodes, positions)]

    if len(nodes_info) &lt; 2:
        return

    first_node = nodes_info[0]
    last_node = nodes_info[-1]
    total_length = last_node[2] + last_node[1] - first_node[2]
    size_of_nodes = sum(node_info[1] for node_info in nodes_info)
    free_space = total_length - size_of_nodes

    if free_space &lt; 0:
        increment = 0
    else:
        increment = free_space / (len(nodes_info) - 1)

    current_pos = first_node[2] + first_node[1]

    for i, (node, size, pos) in enumerate(nodes_info):
        if i == 0 or i == len(nodes_info) - 1:
            continue
        current_pos += increment
        if direction == 'v':
            node.setYpos(int(current_pos))
        elif direction == 'h':
            node.setXpos(int(current_pos))
        current_pos += size

# Ejecutar el script
gradeHI()
&quot;&quot;&quot;
__________________________________________________________

  LGA_gradeHI v1.3 | 2024 | Lega   
  Crea un Dot debajo del nodo seleccionado, otro Dot a la derecha, 
  seguido por un Keyer, un Shuffle y un Dot debajo del Dot derecho. 
  También crea un Grade debajo del primer Dot en la columna principal, 
  alineado en X al primer Dot y centrado en Y con el nodo más bajo de la 
  columna derecha. La distribución en la columna derecha sigue la lógica
  de distribución del script proporcionado.
__________________________________________________________

&quot;&quot;&quot;

import nuke

# Variable global para activar o desactivar los prints
DEBUG = False

def debug_print(message):
    if DEBUG:
        print(message)

def gradeHI():
    # Definir las distancias entre los nodos
    distanciaY = 30  # Espacio libre entre nodos en la columna derecha
    distanciaX = 180
    dot_width = int(nuke.toNode(&quot;preferences&quot;)['dot_node_scale'].value() * 12)
    
    # Obtener el nodo seleccionado
    try:
        selected_node = nuke.selectedNode()
    except ValueError:
        nuke.message(&quot;No node selected.&quot;)
        return

    current_node = selected_node
    current_node_center_x = current_node.xpos() + (current_node.screenWidth() / 2)
    current_node_center_y = current_node.ypos() + (current_node.screenHeight() / 2)

    # Buscar el primer nodo que esté debajo del nodo seleccionado con una tolerancia en X
    all_nodes = [n for n in nuke.allNodes() if n != current_node and n.Class() != 'Root' and n.Class() != 'BackdropNode']
    nodo_siguiente_en_columna = None
    distMedia_NodoSiguiente = float('inf')

    for node in all_nodes:
        node_center_x = node.xpos() + (node.screenWidth() / 2)
        node_center_y = node.ypos() + (node.screenHeight() / 2)

        if abs(node_center_x - current_node_center_x) &lt;= 120 and node_center_y &gt; current_node_center_y:
            distance = node_center_y - current_node_center_y
            if distance &gt; 0 and distance &lt; distMedia_NodoSiguiente:
                distMedia_NodoSiguiente = distance
                nodo_siguiente_en_columna = node

    # Ajustar la distancia Y si es necesario
    if distMedia_NodoSiguiente != float('inf') and distMedia_NodoSiguiente &lt; distanciaY * 2:
        distanciaY = distMedia_NodoSiguiente / 2 - (dot_width / 2) - 6

    # Crear el primer Dot debajo del nodo seleccionado
    dot_below = nuke.nodes.Dot()
    dot_below.setXpos(int(current_node.xpos() + (current_node.screenWidth() / 2) - (dot_width / 2)))
    dot_below.setYpos(int(current_node.ypos() + current_node.screenHeight() + distanciaY))
    dot_below.setInput(0, current_node)

    # Si hay un nodo siguiente en la misma columna, ajustar las conexiones
    if nodo_siguiente_en_columna and current_node in nodo_siguiente_en_columna.dependencies(nuke.INPUTS):
        for i in range(nodo_siguiente_en_columna.inputs()):
            if nodo_siguiente_en_columna.input(i) == current_node:
                nodo_siguiente_en_columna.setInput(i, dot_below)
                break
    
    # Crear el Dot a la derecha del primer Dot
    dot_right = nuke.nodes.Dot()
    dot_right.setXpos(dot_below.xpos() + distanciaX)
    dot_right.setYpos(dot_below.ypos())
    dot_right.setInput(0, dot_below)

    # Crear un Keyer debajo del Dot derecho
    keyer = nuke.nodes.Keyer(operation=&quot;luminance key&quot;)
    keyer.setXpos(dot_right.xpos() - (keyer.screenWidth() // 2) + (dot_width // 2))
    keyer.setYpos(dot_right.ypos() + distanciaY)
    keyer.setInput(0, dot_right)

    # Crear un Shuffle debajo del Keyer
    shuffle = nuke.nodes.Shuffle2(label=&quot;[value in1] --&gt; [value out1]&quot;)
    shuffle.setXpos(keyer.xpos())
    shuffle.setYpos(keyer.ypos() + keyer.screenHeight() + distanciaY)
    shuffle.setInput(0, keyer)

    # Crear un Dot debajo del Shuffle
    dot_bottom = nuke.nodes.Dot()
    dot_bottom.setXpos(shuffle.xpos() - (dot_width // 2) + (shuffle.screenWidth() // 2))
    dot_bottom.setYpos(shuffle.ypos() + shuffle.screenHeight() + distanciaY)
    dot_bottom.setInput(0, shuffle)

    # Distribuir los nodos en la columna derecha
    distribute_nodes_in_column([dot_right, keyer, shuffle, dot_bottom], 'v', distanciaY)

    # Crear un Grade debajo del primer Dot y conectarlo
    grade = nuke.nodes.Grade()
    grade.setXpos(dot_below.xpos() - (grade.screenWidth() // 2) + (dot_width // 2))

    # Alinear el nodo Grade centrado en Y al último nodo de la columna derecha
    grade.setYpos(int(dot_bottom.ypos() + (dot_bottom.screenHeight() // 2) - (grade.screenHeight() // 2)))
    
    grade.setInput(0, dot_below)
    grade.setInput(1, dot_bottom)  # Conectar la máscara al último Dot

    # Si había un nodo siguiente, conectarlo al nodo Grade
    if nodo_siguiente_en_columna:
        for i in range(nodo_siguiente_en_columna.inputs()):
            if nodo_siguiente_en_columna.input(i) == dot_below:
                nodo_siguiente_en_columna.setInput(i, grade)
                break

def distribute_nodes_in_column(nodes, direction, spacing):
    nodes.sort(key=lambda node: node.ypos() if direction == 'v' else node.xpos())
    positions = [node.ypos() for node in nodes] if direction == 'v' else [node.xpos() for node in nodes]
    nodes_info = [(node, node.screenHeight() if direction == 'v' else node.screenWidth(), pos) for node, pos in zip(nodes, positions)]

    if len(nodes_info) &lt; 2:
        return

    first_node = nodes_info[0]
    last_node = nodes_info[-1]
    total_length = last_node[2] + last_node[1] - first_node[2]
    size_of_nodes = sum(node_info[1] for node_info in nodes_info)
    free_space = total_length - size_of_nodes

    if free_space &lt; 0:
        increment = 0
    else:
        increment = free_space / (len(nodes_info) - 1)

    current_pos = first_node[2] + first_node[1]

    for i, (node, size, pos) in enumerate(nodes_info):
        if i == 0 or i == len(nodes_info) - 1:
            continue
        current_pos += increment
        if direction == 'v':
            node.setYpos(int(current_pos))
        elif direction == 'h':
            node.setXpos(int(current_pos))
        current_pos += size

# Ejecutar el script
gradeHI()
import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_grade
importlib.reload(LGA_grade)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_switchMergeOperations
importlib.reload(LGA_switchMergeOperations)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_switchMergeOperations
importlib.reload(LGA_switchMergeOperations)import nuke

# Variable global para habilitar o deshabilitar prints
DEBUG = {
    'A': True,   # Información de cada nodo
    'B': True,   # Resultados de las cuentas
}

def debug_print_A(*message):
    if DEBUG['A']:
        print(' '.join(str(m) for m in message))

def debug_print_B(*message):
    if DEBUG['B']:
        print(' '.join(str(m) for m in message))

def combine_grades():
    # Obtener los nodos seleccionados
    selected_nodes = nuke.selectedNodes('Grade')
    
    if not selected_nodes:
        print(&quot;Por favor, selecciona al menos un nodo Grade.&quot;)
        return
    
    # Inicializar valores combinados
    blackpoint_sum = 0.0
    whitepoint_sum = 0.0
    multiply_mult = 1.0
    add_sum = 0.0
    gamma_mult = 1.0
    gain_mult = 1.0
    mix_values = []
    
    for idx, grade in enumerate(selected_nodes):
        debug_print_A(f&quot;\nNodo Grade {idx + 1} - Nombre: {grade['name'].value()}&quot;)
        
        blackpoint = float(grade['blackpoint'].value())
        whitepoint = float(grade['whitepoint'].value())
        multiply = float(grade['multiply'].value())
        add = float(grade['add'].value())
        gamma = float(grade['gamma'].value())
        gain = float(grade['white'].value())  # Equivalente a Gain
        mix = float(grade['mix'].value())
        
        debug_print_A(f&quot;  blackpoint: {blackpoint}&quot;)
        debug_print_A(f&quot;  whitepoint: {whitepoint}&quot;)
        debug_print_A(f&quot;  multiply: {multiply}&quot;)
        debug_print_A(f&quot;  add: {add}&quot;)
        debug_print_A(f&quot;  gamma: {gamma}&quot;)
        debug_print_A(f&quot;  gain: {gain}&quot;)
        debug_print_A(f&quot;  mix: {mix}&quot;)
        
        blackpoint_sum += blackpoint
        whitepoint_sum += whitepoint
        multiply_mult *= multiply
        add_sum += add
        gamma_mult *= gamma
        gain_mult *= gain
        mix_values.append(mix)
    
    # Calcular el promedio para Mix
    mix_average = sum(mix_values) / len(mix_values) if mix_values else 1.0
    
    # Print de los resultados de las cuentas
    debug_print_B(f&quot;\nResultados de las cuentas:&quot;)
    debug_print_B(f&quot;  Suma de blackpoint: {blackpoint_sum}&quot;)
    debug_print_B(f&quot;  Suma de whitepoint: {whitepoint_sum}&quot;)
    debug_print_B(f&quot;  Multiplicación de multiply: {multiply_mult}&quot;)
    debug_print_B(f&quot;  Suma de add: {add_sum}&quot;)
    debug_print_B(f&quot;  Multiplicación de gamma: {gamma_mult}&quot;)
    debug_print_B(f&quot;  Multiplicación de gain (white): {gain_mult}&quot;)
    debug_print_B(f&quot;  Promedio de mix: {mix_average}&quot;)
    
    # Crear un nuevo nodo Grade
    combined_grade = nuke.createNode('Grade')
    
    # Asignar los valores combinados al nuevo nodo Grade respetando el orden de operaciones
    combined_grade['blackpoint'].setValue(blackpoint_sum)
    combined_grade['whitepoint'].setValue(whitepoint_sum)
    combined_grade['multiply'].setValue(multiply_mult)
    combined_grade['add'].setValue(add_sum)
    combined_grade['gamma'].setValue(gamma_mult)
    combined_grade['white'].setValue(gain_mult)
    combined_grade['mix'].setValue(mix_average)

# Ejecutar la función
combine_grades()
import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_merge
importlib.reload(LGA_merge)import hiero.core
import os
import re
import shotgun_api3
import sys

class ShotGridManager:
    def __init__(self, url, login, password):
        self.sg = shotgun_api3.Shotgun(url, login=login, password=password)

    def find_shot_and_tasks(self, project_name, shot_code):
        projects = self.sg.find(&quot;Project&quot;, [['name', 'is', project_name]], ['id', 'name'])
        if projects:
            project_id = projects[0]['id']
            filters = [
                ['project', 'is', {'type': 'Project', 'id': project_id}],
                ['code', 'is', shot_code]
            ]
            fields = ['id', 'code', 'description']
            shots = self.sg.find(&quot;Shot&quot;, filters, fields)
            if shots:
                shot_id = shots[0]['id']
                tasks = self.find_tasks_for_shot(shot_id)
                return shots[0], tasks
            else:
                print(&quot;No se encontró el shot.&quot;)
        else:
            print(&quot;No se encontró el proyecto en ShotGrid.&quot;)
        return None, None

    def find_tasks_for_shot(self, shot_id):
        filters = [['entity', 'is', {'type': 'Shot', 'id': shot_id}]]
        fields = ['id', 'content', 'sg_description', 'sg_status_list', 'sg_estimated_days']
        return self.sg.find(&quot;Task&quot;, filters, fields)

    def find_version_by_code(self, shot_id, version_code):
        filters = [
            ['entity', 'is', {'type': 'Shot', 'id': shot_id}],
            ['code', 'contains', version_code]
        ]
        fields = ['id', 'code', 'created_at', 'user', 'sg_status_list', 'description']
        versions = self.sg.find(&quot;Version&quot;, filters, fields)
        return versions

    def get_task_url(self, task_id):
        return f&quot;{self.sg.base_url}/detail/Task/{task_id}&quot;

    def get_version_notes(self, version_id):
        filters = [['note_links', 'in', {'type': 'Version', 'id': version_id}]]
        fields = ['content', 'user']
        return self.sg.find(&quot;Note&quot;, filters, fields)

class HieroOperations:
    def __init__(self, shotgrid_manager):
        self.sg_manager = shotgrid_manager

    def parse_exr_name(self, file_name):
        base_name = re.sub(r'_%04d\.exr$', '', file_name)
        version_match = re.search(r'_v(\d+)', base_name)
        version_number = version_match.group(1) if version_match else 'Unknown'
        return base_name, version_number

    def process_selected_clips(self):
        seq = hiero.ui.activeSequence()
        if seq:
            te = hiero.ui.getTimelineEditor(seq)
            selected_clips = te.selection()
            if selected_clips:
                for clip in selected_clips:
                    file_path = clip.source().mediaSource().fileinfos()[0].filename()
                    exr_name = os.path.basename(file_path)
                    base_name, hiero_version_number = self.parse_exr_name(exr_name)
                    project_name = base_name.split('_')[0]
                    parts = base_name.split('_')
                    shot_code = '_'.join(parts[:5])

                    shot, tasks = self.sg_manager.find_shot_and_tasks(project_name, shot_code)
                    if shot:
                        # Imprimir la descripción del shot
                        print(f&quot;- Shot name: {shot['code']}&quot;)
                        print(f&quot;  Description: {shot.get('description', 'No description available')}&quot;)

                        # Mostrar la información de la tarea Comp antes de verificar versiones
                        comp_task = next((task for task in tasks if 'Comp' in task['content']), None)
                        if comp_task:
                            estimated_days = comp_task.get('sg_estimated_days', 0)
                            print(f&quot;- Task: {comp_task['content']} (Status: {comp_task['sg_status_list']})&quot;)
                            print(f&quot;  Description: {comp_task.get('sg_description', 'No description available')}&quot;)
                            print(f&quot;  Estimated Duration: {estimated_days} days&quot;)
                            print(f&quot;  URL: {self.sg_manager.get_task_url(comp_task['id'])}&quot;)

                        # Luego verificar si hay versiones disponibles
                        versions = self.sg_manager.find_version_by_code(shot['id'], f&quot;_v{hiero_version_number}&quot;)
                        if versions:
                            version = versions[0]  # Assuming the first match is the correct version
                            print(f&quot;- Version Hiero: v{hiero_version_number}&quot;)
                            print(f&quot;- Version SG: {version['code']}&quot;)
                            print(f&quot;- Version SG status: {version['sg_status_list']}&quot;)
                            print(f&quot;- Description: {version['description']}&quot;)

                            notes = self.sg_manager.get_version_notes(version['id'])
                            if notes:
                                print(&quot;  - Comments:&quot;)
                                for note in notes:
                                    print(f&quot;    - {note['content']} (User: {note['user']['name']})&quot;)
                            else:
                                print(&quot;  - No comments found.&quot;)
                        else:
                            print(f&quot;No versions found for Hiero version v{hiero_version_number} in ShotGrid.&quot;)
                    else:
                        print(&quot;No se encontró el shot correspondiente en ShotGrid.&quot;)
            else:
                print(&quot;No se han seleccionado clips en el timeline.&quot;)
        else:
            print(&quot;No se encontró una secuencia activa en Hiero.&quot;)

def main():
    global msg_manager
    sg_url = os.getenv('SHOTGRID_URL')
    sg_login = os.getenv('SHOTGRID_LOGIN')
    sg_password = os.getenv('SHOTGRID_PASSWORD')

    if not sg_url or not sg_login or not sg_password:
        print(&quot;Las variables de entorno SHOTGRID_URL, SHOTGRID_LOGIN y SHOTGRID_PASSWORD deben estar configuradas.&quot;)
        return

    sg_manager = ShotGridManager(sg_url, sg_login, sg_password)
    hiero_ops = HieroOperations(sg_manager)
    hiero_ops.process_selected_clips()

if __name__ == &quot;__main__&quot;:
    main()
import nuke

def print_node_inputs():
    # Obtener el nodo seleccionado
    selected_node = nuke.selectedNode()
    
    # Obtener la cantidad de inputs disponibles en el nodo
    total_inputs = selected_node.maxInputs()
    print(f&quot;El nodo '{selected_node.name()}' tiene {total_inputs} inputs disponibles.&quot;)
    
    # Iterar sobre cada input y verificar si está conectado
    for i in range(total_inputs):
        connected_node = selected_node.input(i)
        if connected_node:
            print(f&quot;Input {i+1}: conectado a '{connected_node.name()}'&quot;)
        else:
            print(f&quot;Input {i+1}: no está conectado&quot;)

# Ejecutar la función
print_node_inputs()
import nuke
undo = nuke.Undo()
undo.end()

import importlib
import Dots
importlib.reload(Dots)import os
import re
import hiero.ui
import hiero.core
import shotgun_api3

# Función para parsear el nombre del archivo y obtener base_name
def parse_exr_name(exr_name):
    # Ajustar el manejo del formato del nombre del archivo EXR
    if '%04d' in exr_name:
        exr_name = exr_name.replace('.%', '_%')  # Reemplazar patrón para análisis

    parts = exr_name.split('_')
    if len(parts) &lt; 7:
        raise ValueError(f&quot;Nombre del archivo EXR no tiene el formato esperado: {exr_name}&quot;)
    base_name = '_'.join(parts[:-1])  # Todas las partes excepto la última forman el base_name
    return base_name

# Función para extraer información del base_name
def extract_info_from_base_name(base_name):
    project_name = base_name.split('_')[0]
    parts = base_name.split('_')
    shot_code = '_'.join(parts[:5])

    version_number_str = None
    for part in parts:
        if part.startswith('v') and part[1:].isdigit():
            version_number_str = part
            break

    if version_number_str:
        version_number = int(version_number_str.replace('v', ''))
        print(f&quot;Código de shot: {shot_code}, Número de versión: {version_number}&quot;)
    else:
        print(&quot;Error: No se encontró un número de versión válido en el nombre del archivo.&quot;)
        return None

    version_index = parts.index(version_number_str)
    task_name = parts[version_index - 1].lower()

    return project_name, shot_code, task_name, version_number_str

# Clase para manejar operaciones con ShotGrid
class ShotGridManager:
    def __init__(self, url, script_name, api_key, sudo_login):
        print(&quot;Inicializando conexión a ShotGrid&quot;)
        try:
            self.sg = shotgun_api3.Shotgun(
                url,
                script_name=script_name,
                api_key=api_key,
                sudo_as_login=sudo_login
            )
            print(&quot;Conexión a ShotGrid inicializada exitosamente&quot;)
        except Exception as e:
            print(f&quot;Error al inicializar la conexión a ShotGrid: {e}&quot;)
            self.sg = None

    def find_project(self, project_name):
        if not self.sg:
            print(&quot;Conexión a ShotGrid no está inicializada&quot;)
            return None

        print(f&quot;Buscando proyecto con nombre: {project_name}&quot;)
        try:
            projects = self.sg.find(&quot;Project&quot;, [['name', 'is', project_name]], ['id', 'name'])
            if projects:
                project = projects[0]
                print(f&quot;Proyecto encontrado: {project['name']} (ID: {project['id']})&quot;)
                return project
            else:
                print(&quot;Proyecto no encontrado&quot;)
                return None
        except Exception as e:
            print(f&quot;Error al buscar el proyecto: {e}&quot;)
            return None

    def find_shot(self, project_id, shot_code):
        if not self.sg:
            print(&quot;Conexión a ShotGrid no está inicializada&quot;)
            return None

        print(f&quot;Buscando shot con código: {shot_code}&quot;)
        try:
            filters = [
                ['project', 'is', {'type': 'Project', 'id': project_id}],
                ['code', 'is', shot_code]
            ]
            fields = ['id', 'code']
            shots = self.sg.find(&quot;Shot&quot;, filters, fields)
            if shots:
                shot = shots[0]
                print(f&quot;Shot encontrado: {shot['code']} (ID: {shot['id']})&quot;)
                return shot
            else:
                print(&quot;Shot no encontrado&quot;)
                return None
        except Exception as e:
            print(f&quot;Error al buscar el shot: {e}&quot;)
            return None

    def find_task(self, shot_id, task_name):
        if not self.sg:
            print(&quot;Conexión a ShotGrid no está inicializada&quot;)
            return None

        print(f&quot;Buscando tarea con nombre: {task_name}&quot;)
        try:
            filters = [
                ['entity', 'is', {'type': 'Shot', 'id': shot_id}],
                ['content', 'is', task_name]
            ]
            fields = ['id', 'content', 'sg_status_list']
            tasks = self.sg.find(&quot;Task&quot;, filters, fields)
            if tasks:
                task = tasks[0]
                print(f&quot;Tarea encontrada: {task['content']} (ID: {task['id']})&quot;)
                return task
            else:
                print(&quot;Tarea no encontrada&quot;)
                return None
        except Exception as e:
            print(f&quot;Error al buscar la tarea: {e}&quot;)
            return None

    def find_version(self, shot_id, version_number_str):
        if not self.sg:
            print(&quot;Conexión a ShotGrid no está inicializada&quot;)
            return None

        print(f&quot;Buscando versión: {version_number_str}&quot;)
        try:
            filters = [
                ['entity', 'is', {'type': 'Shot', 'id': shot_id}],
                ['code', 'contains', version_number_str]
            ]
            fields = ['id', 'code', 'sg_status_list']
            versions = self.sg.find(&quot;Version&quot;, filters, fields)
            if versions:
                version = versions[0]
                print(f&quot;Versión encontrada: {version['code']} (ID: {version['id']})&quot;)
                return version
            else:
                print(&quot;Versión no encontrada&quot;)
                return None
        except Exception as e:
            print(f&quot;Error al buscar la versión: {e}&quot;)
            return None

# Función principal
def main():
    # Obtener la secuencia activa y el clip seleccionado
    seq = hiero.ui.activeSequence()
    if not seq:
        print(&quot;No se encontró una secuencia activa.&quot;)
        return
    te = hiero.ui.getTimelineEditor(seq)
    selected_items = te.selection()
    if not selected_items:
        print(&quot;No hay elementos seleccionados.&quot;)
        return
    # Suponiendo que tomamos el primer elemento seleccionado
    item = selected_items[0]
    if isinstance(item, hiero.core.EffectTrackItem):
        print(&quot;El elemento seleccionado es un efecto, se omite.&quot;)
        return
    # Obtener la ruta del archivo
    if item.source().mediaSource().isMediaPresent():
        fileinfos = item.source().mediaSource().fileinfos()
        if fileinfos:
            file_path = fileinfos[0].filename()
            exr_name = os.path.basename(file_path)
            print(f&quot;Nombre del archivo: {exr_name}&quot;)
        else:
            print(&quot;No hay información de archivo disponible.&quot;)
            return
    else:
        print(&quot;El medio no está presente.&quot;)
        return
    # Parsear exr_name para obtener base_name
    try:
        base_name = parse_exr_name(exr_name)
        print(f&quot;Base name: {base_name}&quot;)
    except ValueError as e:
        print(f&quot;Error: {e}&quot;)
        return
    # Extraer project_name, shot_code, task_name, version_number
    info = extract_info_from_base_name(base_name)
    if not info:
        return
    project_name, shot_code, task_name, version_number_str = info
    print(f&quot;Nombre del proyecto: {project_name}&quot;)
    print(f&quot;Código del shot: {shot_code}&quot;)
    print(f&quot;Nombre de la tarea: {task_name}&quot;)
    print(f&quot;Versión: {version_number_str}&quot;)
    # Inicializar conexión a ShotGrid
    sg_url = os.getenv('SHOTGRID_URL')
    sg_script_name = os.getenv('SHOTGRID_SCRIPT_NAME')
    sg_api_key = os.getenv('SHOTGRID_API_KEY')
    sg_login = os.getenv('SHOTGRID_LOGIN')  # Para sudo_as_login

    if not sg_url or not sg_script_name or not sg_api_key or not sg_login:
        print(&quot;Las variables de entorno SHOTGRID_URL, SHOTGRID_SCRIPT_NAME, SHOTGRID_API_KEY y SHOTGRID_LOGIN deben estar configuradas.&quot;)
        return

    sg_manager = ShotGridManager(sg_url, sg_script_name, sg_api_key, sg_login)
    # Buscar proyecto
    project = sg_manager.find_project(project_name)
    if not project:
        return
    # Buscar shot
    shot = sg_manager.find_shot(project['id'], shot_code)
    if not shot:
        return
    # Buscar tarea
    task = sg_manager.find_task(shot['id'], task_name)
    if not task:
        return
    # Buscar versión
    version = sg_manager.find_version(shot['id'], version_number_str)
    if not version:
        return
    # Imprimir información
    print(&quot;\nInformación recuperada de ShotGrid:&quot;)
    print(f&quot;Proyecto: {project['name']} (ID: {project['id']})&quot;)
    print(f&quot;Shot: {shot['code']} (ID: {shot['id']})&quot;)
    print(f&quot;Tarea: {task['content']} (ID: {task['id']}) - Estado: {task['sg_status_list']}&quot;)
    print(f&quot;Versión: {version['code']} (ID: {version['id']}) - Estado: {version['sg_status_list']}&quot;)

# Ejecutar la función principal
main()
import os
import re
import hiero.ui
import hiero.core
import shotgun_api3

# Función para parsear el nombre del archivo y obtener base_name
def parse_exr_name(exr_name):
    # Ajustar el manejo del formato del nombre del archivo EXR
    if '%04d' in exr_name:
        exr_name = exr_name.replace('.%', '_%')  # Reemplazar patrón para análisis

    parts = exr_name.split('_')
    if len(parts) &lt; 7:
        raise ValueError(f&quot;Nombre del archivo EXR no tiene el formato esperado: {exr_name}&quot;)
    base_name = '_'.join(parts[:-1])  # Todas las partes excepto la última forman el base_name
    return base_name

# Función para extraer información del base_name
def extract_info_from_base_name(base_name):
    project_name = base_name.split('_')[0]
    parts = base_name.split('_')
    shot_code = '_'.join(parts[:5])

    version_number_str = None
    for part in parts:
        if part.startswith('v') and part[1:].isdigit():
            version_number_str = part
            break

    if version_number_str:
        version_number = int(version_number_str.replace('v', ''))
        print(f&quot;Código de shot: {shot_code}, Número de versión: {version_number}&quot;)
    else:
        print(&quot;Error: No se encontró un número de versión válido en el nombre del archivo.&quot;)
        return None

    version_index = parts.index(version_number_str)
    task_name = parts[version_index - 1].lower()

    return project_name, shot_code, task_name, version_number_str

# Clase para manejar operaciones con ShotGrid
class ShotGridManager:
    def __init__(self, url, script_name, api_key, sudo_login):
        print(&quot;Inicializando conexión a ShotGrid&quot;)
        try:
            self.sg = shotgun_api3.Shotgun(
                url,
                script_name=script_name,
                api_key=api_key,
                sudo_as_login=sudo_login
            )
            print(&quot;Conexión a ShotGrid inicializada exitosamente&quot;)
        except Exception as e:
            print(f&quot;Error al inicializar la conexión a ShotGrid: {e}&quot;)
            self.sg = None

    def find_project(self, project_name):
        if not self.sg:
            print(&quot;Conexión a ShotGrid no está inicializada&quot;)
            return None

        print(f&quot;Buscando proyecto con nombre: {project_name}&quot;)
        try:
            projects = self.sg.find(&quot;Project&quot;, [['name', 'is', project_name]], ['id', 'name'])
            if projects:
                project = projects[0]
                print(f&quot;Proyecto encontrado: {project['name']} (ID: {project['id']})&quot;)
                return project
            else:
                print(&quot;Proyecto no encontrado&quot;)
                return None
        except Exception as e:
            print(f&quot;Error al buscar el proyecto: {e}&quot;)
            return None

    def find_shot(self, project_id, shot_code):
        if not self.sg:
            print(&quot;Conexión a ShotGrid no está inicializada&quot;)
            return None

        print(f&quot;Buscando shot con código: {shot_code}&quot;)
        try:
            filters = [
                ['project', 'is', {'type': 'Project', 'id': project_id}],
                ['code', 'is', shot_code]
            ]
            fields = ['id', 'code']
            shots = self.sg.find(&quot;Shot&quot;, filters, fields)
            if shots:
                shot = shots[0]
                print(f&quot;Shot encontrado: {shot['code']} (ID: {shot['id']})&quot;)
                return shot
            else:
                print(&quot;Shot no encontrado&quot;)
                return None
        except Exception as e:
            print(f&quot;Error al buscar el shot: {e}&quot;)
            return None

    def find_task(self, shot_id, task_name):
        if not self.sg:
            print(&quot;Conexión a ShotGrid no está inicializada&quot;)
            return None

        print(f&quot;Buscando tarea con nombre: {task_name}&quot;)
        try:
            filters = [
                ['entity', 'is', {'type': 'Shot', 'id': shot_id}],
                ['content', 'is', task_name]
            ]
            fields = ['id', 'content', 'sg_status_list']
            tasks = self.sg.find(&quot;Task&quot;, filters, fields)
            if tasks:
                task = tasks[0]
                print(f&quot;Tarea encontrada: {task['content']} (ID: {task['id']})&quot;)
                return task
            else:
                print(&quot;Tarea no encontrada&quot;)
                return None
        except Exception as e:
            print(f&quot;Error al buscar la tarea: {e}&quot;)
            return None

    def find_version(self, shot_id, version_number_str):
        if not self.sg:
            print(&quot;Conexión a ShotGrid no está inicializada&quot;)
            return None

        print(f&quot;Buscando versión: {version_number_str}&quot;)
        try:
            filters = [
                ['entity', 'is', {'type': 'Shot', 'id': shot_id}],
                ['code', 'contains', version_number_str]
            ]
            fields = ['id', 'code', 'sg_status_list']
            versions = self.sg.find(&quot;Version&quot;, filters, fields)
            if versions:
                version = versions[0]
                print(f&quot;Versión encontrada: {version['code']} (ID: {version['id']})&quot;)
                return version
            else:
                print(&quot;Versión no encontrada&quot;)
                return None
        except Exception as e:
            print(f&quot;Error al buscar la versión: {e}&quot;)
            return None

# Función principal
def main():
    # Obtener la secuencia activa y el clip seleccionado
    seq = hiero.ui.activeSequence()
    if not seq:
        print(&quot;No se encontró una secuencia activa.&quot;)
        return
    te = hiero.ui.getTimelineEditor(seq)
    selected_items = te.selection()
    if not selected_items:
        print(&quot;No hay elementos seleccionados.&quot;)
        return
    # Suponiendo que tomamos el primer elemento seleccionado
    item = selected_items[0]
    if isinstance(item, hiero.core.EffectTrackItem):
        print(&quot;El elemento seleccionado es un efecto, se omite.&quot;)
        return
    # Obtener la ruta del archivo
    if item.source().mediaSource().isMediaPresent():
        fileinfos = item.source().mediaSource().fileinfos()
        if fileinfos:
            file_path = fileinfos[0].filename()
            exr_name = os.path.basename(file_path)
            print(f&quot;Nombre del archivo: {exr_name}&quot;)
        else:
            print(&quot;No hay información de archivo disponible.&quot;)
            return
    else:
        print(&quot;El medio no está presente.&quot;)
        return
    # Parsear exr_name para obtener base_name
    try:
        base_name = parse_exr_name(exr_name)
        print(f&quot;Base name: {base_name}&quot;)
    except ValueError as e:
        print(f&quot;Error: {e}&quot;)
        return
    # Extraer project_name, shot_code, task_name, version_number
    info = extract_info_from_base_name(base_name)
    if not info:
        return
    project_name, shot_code, task_name, version_number_str = info
    print(f&quot;Nombre del proyecto: {project_name}&quot;)
    print(f&quot;Código del shot: {shot_code}&quot;)
    print(f&quot;Nombre de la tarea: {task_name}&quot;)
    print(f&quot;Versión: {version_number_str}&quot;)
    # Inicializar conexión a ShotGrid
    sg_url = os.getenv('SHOTGRID_URL')
    sg_script_name = os.getenv('SHOTGRID_SCRIPT_NAME')
    sg_api_key = os.getenv('SHOTGRID_API_KEY')
    sg_login = os.getenv('SHOTGRID_LOGIN')  # Para sudo_as_login

    if not sg_url or not sg_script_name or not sg_api_key or not sg_login:
        print(&quot;Las variables de entorno SHOTGRID_URL, SHOTGRID_SCRIPT_NAME, SHOTGRID_API_KEY y SHOTGRID_LOGIN deben estar configuradas.&quot;)
        return

    sg_manager = ShotGridManager(sg_url, sg_script_name, sg_api_key, sg_login)
    # Buscar proyecto
    project = sg_manager.find_project(project_name)
    if not project:
        return
    # Buscar shot
    shot = sg_manager.find_shot(project['id'], shot_code)
    if not shot:
        return
    # Buscar tarea
    task = sg_manager.find_task(shot['id'], task_name)
    if not task:
        return
    # Buscar versión
    version = sg_manager.find_version(shot['id'], version_number_str)
    if not version:
        return
    # Imprimir información
    print(&quot;\nInformación recuperada de ShotGrid:&quot;)
    print(f&quot;Proyecto: {project['name']} (ID: {project['id']})&quot;)
    print(f&quot;Shot: {shot['code']} (ID: {shot['id']})&quot;)
    print(f&quot;Tarea: {task['content']} (ID: {task['id']}) - Estado: {task['sg_status_list']}&quot;)
    print(f&quot;Versión: {version['code']} (ID: {version['id']}) - Estado: {version['sg_status_list']}&quot;)

# Ejecutar la función principal
main()
&quot;&quot;&quot;
_______________________________

  LGA_preRender | 2024 | Lega  
_______________________________

&quot;&quot;&quot;

import nuke
import sys
import os

# Agrega la ruta del directorio donde se encuentra este script al sys.path
script_dir = os.path.dirname(__file__)
sys.path.append(script_dir)

# Importa el módulo LGA_oz_backdropReplacer
try:
    import LGA_oz_backdropReplacer
except ImportError:
    nuke.message(&quot;No se pudo encontrar el módulo LGA_oz_backdropReplacer.&quot;)
    nuke.Undo().end()
    sys.exit()

def align_write_to_dot(dot_node, write_node):
    dot_center_y = dot_node.ypos() + dot_node.screenHeight() / 2
    write_center_y = write_node.ypos() + write_node.screenHeight() / 2
    y_offset = dot_center_y - write_center_y
    if y_offset != 0:
        write_node.setYpos(int(write_node.ypos() + y_offset))
    print(f&quot;Posición Y final centrada del nodo {dot_node.name()}: {dot_center_y}&quot;)
    print(f&quot;Posición Y final centrada del nodo {write_node.name()}: {write_center_y}&quot;)

def main():
    # Iniciar el grupo de deshacer
    nuke.Undo().begin(&quot;LGA_preRender&quot;)

    try:
        selected_node = nuke.selectedNode()
    except ValueError:
        nuke.message(&quot;Por favor, selecciona un nodo antes de ejecutar el script.&quot;)
        nuke.Undo().end()
        return

    # Variables para posicionamiento
    dot_width = int(nuke.toNode(&quot;preferences&quot;)['dot_node_scale'].value() * 12)
    distanciaX = 180  # Distancia horizontal para el nodo Write
    distanciaY = 80   # Distancia vertical entre nodos

    # Crear un Dot debajo del nodo seleccionado
    dot_node = nuke.nodes.Dot()
    dot_node.setInput(0, selected_node)
    dot_node.setXpos(int(selected_node.xpos() + (selected_node.screenWidth() / 2) - (dot_width / 2)))
    dot_node.setYpos(selected_node.ypos() + selected_node.screenHeight() + distanciaY * 2)

    # Crear un Switch debajo del Dot con 'which' en 1 y deshabilitado
    switch_node = nuke.nodes.Switch()
    switch_node.setInput(0, dot_node)  # Input 0 conectado al Dot
    switch_node.setInput(1, None)      # Input 1 sin conectar
    switch_node['which'].setValue(1)   # Selecciona Input 1 (sin conectar)
    switch_node['disable'].setValue(True)
    switch_node.setXpos(dot_node.xpos() - (switch_node.screenWidth() // 2) + (dot_width // 2))
    switch_node.setYpos(dot_node.ypos() + distanciaY)

    # Crear un Write alineado verticalmente con el Dot
    write_node = nuke.nodes.Write()
    write_node.setInput(0, dot_node)
    write_node.setXpos(int(dot_node.xpos() + (dot_width / 2) - (write_node.screenWidth() // 2) - distanciaX))
    write_node.setYpos(dot_node.ypos())  # Posición inicial en Y

    # Configurar los ajustes del nodo Write
    write_node['channels'].setValue('rgba')
    write_node['file'].setValue(&quot;[file dirname [value root.name]]/../2_prerenders/[join [lrange [split [file tail [file rootname [value root.name]]] _ ] 0 4] _]Pre_v01/[join [lrange [split [file tail [file rootname [value root.name]]] _ ] 0 4] _]_Pre_v01_%04d.exr&quot;)
    write_node['file_type'].setValue('exr')
    write_node['compression'].setValue('DWAA')
    write_node['dw_compression_level'].setValue(60)
    write_node['first_part'].setValue('rgba')
    write_node['create_directories'].setValue(True)
    write_node['checkHashOnRead'].setValue(False)
    write_node['version'].setValue(4)
    write_node['colorspace'].setValue('ACES - ACES2065-1')
    write_node['name'].setValue('Write_PreRender')

    # Añadir knobs personalizados
    write_node.addKnob(nuke.Tab_Knob('User', 'User'))
    write_node.addKnob(nuke.String_Knob('render_time', 'Render Time'))
    write_node['render_time'].setValue(&quot;00:18:27&quot;)

    # Seleccionar los nodos creados
    for node in [write_node, dot_node, switch_node]:
        node['selected'].setValue(True)

    # Reconectar nodos descendentes al Switch
    downstream_nodes = selected_node.dependent(nuke.INPUTS | nuke.HIDDEN_INPUTS, forceEvaluate=False)
    for node in downstream_nodes:
        for i in range(node.inputs()):
            if node.input(i) == selected_node:
                node.setInput(i, switch_node)

    # Crear el BackdropNode detrás de los tres nodos
    nodes = [write_node, dot_node, switch_node]
    bd_x = min(node.xpos() for node in nodes) - 50
    bd_y = min(node.ypos() for node in nodes) - 100
    bd_w = max(node.xpos() + node.screenWidth() for node in nodes) - bd_x + 50
    bd_h = max(node.ypos() + node.screenHeight() for node in nodes) - bd_y + 100

    backdrop_node = nuke.nodes.BackdropNode(
        xpos = bd_x,
        ypos = bd_y,
        bdwidth = bd_w,
        bdheight = bd_h,
        tile_color = 0x4f7f5601,
        note_font = &quot;Verdana Bold&quot;,
        note_font_size = 50,
        label = &quot;preRender&quot;,
        z_order = 4,
        name = &quot;Backdrop_preRender&quot;
    )
    backdrop_node['selected'].setValue(True)  # Seleccionar el backdrop

    # Función para alinear el Write con el Dot
    def do_align():
        align_write_to_dot(dot_node, write_node)

    # Ejecutar la alineación en el hilo principal de Nuke
    nuke.executeInMainThread(do_align)

    # Llamar a la función replace_with_oz_backdrop del módulo importado
    LGA_oz_backdropReplacer.replace_with_oz_backdrop()

    # Finalizar el grupo de deshacer
    nuke.Undo().end()

# Ejecutar la función principal
main()
&quot;&quot;&quot;
_______________________________

  LGA_preRender | 2024 | Lega  
_______________________________

&quot;&quot;&quot;

import nuke
import sys
import os

# Agrega la ruta del directorio donde se encuentra este script al sys.path
script_dir = os.path.dirname(__file__)
sys.path.append(script_dir)

# Intentar importar el módulo LGA_oz_backdropReplacer
try:
    import LGA_oz_backdropReplacer
    oz_backdrop_available = True
except ImportError:
    oz_backdrop_available = False
    nuke.tprint(&quot;El módulo LGA_oz_backdropReplacer no está disponible. Continuando sin reemplazar el backdrop.&quot;)

def align_write_to_dot(dot_node, write_node):
    dot_center_y = dot_node.ypos() + dot_node.screenHeight() / 2
    write_center_y = write_node.ypos() + write_node.screenHeight() / 2
    y_offset = dot_center_y - write_center_y
    if y_offset != 0:
        write_node.setYpos(int(write_node.ypos() + y_offset))
    print(f&quot;Posición Y final centrada del nodo {dot_node.name()}: {dot_center_y}&quot;)
    print(f&quot;Posición Y final centrada del nodo {write_node.name()}: {write_center_y}&quot;)

def main():
    # Iniciar el grupo de deshacer
    nuke.Undo().begin(&quot;LGA_preRender&quot;)

    # Verificar si hay un nodo seleccionado
    try:
        selected_node = nuke.selectedNode()
        node_was_selected = True
    except ValueError:
        # Si no hay ningún nodo seleccionado, crear un NoOp y seleccionarlo
        selected_node = nuke.nodes.NoOp(name=&quot;tempNoOp&quot;)
        selected_node['selected'].setValue(True)
        node_was_selected = False

    # Variables para posicionamiento
    dot_width = int(nuke.toNode(&quot;preferences&quot;)['dot_node_scale'].value() * 12)
    distanciaX = 180  # Distancia horizontal para el nodo Write
    distanciaY = 80   # Distancia vertical entre nodos

    # Crear un Dot debajo del nodo seleccionado
    dot_node = nuke.nodes.Dot()
    dot_node.setInput(0, selected_node)
    dot_node.setXpos(int(selected_node.xpos() + (selected_node.screenWidth() / 2) - (dot_width / 2)))
    dot_node.setYpos(selected_node.ypos() + selected_node.screenHeight() + distanciaY * 2)

    # Si se creó un NoOp temporal, eliminarlo después de crear el Dot
    if not node_was_selected:
        nuke.delete(selected_node)

    # Crear un Switch debajo del Dot con 'which' en 1 y deshabilitado
    switch_node = nuke.nodes.Switch()
    switch_node.setInput(0, dot_node)  # Input 0 conectado al Dot
    switch_node.setInput(1, None)      # Input 1 sin conectar
    switch_node['which'].setValue(1)   # Selecciona Input 1 (sin conectar)
    switch_node['disable'].setValue(True)
    switch_node.setXpos(dot_node.xpos() - (switch_node.screenWidth() // 2) + (dot_width // 2))
    switch_node.setYpos(dot_node.ypos() + distanciaY)

    # Crear un Write alineado verticalmente con el Dot
    write_node = nuke.nodes.Write()
    write_node.setInput(0, dot_node)
    write_node.setXpos(int(dot_node.xpos() + (dot_width / 2) - (write_node.screenWidth() // 2) - distanciaX))
    write_node.setYpos(dot_node.ypos())  # Posición inicial en Y

    # Configurar los ajustes del nodo Write
    write_node['channels'].setValue('rgba')
    write_node['file'].setValue(&quot;[file dirname [value root.name]]/../2_prerenders/[join [lrange [split [file tail [file rootname [value root.name]]] _ ] 0 4] _]Pre_v01/[join [lrange [split [file tail [file rootname [value root.name]]] _ ] 0 4] _]_Pre_v01_%04d.exr&quot;)
    write_node['file_type'].setValue('exr')
    write_node['compression'].setValue('DWAA')
    write_node['dw_compression_level'].setValue(60)
    write_node['first_part'].setValue('rgba')
    write_node['create_directories'].setValue(True)
    write_node['checkHashOnRead'].setValue(False)
    write_node['version'].setValue(4)
    write_node['colorspace'].setValue('ACES - ACES2065-1')
    write_node['name'].setValue('Write_PreRender')

    # Añadir knobs personalizados
    write_node.addKnob(nuke.Tab_Knob('User', 'User'))
    write_node.addKnob(nuke.String_Knob('render_time', 'Render Time'))
    write_node['render_time'].setValue(&quot;00:18:27&quot;)

    # Seleccionar los nodos creados
    for node in [write_node, dot_node, switch_node]:
        node['selected'].setValue(True)

    # Reconectar nodos descendentes al Switch
    if node_was_selected:
        downstream_nodes = selected_node.dependent(nuke.INPUTS | nuke.HIDDEN_INPUTS, forceEvaluate=False)
        for node in downstream_nodes:
            for i in range(node.inputs()):
                if node.input(i) == selected_node:
                    node.setInput(i, switch_node)

    # Crear el BackdropNode detrás de los tres nodos
    nodes = [write_node, dot_node, switch_node]

    # Ajustes de márgenes según tus especificaciones
    margen_izquierdo = 64  # Antes era 50
    margen_superior = 115  # Antes era 100
    margen_derecho = 77    # Antes era 50
    margen_inferior = 65   # Antes era 100

    bd_x = min(node.xpos() for node in nodes) - margen_izquierdo
    bd_y = min(node.ypos() for node in nodes) - margen_superior
    bd_w = max(node.xpos() + node.screenWidth() for node in nodes) - bd_x + margen_derecho
    bd_h = max(node.ypos() + node.screenHeight() for node in nodes) - bd_y + margen_inferior

    backdrop_node = nuke.nodes.BackdropNode(
        xpos = bd_x,
        ypos = bd_y,
        bdwidth = bd_w,
        bdheight = bd_h,
        tile_color = 0x4f7f5601,
        note_font = &quot;Verdana Bold&quot;,
        note_font_size = 50,
        label = &quot;preRender&quot;,
        z_order = 4,
        name = &quot;Backdrop_preRender&quot;
    )
    backdrop_node['selected'].setValue(True)  # Seleccionar el backdrop

    # Función para alinear el Write con el Dot
    def do_align():
        align_write_to_dot(dot_node, write_node)

    # Ejecutar la alineación en el hilo principal de Nuke
    nuke.executeInMainThread(do_align)

    # Si el módulo LGA_oz_backdropReplacer está disponible, llamar a la función replace_with_oz_backdrop
    if oz_backdrop_available:
        LGA_oz_backdropReplacer.replace_with_oz_backdrop()
    else:
        nuke.tprint(&quot;No se reemplazó el backdrop porque LGA_oz_backdropReplacer no está disponible.&quot;)

    # Deseleccionar el backdrop
    backdrop_node['selected'].setValue(False)

    # Finalizar el grupo de deshacer
    nuke.Undo().end()

# Ejecutar la función principal
main()
&quot;&quot;&quot;
____________________________________

  LGA_preRender v1.0 | 2024 | Lega  
____________________________________

&quot;&quot;&quot;

import nuke
import sys
import os

# Agrega la ruta del directorio donde se encuentra este script al sys.path
script_dir = os.path.dirname(__file__)
sys.path.append(script_dir)

# Intentar importar el módulo LGA_oz_backdropReplacer
try:
    import LGA_oz_backdropReplacer
    oz_backdrop_available = True
except ImportError:
    oz_backdrop_available = False
    nuke.tprint(&quot;El módulo LGA_oz_backdropReplacer no está disponible. Continuando sin reemplazar el backdrop.&quot;)

def align_write_to_dot(dot_node, write_node):
    dot_center_y = dot_node.ypos() + dot_node.screenHeight() / 2
    write_center_y = write_node.ypos() + write_node.screenHeight() / 2
    y_offset = dot_center_y - write_center_y
    if y_offset != 0:
        write_node.setYpos(int(write_node.ypos() + y_offset))
    print(f&quot;Posición Y final centrada del nodo {dot_node.name()}: {dot_center_y}&quot;)
    print(f&quot;Posición Y final centrada del nodo {write_node.name()}: {write_center_y}&quot;)

def main():
    # Iniciar el grupo de deshacer
    nuke.Undo().begin(&quot;LGA_preRender&quot;)

    # Verificar si hay un nodo seleccionado
    try:
        selected_node = nuke.selectedNode()
        node_was_selected = True
    except ValueError:
        # Si no hay ningún nodo seleccionado, crear un NoOp y seleccionarlo
        selected_node = nuke.nodes.NoOp(name=&quot;tempNoOp&quot;)
        selected_node['selected'].setValue(True)
        node_was_selected = False

    # Variables para posicionamiento
    dot_width = int(nuke.toNode(&quot;preferences&quot;)['dot_node_scale'].value() * 12)
    distanciaX = 180  # Distancia horizontal para el nodo Write
    distanciaY = 80   # Distancia vertical entre nodos

    # Crear un Dot debajo del nodo seleccionado
    dot_node = nuke.nodes.Dot()
    dot_node.setInput(0, selected_node)
    dot_node.setXpos(int(selected_node.xpos() + (selected_node.screenWidth() / 2) - (dot_width / 2)))
    dot_node.setYpos(selected_node.ypos() + selected_node.screenHeight() + distanciaY * 2)

    # Si se creó un NoOp temporal, eliminarlo después de crear el Dot
    if not node_was_selected:
        nuke.delete(selected_node)

    # Crear un Switch debajo del Dot con 'which' en 1 y deshabilitado
    switch_node = nuke.nodes.Switch()
    switch_node.setInput(0, dot_node)  # Input 0 conectado al Dot
    switch_node.setInput(1, None)      # Input 1 sin conectar
    switch_node['which'].setValue(1)   # Selecciona Input 1 (sin conectar)
    switch_node['disable'].setValue(True)
    switch_node.setXpos(dot_node.xpos() - (switch_node.screenWidth() // 2) + (dot_width // 2))
    switch_node.setYpos(dot_node.ypos() + distanciaY)

    # Crear un Write alineado verticalmente con el Dot
    write_node = nuke.nodes.Write()
    write_node.setInput(0, dot_node)
    write_node.setXpos(int(dot_node.xpos() + (dot_width / 2) - (write_node.screenWidth() // 2) - distanciaX))
    write_node.setYpos(dot_node.ypos())  # Posición inicial en Y

    # Configurar los ajustes del nodo Write
    write_node['channels'].setValue('rgba')
    write_node['file'].setValue(&quot;[file dirname [value root.name]]/../2_prerenders/[join [lrange [split [file tail [file rootname [value root.name]]] _ ] 0 4] _]Pre_v01/[join [lrange [split [file tail [file rootname [value root.name]]] _ ] 0 4] _]_Pre_v01_%04d.exr&quot;)
    write_node['file_type'].setValue('exr')
    write_node['compression'].setValue('DWAA')
    write_node['dw_compression_level'].setValue(60)
    write_node['first_part'].setValue('rgba')
    write_node['create_directories'].setValue(True)
    write_node['checkHashOnRead'].setValue(False)
    write_node['version'].setValue(4)
    write_node['colorspace'].setValue('ACES - ACES2065-1')
    write_node['name'].setValue('Write_PreRender')

    # Añadir knobs personalizados
    write_node.addKnob(nuke.Tab_Knob('User', 'User'))
    write_node.addKnob(nuke.String_Knob('render_time', 'Render Time'))
    write_node['render_time'].setValue(&quot;00:18:27&quot;)

    # Seleccionar los nodos creados
    for node in [write_node, dot_node, switch_node]:
        node['selected'].setValue(True)

    # Reconectar nodos descendentes al Switch
    if node_was_selected:
        downstream_nodes = selected_node.dependent(nuke.INPUTS | nuke.HIDDEN_INPUTS, forceEvaluate=False)
        for node in downstream_nodes:
            for i in range(node.inputs()):
                if node.input(i) == selected_node:
                    node.setInput(i, switch_node)

    # Crear el BackdropNode detrás de los tres nodos
    nodes = [write_node, dot_node, switch_node]
    bd_x = min(node.xpos() for node in nodes) - 50
    bd_y = min(node.ypos() for node in nodes) - 100
    bd_w = max(node.xpos() + node.screenWidth() for node in nodes) - bd_x + 50
    bd_h = max(node.ypos() + node.screenHeight() for node in nodes) - bd_y + 100

    backdrop_node = nuke.nodes.BackdropNode(
        xpos = bd_x,
        ypos = bd_y,
        bdwidth = bd_w,
        bdheight = bd_h,
        tile_color = 0x4f7f5601,
        note_font = &quot;Verdana Bold&quot;,
        note_font_size = 50,
        label = &quot;preRender&quot;,
        z_order = 4,
        name = &quot;Backdrop_preRender&quot;
    )
    backdrop_node['selected'].setValue(True)  # Seleccionar el backdrop

    # Función para alinear el Write con el Dot
    def do_align():
        align_write_to_dot(dot_node, write_node)

    # Ejecutar la alineación en el hilo principal de Nuke
    nuke.executeInMainThread(do_align)

    nuke.Undo().end()
    
    # Si el módulo LGA_oz_backdropReplacer está disponible, llamar a la función replace_with_oz_backdrop
    if oz_backdrop_available:
        LGA_oz_backdropReplacer.replace_with_oz_backdrop()
    else:
        nuke.tprint(&quot;No se reemplazó el backdrop porque LGA_oz_backdropReplacer no está disponible.&quot;)

    # Deseleccionar el backdrop
    backdrop_node['selected'].setValue(False)

    # Finalizar el grupo de deshacer


# Ejecutar la función principal
main()
&quot;&quot;&quot;
____________________________________

  LGA_preRender v1.0 | 2024 | Lega  
____________________________________

&quot;&quot;&quot;

import nuke
import sys
import os

# Agrega la ruta del directorio donde se encuentra este script al sys.path
script_dir = os.path.dirname(__file__)
sys.path.append(script_dir)

# Intentar importar el módulo LGA_oz_backdropReplacer
try:
    import LGA_oz_backdropReplacer
    oz_backdrop_available = True
except ImportError:
    oz_backdrop_available = False
    nuke.tprint(&quot;El módulo LGA_oz_backdropReplacer no está disponible. Continuando sin reemplazar el backdrop.&quot;)

def align_write_to_dot(dot_node, write_node):
    dot_center_y = dot_node.ypos() + dot_node.screenHeight() / 2
    write_center_y = write_node.ypos() + write_node.screenHeight() / 2
    y_offset = dot_center_y - write_center_y
    if y_offset != 0:
        write_node.setYpos(int(write_node.ypos() + y_offset))
    print(f&quot;Posición Y final centrada del nodo {dot_node.name()}: {dot_center_y}&quot;)
    print(f&quot;Posición Y final centrada del nodo {write_node.name()}: {write_center_y}&quot;)

def main():
    # Iniciar el grupo de deshacer
    nuke.Undo().begin(&quot;LGA_preRender&quot;)

    # Verificar si hay un nodo seleccionado
    try:
        selected_node = nuke.selectedNode()
        node_was_selected = True
    except ValueError:
        # Si no hay ningún nodo seleccionado, crear un NoOp y seleccionarlo
        selected_node = nuke.nodes.NoOp(name=&quot;tempNoOp&quot;)
        selected_node['selected'].setValue(True)
        node_was_selected = False

    # Variables para posicionamiento
    dot_width = int(nuke.toNode(&quot;preferences&quot;)['dot_node_scale'].value() * 12)
    distanciaX = 180  # Distancia horizontal para el nodo Write
    distanciaY = 80   # Distancia vertical entre nodos

    # Crear un Dot debajo del nodo seleccionado
    dot_node = nuke.nodes.Dot()
    dot_node.setInput(0, selected_node)
    dot_node.setXpos(int(selected_node.xpos() + (selected_node.screenWidth() / 2) - (dot_width / 2)))
    dot_node.setYpos(selected_node.ypos() + selected_node.screenHeight() + distanciaY * 2)

    # Si se creó un NoOp temporal, eliminarlo después de crear el Dot
    if not node_was_selected:
        nuke.delete(selected_node)

    # Crear un Switch debajo del Dot con 'which' en 1 y deshabilitado
    switch_node = nuke.nodes.Switch()
    switch_node.setInput(0, dot_node)  # Input 0 conectado al Dot
    switch_node.setInput(1, None)      # Input 1 sin conectar
    switch_node['which'].setValue(1)   # Selecciona Input 1 (sin conectar)
    switch_node['disable'].setValue(True)
    switch_node.setXpos(dot_node.xpos() - (switch_node.screenWidth() // 2) + (dot_width // 2))
    switch_node.setYpos(dot_node.ypos() + distanciaY)

    # Crear un Write alineado verticalmente con el Dot
    write_node = nuke.nodes.Write()
    write_node.setInput(0, dot_node)
    write_node.setXpos(int(dot_node.xpos() + (dot_width / 2) - (write_node.screenWidth() // 2) - distanciaX))
    write_node.setYpos(dot_node.ypos())  # Posición inicial en Y

    # Configurar los ajustes del nodo Write
    write_node['channels'].setValue('rgba')
    write_node['file'].setValue(&quot;[file dirname [value root.name]]/../2_prerenders/[join [lrange [split [file tail [file rootname [value root.name]]] _ ] 0 4] _]Pre_v01/[join [lrange [split [file tail [file rootname [value root.name]]] _ ] 0 4] _]_Pre_v01_%04d.exr&quot;)
    write_node['file_type'].setValue('exr')
    write_node['compression'].setValue('DWAA')
    write_node['dw_compression_level'].setValue(60)
    write_node['first_part'].setValue('rgba')
    write_node['create_directories'].setValue(True)
    write_node['checkHashOnRead'].setValue(False)
    write_node['version'].setValue(4)
    write_node['colorspace'].setValue('ACES - ACES2065-1')
    write_node['name'].setValue('Write_PreRender')

    # Añadir knobs personalizados
    write_node.addKnob(nuke.Tab_Knob('User', 'User'))
    write_node.addKnob(nuke.String_Knob('render_time', 'Render Time'))
    write_node['render_time'].setValue(&quot;00:18:27&quot;)

    # Seleccionar los nodos creados
    for node in [write_node, dot_node, switch_node]:
        node['selected'].setValue(True)

    # Reconectar nodos descendentes al Switch
    if node_was_selected:
        downstream_nodes = selected_node.dependent(nuke.INPUTS | nuke.HIDDEN_INPUTS, forceEvaluate=False)
        for node in downstream_nodes:
            for i in range(node.inputs()):
                if node.input(i) == selected_node:
                    node.setInput(i, switch_node)

    # Crear el BackdropNode detrás de los tres nodos
    nodes = [write_node, dot_node, switch_node]
    bd_x = min(node.xpos() for node in nodes) - 50
    bd_y = min(node.ypos() for node in nodes) - 100
    bd_w = max(node.xpos() + node.screenWidth() for node in nodes) - bd_x + 50
    bd_h = max(node.ypos() + node.screenHeight() for node in nodes) - bd_y + 100

    backdrop_node = nuke.nodes.BackdropNode(
        xpos = bd_x,
        ypos = bd_y,
        bdwidth = bd_w,
        bdheight = bd_h,
        tile_color = 0x4f7f5601,
        note_font = &quot;Verdana Bold&quot;,
        note_font_size = 50,
        label = &quot;preRender&quot;,
        z_order = 4,
        name = &quot;Backdrop_preRender&quot;
    )
    backdrop_node['selected'].setValue(True)  # Seleccionar el backdrop

    # Función para alinear el Write con el Dot
    def do_align():
        align_write_to_dot(dot_node, write_node)

    # Ejecutar la alineación en el hilo principal de Nuke
    nuke.executeInMainThread(do_align)

    nuke.Undo().end()
    
    # Si el módulo LGA_oz_backdropReplacer está disponible, llamar a la función replace_with_oz_backdrop
    if oz_backdrop_available:
        LGA_oz_backdropReplacer.replace_with_oz_backdrop()
    else:
        nuke.tprint(&quot;No se reemplazó el backdrop porque LGA_oz_backdropReplacer no está disponible.&quot;)

    # Deseleccionar el backdrop
    backdrop_node['selected'].setValue(False)

    # Finalizar el grupo de deshacer


# Ejecutar la función principal
main()
import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_preRender
importlib.reload(LGA_preRender)import hiero.ui
from PySide2.QtWidgets import QApplication

def print_current_project_selection():
    &quot;&quot;&quot;
    Prints the current selection in the Project window.
    &quot;&quot;&quot;
    # Process events to ensure the UI is up to date
    QApplication.processEvents()

    # Get the project window
    project_window = None
    for window in hiero.ui.windowManager().windows():
        if window.windowTitle() == &quot;Project&quot;:
            project_window = window
            break
    
    if not project_window:
        print(&quot;No se pudo encontrar la ventana 'Project'.&quot;)
        return

    # Activate the project window
    project_window.raise_()
    project_window.activateWindow()
    project_window.setFocus()

    # Give time for the interface to update
    QApplication.processEvents()

    # Get the current active view (which should be the Project Bin view)
    active_view = hiero.ui.activeView()

    if active_view and hasattr(active_view, 'selection'):
        current_selection = active_view.selection()

        if current_selection:
            print(&quot;Current selection in the Project window:&quot;)
            for item in current_selection:
                print(f&quot;- {item.name()} ({type(item).__name__})&quot;)
        else:
            print(&quot;No items are currently selected in the Project window.&quot;)
    else:
        print(&quot;Could not retrieve the current selection or there is no active view.&quot;)

# Call the function to print the current selection in the Project window
print_current_project_selection()
import hiero.ui

# Obtén el viewer actual
viewer = hiero.ui.currentViewer()

# Verifica si el viewer fue encontrado
if viewer is not None:
    # Aplica un estilo de máscara de superposición
    try:
        # Establece el estilo de superposición a 'eMaskOverlayFull'
        viewer.setMaskOverlayStyle(hiero.ui.Player.MaskOverlayStyle.eMaskOverlayFull)
        print(&quot;El estilo de máscara de superposición se ha aplicado correctamente.&quot;)
    except AttributeError as e:
        print(f&quot;Error: {e}&quot;)
else:
    print(&quot;No se pudo obtener el viewer actual.&quot;)
import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_merge
importlib.reload(LGA_merge)&quot;&quot;&quot;
___________________________________________________________________________________________________

  LGA_CDL_CC_IP v1.0 | 2024 | Lega  

  Herramienta para exportar los valores CDL desde un nodo Read o OCIOCDLTransform y convertirlos 
  en un archivo .cc que se guarda en el mismo directorio que el archivo CDL original.

  Crea dos nodos OCIOFileTransform:
  uno para el renderizado de MOV y otro configurado como el Input Process activo.
___________________________________________________________________________________________________

&quot;&quot;&quot;


import nuke
import os

# Variable global para activar o desactivar los prints
DEBUG = False

def debug_print(*message):
    if DEBUG:
        print(*message)

def export_cc_and_create_node():
    # Obtener el nodo seleccionado
    selected_node = nuke.selectedNode()
    
    # Verificar si hay un nodo seleccionado y si es un OCIOCDLTransform o un Read
    if selected_node and selected_node.Class() in [&quot;OCIOCDLTransform&quot;, &quot;Read&quot;]:
        # Obtener el valor del knob 'file'
        if selected_node.Class() == &quot;OCIOCDLTransform&quot;:
            file_path = selected_node['file'].value()
        else:  # Read node
            file_path = selected_node['file'].value()
            cdl_path = os.path.splitext(file_path)[0] + '.cdl'
            if not os.path.exists(cdl_path):
                print(f&quot;Error: No se encontró un archivo .cdl correspondiente para {file_path}&quot;)
                return
            file_path = cdl_path
        
        # Crear el nuevo nombre de archivo con extensión .cc
        new_file_path = os.path.splitext(file_path)[0] + '.cc'
        
        # Crear el contenido del archivo .cc
        if selected_node.Class() == &quot;OCIOCDLTransform&quot;:
            slope = selected_node['slope'].value()
            offset = selected_node['offset'].value()
            power = selected_node['power'].value()
            saturation = selected_node['saturation'].value()
        else:  # Read node
            # Leer los valores del archivo .cdl
            slope, offset, power, saturation = read_cdl_values(cdl_path)
        
        cc_content = f&quot;&quot;&quot;&lt;ColorCorrection id=&quot;{os.path.basename(new_file_path)}&quot;&gt;
    &lt;SOPNode&gt;
        &lt;Slope&gt;{slope[0]} {slope[1]} {slope[2]}&lt;/Slope&gt;
        &lt;Offset&gt;{offset[0]} {offset[1]} {offset[2]}&lt;/Offset&gt;
        &lt;Power&gt;{power[0]} {power[1]} {power[2]}&lt;/Power&gt;
    &lt;/SOPNode&gt;
    &lt;SatNode&gt;
        &lt;Saturation&gt;{saturation}&lt;/Saturation&gt;
    &lt;/SatNode&gt;
&lt;/ColorCorrection&gt;
&quot;&quot;&quot;
        
        # Escribir el archivo .cc
        try:
            with open(new_file_path, 'w') as f:
                f.write(cc_content)
            debug_print(f&quot;Archivo CC exportado exitosamente: {new_file_path}&quot;)
            
            # Deseleccionar todos los nodos
            for n in nuke.allNodes():
                n['selected'].setValue(False)
            
            # Crear el nodo OCIOFileTransform desconectado
            ocio_file_transform = nuke.nodes.OCIOFileTransform()
            
            # Configurar el nodo OCIOFileTransform
            ocio_file_transform['file'].setValue(new_file_path)
            ocio_file_transform['working_space'].setValue(&quot;ACES - ACEScct&quot;)
            ocio_file_transform['label'].setValue(&quot;Input Process&quot;)
            
            # Posicionar el nuevo nodo (desconectado)
            ocio_file_transform.setXYpos(selected_node.xpos(), selected_node.ypos() + 140)
            
            # Seleccionar solo el nuevo OCIOFileTransform
            ocio_file_transform['selected'].setValue(True)
            
            # Imprimir confirmación de que el nodo ha sido creado correctamente
            debug_print(&quot;Nodo OCIOFileTransform creado y configurado.&quot;)
            
            # Obtener el nodo seleccionado (que es el OCIOFileTransform)
            selected_node = nuke.selectedNode()
            
            # Deseleccionar todos los nodos antes de crear el duplicado
            for n in nuke.allNodes():
                n['selected'].setValue(False)
            
            # Duplicar el nodo seleccionado manualmente creando uno nuevo con las mismas propiedades
            ocio_file_transform_duplicate = nuke.createNode(&quot;OCIOFileTransform&quot;)
            
            # Copiar las configuraciones del nodo original
            ocio_file_transform_duplicate['file'].setValue(selected_node['file'].value())
            ocio_file_transform_duplicate['working_space'].setValue(selected_node['working_space'].value())
            ocio_file_transform_duplicate['label'].setValue(&quot;Write MOV&quot;)
            
            # Posicionar el nodo duplicado debajo del original
            ocio_file_transform_duplicate.setXYpos(selected_node.xpos(), selected_node.ypos() + 80)
            
            debug_print(&quot;Nodo duplicado con etiqueta 'Write MOV' creado.&quot;)
            
        except Exception as e:
            print(f&quot;Error: {str(e)}&quot;)

    else:
        print(&quot;No se ha seleccionado un nodo OCIOCDLTransform o Read válido.&quot;)

import nuke

def read_cdl_values(cdl_path):
    # Inicialización de variables como None para verificar si se encontraron en el archivo
    slope = None
    offset = None
    power = None
    saturation = None
    
    # Abre el archivo CDL en modo lectura
    with open(cdl_path, 'r') as f:
        # Itera sobre cada línea del archivo
        for line in f:
            # Busca y extrae los valores de Slope (pendiente)
            if '&lt;Slope&gt;' in line:
                slope = [float(x) for x in line.split('&gt;')[1].split('&lt;')[0].split()]
            
            # Busca y extrae los valores de Offset (desplazamiento)
            elif '&lt;Offset&gt;' in line:
                offset = [float(x) for x in line.split('&gt;')[1].split('&lt;')[0].split()]
            
            # Busca y extrae los valores de Power (potencia)
            elif '&lt;Power&gt;' in line:
                power = [float(x) for x in line.split('&gt;')[1].split('&lt;')[0].split()]
            
            # Busca y extrae el valor de Saturation (saturación)
            elif '&lt;Saturation&gt;' in line:
                saturation = float(line.split('&gt;')[1].split('&lt;')[0])
    
    # Verifica si se encontraron todos los valores requeridos
    if slope is None:
        nuke.message(&quot;Error: No se encontró el valor de Slope en el archivo CDL.&quot;)
        raise ValueError(&quot;Falta el valor de Slope&quot;)
    
    if offset is None:
        nuke.message(&quot;Error: No se encontró el valor de Offset en el archivo CDL.&quot;)
        raise ValueError(&quot;Falta el valor de Offset&quot;)
    
    if power is None:
        nuke.message(&quot;Error: No se encontró el valor de Power en el archivo CDL.&quot;)
        raise ValueError(&quot;Falta el valor de Power&quot;)
    
    if saturation is None:
        nuke.message(&quot;Error: No se encontró el valor de Saturation en el archivo CDL.&quot;)
        raise ValueError(&quot;Falta el valor de Saturation&quot;)
    
    # Si todos los valores se encontraron, los devuelve como una tupla
    return slope, offset, power, saturation

# Ejecutar la función
export_cc_and_create_node()import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_CDL_CC_IP
importlib.reload(LGA_CDL_CC_IP)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_preRender
importlib.reload(LGA_preRender)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_preRender
importlib.reload(LGA_preRender)import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_preRender
importlib.reload(LGA_preRender)import nuke

def main():
    # Verifica si hay un nodo seleccionado
    selected_node = nuke.selectedNode()
    
    if selected_node:
        # Intenta obtener el valor del knob &quot;channels&quot;
        if &quot;channels&quot; in selected_node.knobs():
            channels_knob = selected_node['channels']
            current_value = channels_knob.value()
            
            # Lista de valores permitidos
            channels_values = ['rgb', 'rgba', 'alpha']
            
            # Determina el siguiente valor en la rotación
            if current_value in channels_values:
                next_value_index = (channels_values.index(current_value) + 1) % len(channels_values)
                next_value = channels_values[next_value_index]
            else:
                # Si el valor actual no está en la lista, se resetea a 'rgb'
                next_value = 'rgb'
            
            # Asigna el siguiente valor
            channels_knob.setValue(next_value)
            print(f&quot;El knob 'channels' ha cambiado a: {next_value}&quot;)
        else:
            print(&quot;El nodo seleccionado no tiene un knob 'channels'.&quot;)
    else:
        print(&quot;No hay ningún nodo seleccionado.&quot;)

# Ejecuta la función
main()
import nuke

DEBUG = True

def debug_print(*message):
    if DEBUG:
        print(*message)

def get_backdrops():
    return [n for n in nuke.allNodes() if n.Class() == &quot;BackdropNode&quot;]

def is_overlapping(a, b):
    ax, ay = a['xpos'].value(), a['ypos'].value()
    aw, ah = a['bdwidth'].value(), a['bdheight'].value()
    bx, by = b['xpos'].value(), b['ypos'].value()
    bw, bh = b['bdwidth'].value(), b['bdheight'].value()
    
    overlapping = not (ax + aw &lt;= bx or bx + bw &lt;= ax or ay + ah &lt;= by or by + bh &lt;= ay)
    if overlapping:
        debug_print(f&quot;Backdrops superpuestos: {a.name()} y {b.name()}&quot;)
    return overlapping

def is_inside(inner, outer):
    ix, iy = inner['xpos'].value(), inner['ypos'].value()
    iw, ih = inner['bdwidth'].value(), inner['bdheight'].value()
    ox, oy = outer['xpos'].value(), outer['ypos'].value()
    ow, oh = outer['bdwidth'].value(), outer['bdheight'].value()
    
    inside = (ox &lt;= ix and oy &lt;= iy and ox + ow &gt;= ix + iw and oy + oh &gt;= iy + ih)
    if inside:
        debug_print(f&quot;{inner.name()} está dentro de {outer.name()}&quot;)
    return inside

def get_area(backdrop):
    area = backdrop['bdwidth'].value() * backdrop['bdheight'].value()
    debug_print(f&quot;Área de {backdrop.name()}: {area}&quot;)
    return area

def group_overlapping_backdrops(backdrops):
    groups = []
    for backdrop in backdrops:
        added_to_group = False
        for group in groups:
            if any(is_overlapping(backdrop, b) for b in group):
                group.append(backdrop)
                added_to_group = True
                break
        if not added_to_group:
            groups.append([backdrop])
    return groups

def order_group(group):
    debug_print(f&quot;\nOrdenando grupo de {len(group)} backdrops&quot;)
    # Ordenar primero por área, de menor a mayor
    group.sort(key=get_area)
    
    ordered = []
    while group:
        current = group.pop(0)
        insert_index = len(ordered)  # Por defecto, insertar al final
        for i, ordered_backdrop in enumerate(ordered):
            if is_inside(current, ordered_backdrop):
                debug_print(f&quot;{current.name()} está dentro de {ordered_backdrop.name()}, insertando después&quot;)
                insert_index = i + 1
            elif is_inside(ordered_backdrop, current):
                debug_print(f&quot;{ordered_backdrop.name()} está dentro de {current.name()}, insertando antes&quot;)
                insert_index = i
                break
            elif get_area(current) &gt; get_area(ordered_backdrop):
                debug_print(f&quot;{current.name()} es más grande que {ordered_backdrop.name()}, insertando antes&quot;)
                insert_index = i
                break
        
        ordered.insert(insert_index, current)
        debug_print(f&quot;Insertado {current.name()} en la posición {insert_index}&quot;)
    
    return ordered

def order_all_backdrops():
    backdrops = get_backdrops()
    groups = group_overlapping_backdrops(backdrops)
    
    # Ordenar los grupos de manera determinista, por ejemplo, por el área total del grupo
    groups.sort(key=lambda g: sum(get_area(b) for b in g), reverse=True)
    
    ordered_groups = [order_group(group) for group in groups]
    
    # Asignación global de z_order
    current_z = 0
    debug_print(&quot;\nNuevo orden de backdrops por grupos (de atrás hacia adelante):&quot;)
    for group_index, group in enumerate(ordered_groups):
        debug_print(f&quot;\nGrupo {group_index + 1}:&quot;)
        for i, backdrop in enumerate(group):
            backdrop['z_order'].setValue(current_z)
            debug_print(f&quot;  {i+1}. {backdrop.name()} - Nuevo Z: {current_z}&quot;)
            current_z += 1  # Incrementar globalmente
    debug_print(&quot;\nSe han ajustado los valores Z de todos los backdrops de manera global.&quot;)
    
    return ordered_groups

# Esta parte solo se ejecutará si el script se ejecuta directamente
if __name__ == &quot;__main__&quot;:
    ordered_groups = order_all_backdrops()
import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_disable_A_B
importlib.reload(LGA_disable_A_B)import hiero.ui

def rotate_overlay_style(viewer):
    current_style = viewer.maskOverlayStyle()
    style_order = [
        hiero.ui.Player.MaskOverlayStyle.eMaskOverlayNone,
        hiero.ui.Player.MaskOverlayStyle.eMaskOverlayHalf,
        hiero.ui.Player.MaskOverlayStyle.eMaskOverlayFull
    ]
    
    # Encontrar el índice del estilo actual y rotar al siguiente
    try:
        current_index = style_order.index(current_style)
        next_index = (current_index + 1) % len(style_order)
        new_style = style_order[next_index]
    except ValueError:
        # Si el estilo actual no está en la lista, comenzar desde el principio
        new_style = style_order[0]
    
    return new_style

# Obtener el visor actual
viewer = hiero.ui.currentViewer()

# Verificar si se encontró el visor
if viewer is not None:
    try:
        # Obtener y mostrar el estilo actual
        current_style = viewer.maskOverlayStyle()
        print(f&quot;Estilo actual: {current_style}&quot;)

        # Rotar al siguiente estilo
        new_style = rotate_overlay_style(viewer)
        viewer.setMaskOverlayStyle(new_style)
        print(f&quot;Nuevo estilo aplicado: {new_style}&quot;)

        # Aplicar siempre el aspecto 2.35:1
        viewer.setMaskOverlayFromRemote(&quot;2.35:1&quot;)
        print(&quot;Aspecto 2.35:1 aplicado&quot;)

    except AttributeError as e:
        print(f&quot;Error: {e}&quot;)
else:
    print(&quot;No se pudo obtener el visor actual.&quot;)from PySide2.QtWidgets import QTreeView
from PySide2.QtCore import Qt
import hiero.ui

def findBinView():
    &quot;&quot;&quot;Encuentra la vista del Bin activa.&quot;&quot;&quot;
    for window in hiero.ui.windowManager().windows():
        if window.metaObject().className().endswith(&quot;BinView&quot;):
            return window
    return None

def expandItemRecursively(treeView, model, parent, target_item):
    &quot;&quot;&quot;Expande recursivamente hasta encontrar y expandir el elemento objetivo.&quot;&quot;&quot;
    for row in range(parent.rowCount()):
        child = parent.child(row)
        if child.text(0) == target_item.name():
            index = model.indexFromItem(child)
            treeView.expand(index)
            # Opcional: seleccionar el elemento
            treeView.setCurrentIndex(index)
            return True
        # Llamada recursiva
        if expandItemRecursively(treeView, model, child, target_item):
            return True
    return False

def printAndExpandSelectedItem():
    &quot;&quot;&quot;Imprime el elemento seleccionado y expande su ruta en el Bin.&quot;&quot;&quot;
    binView = findBinView()
    if not binView:
        print(&quot;No se encontró la vista del Bin.&quot;)
        return

    view = hiero.ui.activeView()
    if not isinstance(view, hiero.ui.BinView):
        print(&quot;La vista activa no es una vista del Bin.&quot;)
        return

    selection = view.selection()
    if not selection:
        print(&quot;No hay elementos seleccionados en la vista del Bin.&quot;)
        return

    selected_item = selection[0]
    print(f&quot;Elemento seleccionado: {selected_item.name()}&quot;)

    # Intentar expandir el elemento seleccionado
    treeViews = binView.findChildren(QTreeView)
    expanded = False
    for treeView in treeViews:
        model = treeView.model()
        root = model.invisibleRootItem()
        if expandItemRecursively(treeView, model, root, selected_item):
            print(f&quot;Elemento '{selected_item.name()}' expandido.&quot;)
            expanded = True
            break

    if not expanded:
        print(f&quot;No se pudo expandir el elemento '{selected_item.name()}'.&quot;)

# Ejecutar la función
printAndExpandSelectedItem()
import hiero.core
import hiero.ui
def print_effects_in_tracks(track_names):
    &quot;&quot;&quot;
    Imprime los efectos en las pistas especificadas.

    Args:
        track_names (list): Lista de nombres de pistas a inspeccionar.
    &quot;&quot;&quot;
    # Obtener la secuencia activa
    seq = hiero.ui.activeSequence()

    if not seq:
        print(&quot;No hay una secuencia activa.&quot;)
        return

    # Iterar sobre las pistas de video en la secuencia
    for track in seq.videoTracks():
        if track.name() in track_names:
            print(f&quot;\nPista '{track.name()}':&quot;)
            items = track.items()
            if not items:
                print(f&quot;  La pista '{track.name()}' no tiene elementos.&quot;)
                continue
            for idx, item in enumerate(items):
                # Verificar si el item es un efecto
                if isinstance(item, hiero.core.EffectTrackItem):
                    effect_name = item.name() if hasattr(item, 'name') else &quot;Efecto sin nombre&quot;
                    print(f&quot;  Efecto {idx+1}: {effect_name}&quot;)
                else:
                    print(f&quot;  Clip {idx+1}: No es un efecto.&quot;)

# Lista de pistas a inspeccionar
tracks_to_inspect = [&quot;BurnIn&quot;, &quot;EXR&quot;]
# Llamar a la función para imprimir los efectos en las pistas especificadas
print_effects_in_tracks(tracks_to_inspect)
&quot;&quot;&quot;
__________________________________________________________

  LGA_NKS_Combined_Script v1.0 - 2024 - Lega
  Combina la rotación de estilos de máscara del viewer y
  el toggle de opacity con ajuste de box en efectos específicos.
__________________________________________________________
&quot;&quot;&quot;

import hiero.core
import hiero.ui
import nuke
import os

# ============================
# Configuración de Variables
# ============================

# Configuración para la rotación de estilos de máscara
ASPECT_RATIO = &quot;2.35:1&quot;  # Aspecto a aplicar al viewer

# Definición de estilos de máscara en orden de rotación
MASK_STYLE_ORDER = [
    hiero.ui.Player.MaskOverlayStyle.eMaskOverlayNone,
    hiero.ui.Player.MaskOverlayStyle.eMaskOverlayHalf,
    hiero.ui.Player.MaskOverlayStyle.eMaskOverlayFull
]

# Nombre del track a inspeccionar
TRACK_NAME = &quot;BurnIn&quot;

# Palabra clave para buscar el efecto
EFFECT_NAME_SEARCH = &quot;Frame&quot;

# Propiedad principal para toggle
MAIN_TOGGLE_PROPERTY = &quot;opacity&quot;

# Valores para toggle de la propiedad principal
TOGGLE_INITIAL_VALUE = 1.0    # Valor inicial (e.g., 1.0)
TOGGLE_SECONDARY_VALUE = 0.9  # Valor secundario (e.g., 0.9)

# Propiedad de 'box' y ajustes relacionados
BOX_PROPERTY = &quot;box&quot;
BOX_INDEX_TO_MODIFY = 3          # Índice del cuarto valor en la tupla (0-based)
BOX_ADJUSTMENT_INITIAL = 300     # Incremento cuando se cambia a TOGGLE_SECONDARY_VALUE
BOX_ADJUSTMENT_SECONDARY = -300  # Decremento cuando se cambia a TOGGLE_INITIAL_VALUE

# ============================
# Funciones Principales
# ============================

def rotate_overlay_style(viewer):
    &quot;&quot;&quot;
    Rota el estilo de máscara del viewer al siguiente en el orden definido.
    &quot;&quot;&quot;
    current_style = viewer.maskOverlayStyle()
    try:
        current_index = MASK_STYLE_ORDER.index(current_style)
        next_index = (current_index + 1) % len(MASK_STYLE_ORDER)
        new_style = MASK_STYLE_ORDER[next_index]
    except ValueError:
        # Si el estilo actual no está en la lista, comenzar desde el principio
        new_style = MASK_STYLE_ORDER[0]
    
    return new_style

def print_effects_in_tracks(track_name):
    &quot;&quot;&quot;
    Imprime todos los efectos en el track especificado.
    &quot;&quot;&quot;
    # Obtener la secuencia activa
    seq = hiero.ui.activeSequence()

    if not seq:
        print(&quot;No se encontró una secuencia activa.&quot;)
        return

    # Iterar sobre las pistas de video en la secuencia
    for track in seq.videoTracks():
        if track.name() == track_name:
            print(f&quot;\nTrack '{track.name()}':&quot;)
            items = track.subTrackItems()
            if not items:
                print(f&quot;  El track '{track.name()}' no tiene items.&quot;)
                continue
            for idx, item in enumerate(items):
                # Asumimos que cada item es una lista o tupla y tomamos el primer elemento
                effect_item = item[0]
                if isinstance(effect_item, hiero.core.EffectTrackItem):
                    effect_name = effect_item.name() if hasattr(effect_item, 'name') else &quot;Efecto sin nombre&quot;
                    print(f&quot;  Efecto {idx+1}: {effect_name}&quot;)
                else:
                    print(f&quot;  Clip {idx+1}: No es un efecto.&quot;)

def toggle_opacity_and_adjust_box(effect_item, new_mask_style):
    &quot;&quot;&quot;
    Realiza un toggle en la propiedad principal del efecto y ajusta la propiedad 'box'
    según el nuevo estilo de máscara.
    &quot;&quot;&quot;
    if not isinstance(effect_item, hiero.core.EffectTrackItem):
        print(&quot;El item proporcionado no es un efecto.&quot;)
        return

    # Obtener el nodo asociado al efecto
    node = effect_item.node()
    if not node:
        print(&quot;No se encontró un nodo asociado al efecto.&quot;)
        return

    # Verificar si el nodo tiene la propiedad principal para toggle
    if MAIN_TOGGLE_PROPERTY not in node.knobs():
        print(f&quot;El nodo del efecto no tiene una propiedad '{MAIN_TOGGLE_PROPERTY}'.&quot;)
        return

    # Obtener el valor actual de la propiedad principal
    try:
        current_toggle_value = node[MAIN_TOGGLE_PROPERTY].value()
        print(f&quot;\nValor actual de '{MAIN_TOGGLE_PROPERTY}': {current_toggle_value} (Tipo: {type(current_toggle_value).__name__})&quot;)
    except Exception as e:
        print(f&quot;No se pudo obtener el valor de '{MAIN_TOGGLE_PROPERTY}': {e}&quot;)
        return

    # Determinar el nuevo valor de la propiedad principal y el ajuste de 'box' según el nuevo estilo de máscara
    if new_mask_style == hiero.ui.Player.MaskOverlayStyle.eMaskOverlayNone:
        desired_opacity = TOGGLE_INITIAL_VALUE  # 1.0
        if current_toggle_value != desired_opacity:
            new_toggle_value = desired_opacity
            box_adjustment = BOX_ADJUSTMENT_SECONDARY if current_toggle_value == TOGGLE_SECONDARY_VALUE else 0
            toggle_action = f&quot;cambiar '{MAIN_TOGGLE_PROPERTY}' a {new_toggle_value}&quot;
        else:
            print(f&quot;'{MAIN_TOGGLE_PROPERTY}' ya está en {desired_opacity}. No se realizará ningún cambio.&quot;)
            return
    elif new_mask_style in [hiero.ui.Player.MaskOverlayStyle.eMaskOverlayHalf, hiero.ui.Player.MaskOverlayStyle.eMaskOverlayFull]:
        desired_opacity = TOGGLE_SECONDARY_VALUE  # 0.9
        if current_toggle_value == TOGGLE_INITIAL_VALUE:
            new_toggle_value = desired_opacity
            box_adjustment = BOX_ADJUSTMENT_INITIAL
            toggle_action = f&quot;cambiar '{MAIN_TOGGLE_PROPERTY}' a {new_toggle_value} y sumar {BOX_ADJUSTMENT_INITIAL} al cuarto valor de '{BOX_PROPERTY}'&quot;
        elif current_toggle_value == TOGGLE_SECONDARY_VALUE:
            print(f&quot;'{MAIN_TOGGLE_PROPERTY}' ya está en {desired_opacity}. No se realizará ningún cambio.&quot;)
            return
        else:
            # Si el valor actual no es ninguno de los esperados, establecer a valor secundario y ajustar
            new_toggle_value = desired_opacity
            box_adjustment = BOX_ADJUSTMENT_INITIAL
            toggle_action = f&quot;cambiar '{MAIN_TOGGLE_PROPERTY}' a {new_toggle_value} y sumar {BOX_ADJUSTMENT_INITIAL} al cuarto valor de '{BOX_PROPERTY}'&quot;
    else:
        print(&quot;Estilo de máscara no reconocido. No se realizará ningún cambio.&quot;)
        return

    # Aplicar el nuevo valor de la propiedad principal
    try:
        node[MAIN_TOGGLE_PROPERTY].setValue(new_toggle_value)
        print(f&quot;'{MAIN_TOGGLE_PROPERTY}' ha sido {toggle_action}. Nuevo valor: {new_toggle_value}&quot;)
    except Exception as e:
        print(f&quot;No se pudo establecer el nuevo valor de '{MAIN_TOGGLE_PROPERTY}': {e}&quot;)
        return

    # Verificar si se necesita ajustar 'box'
    if box_adjustment != 0:
        # Verificar si el nodo tiene la propiedad 'box'
        if BOX_PROPERTY not in node.knobs():
            print(f&quot;El nodo del efecto no tiene una propiedad '{BOX_PROPERTY}'. No se puede ajustar.&quot;)
            return

        # Obtener el valor actual de 'box'
        try:
            current_box = node[BOX_PROPERTY].value()
            if not isinstance(current_box, (tuple, list)) or len(current_box) &lt;= BOX_INDEX_TO_MODIFY:
                print(f&quot;La propiedad '{BOX_PROPERTY}' no tiene el formato esperado (debe ser una tupla o lista con al menos {BOX_INDEX_TO_MODIFY + 1} elementos).&quot;)
                return
            print(f&quot;Valor actual de '{BOX_PROPERTY}': {current_box} (Tipo: {type(current_box).__name__})&quot;)
        except Exception as e:
            print(f&quot;No se pudo obtener el valor de '{BOX_PROPERTY}': {e}&quot;)
            return

        # Ajustar el cuarto valor de 'box'
        try:
            # Convertir a lista para modificar
            new_box = list(current_box)
            new_box[BOX_INDEX_TO_MODIFY] += box_adjustment
            # Convertir de nuevo a tupla
            new_box = tuple(new_box)
            node[BOX_PROPERTY].setValue(new_box)
            print(f&quot;'{BOX_PROPERTY}' ha sido ajustado. Nuevo valor: {new_box}&quot;)
        except Exception as e:
            print(f&quot;No se pudo ajustar el valor de '{BOX_PROPERTY}': {e}&quot;)

def main():
    &quot;&quot;&quot;
    Función principal que coordina la rotación de estilos de máscara y la modificación del efecto específico.
    &quot;&quot;&quot;
    # Rotar el estilo de máscara del viewer
    viewer = hiero.ui.currentViewer()

    # Verificar si se encontró el viewer
    if viewer is not None:
        try:
            # Obtener el estilo actual y determinar el nuevo estilo
            current_style = viewer.maskOverlayStyle()
            new_style = rotate_overlay_style(viewer)
            viewer.setMaskOverlayStyle(new_style)
            print(f&quot;\nEstilo de máscara cambiado de {current_style} a {new_style}&quot;)

            # Aplicar siempre el aspecto 2.35:1
            viewer.setMaskOverlayFromRemote(ASPECT_RATIO)
            print(f&quot;Aspecto {ASPECT_RATIO} aplicado al viewer&quot;)

            # Determinar el nombre del nuevo estilo para lógica posterior
            if new_style == hiero.ui.Player.MaskOverlayStyle.eMaskOverlayNone:
                new_mask_style = &quot;None&quot;
            elif new_style == hiero.ui.Player.MaskOverlayStyle.eMaskOverlayHalf:
                new_mask_style = &quot;Half&quot;
            elif new_style == hiero.ui.Player.MaskOverlayStyle.eMaskOverlayFull:
                new_mask_style = &quot;Full&quot;
            else:
                new_mask_style = &quot;Unknown&quot;

            print(f&quot;Nuevo estilo de máscara: {new_mask_style}&quot;)

        except AttributeError as e:
            print(f&quot;Error al manipular el viewer: {e}&quot;)
    else:
        print(&quot;No se pudo obtener el viewer actual.&quot;)

    # Imprimir todos los efectos en el track especificado
    print_effects_in_tracks(TRACK_NAME)

    # Obtener la secuencia activa nuevamente
    seq = hiero.ui.activeSequence()
    if not seq:
        return

    # Buscar el track especificado
    target_track = None
    for track in seq.videoTracks():
        if track.name() == TRACK_NAME:
            target_track = track
            break

    if not target_track:
        print(f&quot;No se encontró el track '{TRACK_NAME}'.&quot;)
        return

    # Iterar sobre los items del track para encontrar el efecto que contiene la palabra clave
    items = target_track.subTrackItems()
    if not items:
        print(f&quot;El track '{target_track.name()}' no tiene items.&quot;)
        return

    target_effect = None
    for item in items:
        effect_item = item[0]
        if isinstance(effect_item, hiero.core.EffectTrackItem):
            if EFFECT_NAME_SEARCH in effect_item.name():
                target_effect = effect_item
                break

    if target_effect:
        print(f&quot;\nEfecto que contiene '{EFFECT_NAME_SEARCH}' encontrado:&quot;)
        print(f&quot;Nombre del efecto: {target_effect.name()}&quot;)
        toggle_opacity_and_adjust_box(target_effect, new_style)
    else:
        print(f&quot;No se encontró ningún efecto que contenga la palabra '{EFFECT_NAME_SEARCH}' en el nombre.&quot;)

# Ejecutar el script principal
if __name__ == &quot;__main__&quot;:
    main()
import hiero
import time

def obtener_limites_scrollbar():
    try:
        t = hiero.ui.getTimelineEditor(hiero.ui.activeSequence())
        scrollbar = t.window().children()[3].children()[0].children()[0].children()[7].children()[0]
        
        limite_inferior = scrollbar.minimum()
        limite_superior = scrollbar.maximum()
        
        posicion_actual = scrollbar.value()
        
        print(f&quot;Posición actual del scrollbar: {posicion_actual}&quot;)
        print(f&quot;Rango del scrollbar: {scrollbar.minimum()} a {scrollbar.maximum()}&quot;)
        print(f&quot;Tamaño de página del scrollbar: {scrollbar.pageStep()}&quot;)
        
        return limite_inferior, limite_superior, scrollbar
    
    except Exception as e:
        print(f&quot;Ocurrió un error al obtener los límites: {e}&quot;)
        return None, None, None

def scroll_to_position(scrollbar, position):
    try:
        scrollbar.setValue(position)
        print(f&quot;Scrolled to position {position}.&quot;)
    except Exception as e:
        print(f&quot;Ocurrió un error al mover el scrollbar: {e}&quot;)

# Obtener los límites y el scrollbar
tiempo_inicio = time.time()
limite_inferior, limite_superior, scrollbar = obtener_limites_scrollbar()
tiempo_total = time.time() - tiempo_inicio

if limite_inferior is not None and limite_superior is not None:
    print(f&quot;Límite inferior del scrollbar: {limite_inferior}&quot;)
    print(f&quot;Límite superior del scrollbar: {limite_superior}&quot;)
    print(f&quot;Tiempo de ejecución: {tiempo_total:.2f} segundos&quot;)
    
    # Calcular la nueva posición y mover el scrollbar
    nueva_posicion = limite_inferior + 70
    scroll_to_position(scrollbar, nueva_posicion)
    
    # Verificar la posición final
    posicion_final = scrollbar.value()
    print(f&quot;Posición final del scrollbar: {posicion_final}&quot;)&quot;&quot;&quot;
_________________________________________________

  LGA_ViewerPanel v1.0 - 2024 - Lega Pugliese
  Viewer panel for Hiero / Nuke Studio
_________________________________________________

&quot;&quot;&quot;

import hiero.ui
import hiero.core
import os
import subprocess
import socket
from PySide2.QtWidgets import *
from PySide2.QtGui import QIcon, QKeySequence
from PySide2.QtCore import *
from PySide2 import QtWidgets, QtCore

# Variable global para activar o desactivar los prints
DEBUG = False

def debug_print(*message):
    if DEBUG:
        print(*message)

class ViewerPanel(QWidget):
    def __init__(self):
        super(ViewerPanel, self).__init__()

        self.setObjectName(&quot;com.lega.ViewerPanel&quot;)
        self.setWindowTitle(&quot;Viewer&quot;)
        self.setStyleSheet(&quot;QToolTip { color: #ffffff; background-color: #2a2a2a; border: 1px solid white; }&quot;)

        self.layout = QGridLayout(self)
        self.setLayout(self.layout)

        # Crear botones y agregarlos al layout
        self.buttons = [
            (&quot;&amp;Viewer | Rec709&quot;, self.rec709_viewer, &quot;#311840&quot;, &quot;Shift+V&quot;, &quot;Shift+V&quot;),
            (&quot;Viewer | 2.35:1 &quot;, self.viewer_235, &quot;#311840&quot;),
            (&quot;Refresh Timeline&quot;, self.refresh_timeline, &quot;#4c4350&quot;),
            (&quot;Top Track &quot;, self.top_track, &quot;#4c4350&quot;, &quot;Ctrl+Shift+T&quot;)            
        ]

        self.num_columns = 1  # Inicialmente una columna
        self.create_buttons()

        # Conectar la señal de cambio de tamaño del widget al método correspondiente
        self.adjust_columns_on_resize()
        self.resizeEvent = self.adjust_columns_on_resize

    def create_buttons(self):
        for index, button_info in enumerate(self.buttons):
            name = button_info[0]
            handler = button_info[1]
            style = button_info[2]
            shortcut = button_info[3] if len(button_info) &gt; 3 else None
            tooltip = button_info[4] if len(button_info) &gt; 4 else None

            button = QPushButton(name)
            button.setStyleSheet(f&quot;background-color: {style}&quot;)
            button.clicked.connect(handler)
            if shortcut:
                button.setShortcut(QKeySequence(shortcut))  # Usar QKeySequence
            if tooltip:
                button.setToolTip(tooltip)

            row = index // self.num_columns
            column = index % self.num_columns
            self.layout.addWidget(button, row, column)


    def adjust_columns_on_resize(self, event=None):
        # Obtener el ancho actual del widget
        panel_width = self.width()
        button_width = 150  # Ancho aproximado de cada botón
        min_button_spacing = 10  # Espacio mínimo entre botones

        # Calcular el número de columnas en función del ancho del widget
        self.num_columns = max(1, (panel_width + min_button_spacing) // (button_width + min_button_spacing))

        # Limpiar el layout actual y eliminar widgets solo si existen
        while self.layout.count():
            item = self.layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

        # Volver a crear los botones con el nuevo número de columnas
        self.create_buttons()

        # Calcular el número de filas usadas
        num_rows = (len(self.buttons) + self.num_columns - 1) // self.num_columns

        # Añadir el espaciador vertical
        spacer = QSpacerItem(20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding)
        self.layout.addItem(spacer, num_rows, 0, 1, self.num_columns)

    ##### Rec709 en Viewer
    def rec709_viewer(self):
        try:
            current_viewer = hiero.ui.currentViewer()
            if current_viewer:
                current_viewer.player().setLUT('ACES/Rec.709')
                debug_print(&quot;LUT set to ACES/Rec.709&quot;)
            else:
                debug_print(&quot;No active viewer found.&quot;)
        except Exception as e:
            debug_print(f&quot;Error setting Rec.709 LUT: {e}&quot;)

    def viewer_235(self):
        try:
            script_path = os.path.join(os.path.dirname(__file__), 'LGA_NKS', 'LGA_NKS_Viewer_235.py')
            if os.path.exists(script_path):
                import importlib.util
                spec = importlib.util.spec_from_file_location(&quot;LGA_NKS_Viewer_235&quot;, script_path)
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)

                # Llamar a la función main del script
                module.main()
                debug_print(&quot;Executed LGA_NKS_Viewer_235 script.&quot;)
            else:
                debug_print(f&quot;Script not found at path: {script_path}&quot;)
        except Exception as e:
            debug_print(f&quot;Error during running Viewer 2.35 script: {e}&quot;)


###### Refresh timeline
    def refresh_timeline(self):
        # Ruta al script dentro de la subcarpeta LGA_NKS
        script_path = os.path.join(os.path.dirname(__file__), 'LGA_NKS', 'LGA_NKS_Refresh_Timeline.py')
        if os.path.exists(script_path):
            import importlib.util
            spec = importlib.util.spec_from_file_location(&quot;LGA_NKS_Refresh_Timeline&quot;, script_path)
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)

            # Llamar a la funcion principal del script
            module.main()
        else:
            debug_print(f&quot;Script not found at path: {script_path}&quot;)

        # Pausa de 500 milisegundos
        timer = QTimer(self)
        timer.setSingleShot(True)  # Asegurarse de que solo se dispare una vez
        timer.timeout.connect(self.execute_scroll_to_top_track)
        timer.start(200)  # Esperar 1.5 segundos antes de ejecutar el siguiente script
                    
    def execute_scroll_to_top_track(self):
        # Ruta al script dentro de la subcarpeta LGA_NKS
        script_path = os.path.join(os.path.dirname(__file__), 'LGA_NKS', 'LGA_NKS-ScrollTo_TopTrack.py')
        if os.path.exists(script_path):
            import importlib.util
            spec = importlib.util.spec_from_file_location(&quot;LGA_NKS-ScrollTo_TopTrack&quot;, script_path)
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)

            # Llamar a la funcion principal del script
            module.main()
        else:
            debug_print(f&quot;Script not found at path: {script_path}&quot;)


###### Refresh timeline
    def top_track(self):
                    
         # Ruta al script dentro de la subcarpeta LGA_NKS
        script_path = os.path.join(os.path.dirname(__file__), 'LGA_NKS', 'LGA_NKS-ScrollTo_TopTrack.py')
        if os.path.exists(script_path):
            import importlib.util
            spec = importlib.util.spec_from_file_location(&quot;LGA_NKS-ScrollTo_TopTrack&quot;, script_path)
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)

            # Llamar a la funcion principal del script
            module.main()
        else:
            debug_print(f&quot;Script not found at path: {script_path}&quot;)            

# Crear la instancia del widget y añadirlo al gestor de ventanas de Hiero
viewerPanel = ViewerPanel()
wm = hiero.ui.windowManager()
wm.addWindow(viewerPanel)
&quot;&quot;&quot;
________________________________________________________________________________

  LGA_NKS_mediaMissingFrames v1.4 | 2024 | Lega  
  Escanea los clips seleccionados en Hiero para secuencias EXR con frames faltantes
________________________________________________________________________________

&quot;&quot;&quot;

import hiero.core
import hiero.ui
from PySide2.QtWidgets import QApplication, QWidget, QVBoxLayout, QTableWidget, QTableWidgetItem, QHeaderView
from PySide2.QtGui import QScreen
from PySide2.QtCore import Qt
import os
import re

class ClipMediaInfo(QWidget):
    def __init__(self, parent=None):
        super(ClipMediaInfo, self).__init__(parent)
        self.initUI()

    def initUI(self):
        self.setWindowTitle(&quot;Información de Clips EXR&quot;)
        layout = QVBoxLayout(self)

        self.table = QTableWidget(0, 6, self)
        self.table.setHorizontalHeaderLabels(['Ruta', 'Nombre del Clip', 'IN', 'OUT', 'Frames', 'Estado'])
        self.table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        
        self.load_data()

        layout.addWidget(self.table)
        self.setLayout(layout)
        
        self.adjust_window_size()

    def load_data(self):
        seq = hiero.ui.activeSequence()
        if seq:
            te = hiero.ui.getTimelineEditor(seq)
            selected_items = te.selection()

            for item in selected_items:
                if isinstance(item, hiero.core.TrackItem):
                    clip = item.source()
                    file_path = clip.mediaSource().fileinfos()[0].filename()
                    if file_path.endswith('.exr'):
                        row_count = self.table.rowCount()
                        self.table.insertRow(row_count)
                        
                        self.table.setItem(row_count, 0, QTableWidgetItem(file_path))
                        clip_name_item = QTableWidgetItem(clip.name())
                        clip_name_item.setTextAlignment(Qt.AlignCenter)
                        self.table.setItem(row_count, 1, clip_name_item)
                        
                        # Obtener el rango de frames correcto
                        first_frame = clip.mediaSource().startTime()
                        last_frame = clip.mediaSource().startTime() + clip.mediaSource().duration() - 1
                        in_frame_item = QTableWidgetItem(str(first_frame))
                        in_frame_item.setTextAlignment(Qt.AlignCenter)
                        self.table.setItem(row_count, 2, in_frame_item)
                        out_frame_item = QTableWidgetItem(str(last_frame))
                        out_frame_item.setTextAlignment(Qt.AlignCenter)
                        self.table.setItem(row_count, 3, out_frame_item)
                        
                        total_frames = last_frame - first_frame + 1
                        frames_item = QTableWidgetItem(str(total_frames))
                        frames_item.setTextAlignment(Qt.AlignCenter)
                        self.table.setItem(row_count, 4, frames_item)
                        
                        directory = os.path.dirname(file_path)
                        filename_pattern = os.path.basename(file_path)
                        filename_pattern = re.sub(r'%0\d+d', r'%d', filename_pattern)
                        
                        missing_frames = []
                        for frame in range(int(first_frame), int(last_frame) + 1):
                            expected_filename = os.path.join(directory, filename_pattern % frame)
                            if not os.path.exists(expected_filename):
                                missing_frames.append(str(frame))
                        
                        if missing_frames:
                            if len(missing_frames) == total_frames:
                                status_item = QTableWidgetItem(&quot;OFFLINE&quot;)
                            else:
                                status_item = QTableWidgetItem(&quot;MISSING&quot;)
                                print(f&quot;Ruta del archivo: {file_path}&quot;)
                                print(f&quot;Faltantes: {', '.join(missing_frames)}&quot;)
                        else:
                            status_item = QTableWidgetItem(&quot;OK&quot;)
                            
                        status_item.setTextAlignment(Qt.AlignCenter)
                        self.table.setItem(row_count, 5, status_item)
                    
            self.table.resizeColumnsToContents()

    def adjust_window_size(self):
        self.table.horizontalHeader().setStretchLastSection(False)
        self.table.resizeColumnsToContents()

        width = self.table.verticalHeader().width() - 40
        for i in range(self.table.columnCount()):
            width += self.table.columnWidth(i) + 20

        screen = QApplication.primaryScreen()
        screen_rect = screen.availableGeometry()
        max_width = screen_rect.width() * 0.8
        final_width = min(width, max_width)

        height = self.table.horizontalHeader().height() + 20
        for i in range(self.table.rowCount()):
            height += self.table.rowHeight(i) + 4

        max_height = screen_rect.height() * 0.8
        final_height = min(height, max_height)

        self.table.horizontalHeader().setStretchLastSection(True)

        self.resize(final_width, final_height)
        self.move((screen_rect.width() - final_width) // 2, (screen_rect.height() - final_height) // 2)

def showClipMediaInfo():
    global clipMediaInfoWindow
    clipMediaInfoWindow = ClipMediaInfo()
    clipMediaInfoWindow.show()

# Función para ejecutar el script
def run_script():
    showClipMediaInfo()

# Registrar la función como una acción en Hiero
action = hiero.ui.createMenuAction(&quot;Mostrar Información de Clips EXR&quot;, run_script)
hiero.ui.registerAction(action)

# Agregar la acción al menú de Hiero
menuBar = hiero.ui.menuBar()
toolsMenu = menuBar.addMenu(&quot;Herramientas&quot;)
toolsMenu.addAction(action)

# Ejecutar el script automáticamente al cargar
run_script()
&quot;&quot;&quot;
_________________________________________

  LGA_EditToolsPanel v2.5 - 2024 - Lega
  Tools panel for Hiero / Nuke Studio
_________________________________________

&quot;&quot;&quot;


import hiero.ui
import hiero.core
import os
import re
import subprocess
import socket
import PySide2, hiero
from PySide2.QtWidgets import *
from PySide2.QtGui import QIcon
from PySide2.QtCore import *
from PySide2 import QtWidgets, QtCore

# Variable global para activar o desactivar los prints
DEBUG = False

def debug_print(*message):
    if DEBUG:
        print(*message)

class ReconnectMediaWidget(QWidget):
    def __init__(self):
        super(ReconnectMediaWidget, self).__init__()

        self.setObjectName(&quot;com.lega.toolPanel&quot;)
        self.setWindowTitle(&quot;Edit&quot;)
        self.setStyleSheet(&quot;QToolTip { color: #ffffff; background-color: #2a2a2a; border: 1px solid white; }&quot;)

        self.layout = QGridLayout(self)  # Usamos QGridLayout en lugar de QVBoxLayout
        self.setLayout(self.layout)

        # Crear el organizador
        self.organizer = OrganizeProject()

        # Crear botones y agregarlos al layout
        self.buttons = [
            (&quot;Organize Project&quot;, self.organizer.organize_project, &quot;#283548&quot;),
            (&quot;Clean Project&quot;, self.clean_project, &quot;#283548&quot;),
            (&quot;Rec709 | Clip&quot;, self.rec709_clip, &quot;#434c41&quot;),
            (&quot;Default | Clip&quot;, self.default_clip, &quot;#434c41&quot;),
            (&quot;Set Shot Name&quot;, self.set_shot_name, &quot;#453434&quot;),
            (&quot;Extend &amp;Edit&quot;, self.extend_edit_to_playhead, &quot;#453434&quot;, &quot;Alt+E&quot;, &quot;Alt+E&quot;),
            (&quot;Reconnect T &gt; N&quot;, self.reconnect_t_to_n, &quot;#4a4329&quot;),
            (&quot;Reconnect N &gt; T&quot;, self.reconnect_n_to_t, &quot;#4a4329&quot;),
            (&quot;Reconnect Media&quot;, self.reconnectMediaFromTimeline, &quot;#4a4329&quot;, &quot;Alt+M&quot;, &quot;Alt+M&quot;),
            ]

        self.num_columns = 1  # Inicialmente una columna
        self.create_buttons()

        # Conectar la senal de cambio de tamano del widget al metodo correspondiente
        self.adjust_columns_on_resize()
        self.resizeEvent = self.adjust_columns_on_resize

    def create_buttons(self):
        for index, button_info in enumerate(self.buttons):
            name = button_info[0]
            handler = button_info[1]
            style = button_info[2]
            shortcut = button_info[3] if len(button_info) &gt; 3 else None
            tooltip = button_info[4] if len(button_info) &gt; 4 else None

            button = QPushButton(name)
            button.setStyleSheet(f&quot;background-color: {style}&quot;)
            button.clicked.connect(handler)
            if shortcut:
                button.setShortcut(shortcut)
            if tooltip:
                button.setToolTip(tooltip)

            row = index // self.num_columns
            column = index % self.num_columns
            self.layout.addWidget(button, row, column)

    def adjust_columns_on_resize(self, event=None):
        # Obtener el ancho actual del widget
        panel_width = self.width()
        button_width = 120  # Ancho aproximado de cada boton
        min_button_spacing = 10  # Espacio minimo entre botones

        # Calcular el numero de columnas en funcion del ancho del widget
        self.num_columns = max(1, (panel_width + min_button_spacing) // (button_width + min_button_spacing))

        # Limpiar el layout actual y eliminar widgets solo si existen
        while self.layout.count():
            item = self.layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

        # Volver a crear los botones con el nuevo numero de columnas
        self.create_buttons()

        # Calcular el numero de filas usadas
        num_rows = (len(self.buttons) + self.num_columns - 1) // self.num_columns

        # Anadir el espaciador vertical
        spacer = QSpacerItem(20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding)
        self.layout.addItem(spacer, num_rows, 0, 1, self.num_columns)


###### Rec 709 en clips seleccionados
    def rec709_clip(self):
        # Obtener la secuencia activa y el editor de linea de tiempo
        seq = hiero.ui.activeSequence()
        if seq:  # Asegurarse de que hay una secuencia activa
            te = hiero.ui.getTimelineEditor(seq)
            selected_clips = te.selection()

            # Iterar sobre los clips seleccionados para cambiar el color transform
            for clip in selected_clips:
                try:
                    clip.setSourceMediaColourTransform(&quot;Output - Rec.709&quot;)
                    debug_print(&quot;Color transform changed successfully.&quot;)
                except Exception as e:
                    debug_print(&quot;Error changing color transform:&quot;, e)
        else:
            debug_print(&quot;No active sequence found.&quot;)

###### Default space color en clips seleccionados
    def default_clip(self):
        # Obtener la secuencia activa y el editor de linea de tiempo
        seq = hiero.ui.activeSequence()
        if seq:  # Asegurarse de que hay una secuencia activa
            te = hiero.ui.getTimelineEditor(seq)
            selected_clips = te.selection()

            # Iterar sobre los clips seleccionados para cambiar el color transform
            for clip in selected_clips:
                try:
                    clip.setSourceMediaColourTransform(&quot;default&quot;)
                    debug_print(&quot;Color transform changed successfully.&quot;)
                except Exception as e:
                    debug_print(&quot;Error changing color transform:&quot;, e)
        else:
            debug_print(&quot;No active sequence found.&quot;)




###### Shot name
    def set_shot_name(self):
        try:
            project = hiero.core.projects()[-1]
            with project.beginUndo(&quot;Set Shot Name&quot;):
                seq = hiero.ui.activeSequence()
                if not seq:
                    debug_print(&quot;No active sequence found.&quot;)
                    return

                te = hiero.ui.getTimelineEditor(seq)
                selected_clips = te.selection()

                if len(selected_clips) == 0:
                    debug_print(&quot;*** No clips selected on the track ***&quot;)
                else:
                    for shot in selected_clips:
                        # Obtener el file path del clip seleccionado
                        file_path = shot.source().mediaSource().fileinfos()[0].filename()
                        debug_print(&quot;Original file path:&quot;, file_path)

                        # Obtener el nombre del plano del path del clip
                        shot_name = self.get_shot_name(file_path)
                        debug_print(&quot;Shot name:&quot;, shot_name)

                        # Cambiar el nombre del plano al clip seleccionado
                        shot.setName(shot_name)
                        debug_print(&quot;Shot name changed successfully.&quot;)
        except Exception as e:
            debug_print(f&quot;Error: {e}&quot;)

    def get_shot_name(self, file_path):
        # Dividir el path en partes usando '/' como separador
        path_parts = file_path.split('/')
        # El shot name seria la tercera parte del path
        shot_name = path_parts[3]
        return shot_name


###### Extend edit
    def extend_edit_to_playhead(self):
        seq = hiero.ui.activeSequence()
        if not seq:
            debug_print(&quot;\nNo active sequence found.&quot;)
            return
            
        te = hiero.ui.getTimelineEditor(seq)
        selected_clips = te.selection()
        
        current_viewer = hiero.ui.currentViewer()
        player = current_viewer.player() if current_viewer else None
        playhead_frame = player.time() if player else None

        if selected_clips and playhead_frame is not None:
            for shot in selected_clips:
                try:
                    shot.setTimelineOut(playhead_frame + 1)
                    debug_print(f&quot;DST Out extended to {playhead_frame + 1} for clip: {shot.name()}&quot;)
                except Exception as e:
                    debug_print(f&quot;Error setting DST Out: {e}&quot;)
        else:
            debug_print(&quot;No clips selected or playhead position unavailable.&quot;)


###### Reconnect
    def reconnect_t_to_n(self):
        try:
            project = hiero.core.projects()[-1]
            project.beginUndo(&quot;Reconnect T &gt; N&quot;)
            try:
                self.reconnect_media(&quot;t:&quot;, &quot;n:&quot;)
            except Exception as e:
                debug_print(f&quot;Error: {e}&quot;)
            project.endUndo()
        except Exception as e:
            debug_print(f&quot;Error: {e}&quot;)

    def reconnect_n_to_t(self):
        try:
            project = hiero.core.projects()[-1]
            with project.beginUndo(&quot;Reconnect N &gt; T&quot;):
                self.reconnect_media(&quot;n:&quot;, &quot;t:&quot;)
        except Exception as e:
            debug_print(f&quot;Error: {e}&quot;)
        finally:
            if project.undoStack().canEnd():
                project.endUndo()
            else:
                debug_print(&quot;No current undo item to end.&quot;)

    def reconnect_media(self, old_prefix, new_prefix):
        try:
            seq = hiero.ui.activeSequence()
            if not seq:
                debug_print(&quot;No active sequence found.&quot;)
                return

            te = hiero.ui.getTimelineEditor(seq)
            selected_clips = te.selection()

            if len(selected_clips) == 0:
                debug_print(&quot;*** No clips selected on the track ***&quot;)
            else:
                for shot in selected_clips:
                    # Obtener el file path del clip seleccionado
                    file_path = shot.source().mediaSource().fileinfos()[0].filename()
                    debug_print(&quot;Original file path:&quot;, file_path)

                    # Normalizar el path convirtiendo todo a minusculas
                    normalized_file_path = file_path.lower()

                    # Reemplazar el prefijo antiguo por el nuevo
                    new_file_path = normalized_file_path.replace(old_prefix, new_prefix)
                    debug_print(&quot;Modified file path:&quot;, new_file_path)

                    # Obtener solo la ruta del directorio sin el nombre del archivo
                    directory_path = os.path.dirname(new_file_path)

                    # Reemplazar el clip por el del nuevo path
                    try:
                        shot.reconnectMedia(directory_path)
                        debug_print(&quot;Clip reconnected successfully.&quot;)
                    except Exception as e:
                        debug_print(f&quot;Error reconnecting clip: {e}&quot;)
        except Exception as e:
            debug_print(f&quot;Error: {e}&quot;)

    def reconnectMediaFromTimeline(self): 
        seq = hiero.ui.activeSequence()
        if not seq:
            debug_print(&quot;\nNo active sequence found.&quot;)
            return
            
        te = hiero.ui.getTimelineEditor(seq)
        selected_track_items = te.selection()

        if len(selected_track_items) == 0:
            debug_print(&quot;*** No track items selected ***&quot;)
            return

        # Obtener la ruta del clip seleccionado
        selected_clip = selected_track_items[0]  # Solo usaremos el primer clip seleccionado
        file_path = selected_clip.source().mediaSource().fileinfos()[0].filename()
        initial_path = os.path.dirname(file_path)

        # Agregar una barra al final del path si no esta presente
        if not initial_path.endswith(&quot;/&quot;):
            initial_path += &quot;/&quot;

        # Abrir el file browser con la ruta inicial del clip seleccionado
        search_path = hiero.ui.openFileBrowser(&quot;Choose directory to search for media&quot;, mode=3, initialPath=initial_path)[0] 

        for track_item in selected_track_items:         
            track_item.reconnectMedia(search_path)






###### Clean Project
    def clean_project(self):
        try:
            clean_action = CleanUnusedAction()
            clean_action.CleanUnused()
        except Exception as e:
            debug_print(f&quot;Error during project cleaning: {e}&quot;)

class CleanUnusedAction:

    def __init__(self):
         pass
         
    # Method to return whether a Bin is empty...
    def binIsEmpty(self,b):
        numBinItems = 0
        bItems = b.items()
        empty = False

        if len(bItems) == 0:
            empty = True
            return empty
        else:
            for b in bItems:
                if isinstance(b,hiero.core.BinItem) or isinstance(b,hiero.core.Bin):
                    numBinItems+=1
            if numBinItems == 0:
                empty = True

        return empty

    def CleanUnused(self) :

        # Get the active project
        project = get_active_project()

        # Build a list of Projects
        SEQS = hiero.core.findItems(project, &quot;Sequences&quot;)

        # Build a list of Clips
        CLIPSTOREMOVE = hiero.core.findItems(project, &quot;Clips&quot;)


        if len(SEQS)==0:
            # Present Dialog Asking if User wants to remove Clips
            msgBox = QMessageBox()
            msgBox.setText(&quot;Clean Unused Clips&quot;);
            msgBox.setInformativeText(&quot;You have no Sequences in this Project. Do you want to remove all Clips (%i) from Project: %s?&quot; % (len(CLIPSTOREMOVE), project.name()));
            msgBox.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel);
            msgBox.setDefaultButton(QMessageBox.Ok);
            ret = msgBox.exec_()
            if ret == QMessageBox.Cancel:
                debug_print('Not purging anything.')
            elif ret == QMessageBox.Ok:
                with project.beginUndo('Clean Unused Clips'):
                    BINS = []
                    for clip in CLIPSTOREMOVE:
                        BI = clip.binItem()
                        B = BI.parentBin()
                        BINS+=[B]
                        debug_print('Removing:', BI)
                        try:
                            B.removeItem(BI)
                        except:
                            debug_print('Unable to remove:', BI)
            return

        # For each sequence, iterate through each track Item, see if the Clip is in the CLIPS list.
        # Remaining items in CLIPS will be removed

        for seq in SEQS:

            #Loop through selected and make folders
            for track in seq:
                for trackitem in track:

                    if trackitem.source() in CLIPSTOREMOVE:
                        CLIPSTOREMOVE.remove(trackitem.source())

        # Present Dialog Asking if User wants to remove Clips
        msgBox = QMessageBox()
        msgBox.setText(&quot;Clean Unused Clips&quot;);
        msgBox.setInformativeText(&quot;Remove %i unused Clips from Project %s?&quot; % (len(CLIPSTOREMOVE), project.name()));
        msgBox.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel);
        msgBox.setDefaultButton(QMessageBox.Ok);
        ret = msgBox.exec_()

        if ret == QMessageBox.Cancel:
             debug_print('Cancel')
             return
        elif ret == QMessageBox.Ok:
            BINS = []
            with project.beginUndo('Clean Unused Clips'):
                # Delete the rest of the Clips
                for clip in CLIPSTOREMOVE:
                    BI = clip.binItem()
                    B = BI.parentBin()
                    BINS+=[B]
                    debug_print('Removing:', BI)
                    try:
                        B.removeItem(BI)
                    except:
                        debug_print('Unable to remove:', BI)

    def eventHandler(self, event):
        if not hasattr(event.sender, 'selection'):
                # Something has gone wrong, we shouldn't only be here if raised
                # by the Bin view which will give a selection.
                return

        self.selectedItem = None
        s = event.sender.selection()

        if len(s)&gt;=1:
            self.selectedItem = s[0]
            title = &quot;Clean Unused Clips&quot;
            self.setText(title)
            event.menu.addAction(self)

        return

def get_active_project():
    &quot;&quot;&quot;
    Obtiene el proyecto activo en Hiero.

    Returns:
    - hiero.core.Project o None: El proyecto activo, o None si no se encuentra ningun proyecto activo.
    &quot;&quot;&quot;
    projects = hiero.core.projects()
    if projects:
        return projects[0]  # Devuelve el primer proyecto en la lista
    else:
        return None


##### Organize Project
class OrganizeProject:
    def find_or_create_bin(self, root_bin, bin_name):
        for item in root_bin.items():
            if isinstance(item, hiero.core.Bin) and item.name() == bin_name:
                return item
        new_bin = hiero.core.Bin(bin_name)
        root_bin.addItem(new_bin)
        return new_bin

    def move_clips_from_bin(self, bin_item):
        if bin_item.name() == &quot;Published&quot;:  # Ignorar el bin 'Published' y sus subcarpetas
            return
        for item in bin_item.items():
            if isinstance(item, hiero.core.BinItem) and isinstance(item.activeItem(), hiero.core.Clip):
                clip = item.activeItem()
                media_source = clip.mediaSource()
                if media_source and media_source.fileinfos():
                    file_path = media_source.fileinfos()[0].filename()
                    parts = file_path.split('/')
                    if len(parts) &gt; 3:
                        folder_name = f&quot;F {parts[2]}&quot;
                        shot_name = parts[3]
                        folder_bin = self.find_or_create_bin(self.project.clipsBin(), folder_name)
                        shot_bin = self.find_or_create_bin(folder_bin, shot_name)
                        clip_item = clip.binItem()
                        if clip_item.parentBin() != shot_bin:
                            clip_item.parentBin().removeItem(clip_item)
                            shot_bin.addItem(clip_item)
            elif isinstance(item, hiero.core.Bin):
                self.move_clips_from_bin(item)

    def clean_empty_bins(self, bin_item):
        if bin_item.name() == &quot;Published&quot;:
            return
        items_to_check = list(bin_item.items())
        for item in items_to_check:
            if isinstance(item, hiero.core.Bin):
                self.clean_empty_bins(item)
        if not bin_item.items() and bin_item.parentBin():
            bin_item.parentBin().removeItem(bin_item)

    def move_clips_based_on_path(self, project):
        self.project = project
        with project.beginUndo('Reorganize Clips Based on Path'):
            for bin_item in project.clipsBin().items():
                if isinstance(bin_item, hiero.core.Bin):
                    self.move_clips_from_bin(bin_item)

            for bin_item in list(project.clipsBin().items()):
                if isinstance(bin_item, hiero.core.Bin):
                    self.clean_empty_bins(bin_item)

    def organize_project(self):
        project = hiero.core.projects()[0] if hiero.core.projects() else None
        if project:
            self.move_clips_based_on_path(project)
        else:
            debug_print(&quot;No se encontro un proyecto abierto en Hiero.&quot;)


# Crear la instancia del widget y anadirlo al gestor de ventanas de Hiero
reconnectWidget = ReconnectMediaWidget()
wm = hiero.ui.windowManager()
wm.addWindow(reconnectWidget)
import hiero.core
import hiero.ui

def set_in_out_from_edit_ref_track():
    # Obtener la secuencia activa
    seq = hiero.ui.activeSequence()
    if not seq:
        print(&quot;No hay una secuencia activa.&quot;)
        return

    # Obtener la posición del playhead
    te = hiero.ui.getTimelineEditor(seq)
    current_viewer = hiero.ui.currentViewer()
    player = current_viewer.player() if current_viewer else None
    playhead_frame = player.time() if player else None

    if playhead_frame is None:
        print(&quot;No se pudo obtener la posición del playhead.&quot;)
        return

    # Buscar el track llamado &quot;EditRef&quot;
    edit_ref_track = None
    for track in seq.videoTracks():
        if track.name() == &quot;EditRef&quot;:
            edit_ref_track = track
            break

    if not edit_ref_track:
        print(&quot;No se encontró un track llamado 'EditRef'.&quot;)
        return

    # Buscar el clip más cercano en el track EditRef
    edit_ref_clip = None
    min_distance = float('inf')
    for item in edit_ref_track.items():
        if item.timelineIn() &lt;= playhead_frame &lt; item.timelineOut():
            edit_ref_clip = item
            break
        else:
            # Calcular la distancia al playhead
            if playhead_frame &lt; item.timelineIn():
                distance = item.timelineIn() - playhead_frame
            else:
                distance = playhead_frame - item.timelineOut()
            if distance &lt; min_distance:
                min_distance = distance
                edit_ref_clip = item

    if not edit_ref_clip:
        print(&quot;No se encontró ningún clip en el track EditRef.&quot;)
        return

    # Obtener el in y out del clip de referencia
    ref_in = edit_ref_clip.timelineIn()
    ref_out = edit_ref_clip.timelineOut()

    # Establecer el in y out de la secuencia
    seq.setInTime(ref_in)
    seq.setOutTime(ref_out)

    print(f&quot;Se ha establecido el in/out de la secuencia a [{ref_in}, {ref_out}] basado en el clip de EditRef más cercano.&quot;)

# Ejecutar la función
set_in_out_from_edit_ref_track()import sys
import os
import hiero.core
import importlib

# Variable global para activar o desactivar los prints de depuración
DEBUG = False

def debug_print(*message):
    if DEBUG:
        print(*message)

# Definir la ruta del script que quieres ejecutar
ScriptPath = &quot;Python/Startup/LGA_NKS/LGA_Reduce_SeqWin.py&quot;

def ejecutar_script(script_path):
    # Obtener la ruta del directorio de plugins de Hiero
    hiero_plugin_paths = hiero.core.pluginPath()

    # Asumimos que el primer path en la tupla es el que necesitamos
    if isinstance(hiero_plugin_paths, tuple) and len(hiero_plugin_paths) &gt; 0:
        hiero_plugin_path = hiero_plugin_paths[0]
    else:
        hiero_plugin_path = hiero_plugin_paths  # En caso de que sea una cadena

    # Construir la ruta al directorio que contiene nuestro script
    script_parts = script_path.split('/')
    script_dir = os.path.join(os.path.dirname(hiero_plugin_path), *script_parts[:-1])
    
    # Añadir el directorio al path de Python si no está ya
    if script_dir not in sys.path:
        sys.path.insert(0, script_dir)

    debug_print(&quot;Python path:&quot;, sys.path)
    debug_print(&quot;Script directory:&quot;, script_dir)
    debug_print(&quot;&quot;)

    # Obtener el nombre del módulo del script
    module_name = os.path.splitext(script_parts[-1])[0]
    package_name = script_parts[-2]

    try:
        # Importar el módulo
        debug_print(f&quot;Intentando importar el módulo: {package_name}.{module_name}&quot;)
        module = importlib.import_module(f&quot;{package_name}.{module_name}&quot;)
        
        # Recargar el módulo
        debug_print(f&quot;Recargando el módulo: {package_name}.{module_name}&quot;)
        module = importlib.reload(module)
        
        debug_print(f&quot;Módulo importado y recargado: {module}&quot;)
        
        # Si el módulo tiene una función main(), ejecutarla
        if hasattr(module, 'main') and callable(module.main):
            debug_print(&quot;Función main() encontrada. Ejecutando...&quot;)
            module.main()
        else:
            debug_print(f&quot;El módulo {module_name} no tiene una función main() ejecutable.&quot;)
            debug_print(&quot;Contenido del módulo:&quot;)
            for attr in dir(module):
                debug_print(f&quot;  {attr}&quot;)
    except Exception as e:
        debug_print(f&quot;Error al importar o ejecutar el módulo: {e}&quot;)
        import traceback
        traceback.print_exc()
        
        debug_print(f&quot;Asegúrate de que el archivo {script_parts[-1]} está en {script_dir}&quot;)
        
        # Listar los contenidos del directorio para depuración
        debug_print(&quot;Contenidos del directorio:&quot;)
        for root, dirs, files in os.walk(script_dir):
            for file in files:
                debug_print(os.path.join(root, file))

# Ejecutar el script
ejecutar_script(ScriptPath)import sys
import os
import hiero.core
import importlib

# Variable global para activar o desactivar los prints de depuración
DEBUG = False

def debug_print(*message):
    if DEBUG:
        print(*message)

# Definir la ruta del script que quieres ejecutar
ScriptPath = &quot;Python/Startup/LGA_NKS/LGA_NKS_Timeline_Zoom.py&quot;

def ejecutar_script(script_path):
    # Obtener la ruta del directorio de plugins de Hiero
    hiero_plugin_paths = hiero.core.pluginPath()

    # Asumimos que el primer path en la tupla es el que necesitamos
    if isinstance(hiero_plugin_paths, tuple) and len(hiero_plugin_paths) &gt; 0:
        hiero_plugin_path = hiero_plugin_paths[0]
    else:
        hiero_plugin_path = hiero_plugin_paths  # En caso de que sea una cadena

    # Construir la ruta al directorio que contiene nuestro script
    script_parts = script_path.split('/')
    script_dir = os.path.join(os.path.dirname(hiero_plugin_path), *script_parts[:-1])
    
    # Añadir el directorio al path de Python si no está ya
    if script_dir not in sys.path:
        sys.path.insert(0, script_dir)

    debug_print(&quot;Python path:&quot;, sys.path)
    debug_print(&quot;Script directory:&quot;, script_dir)
    debug_print(&quot;&quot;)

    # Obtener el nombre del módulo del script
    module_name = os.path.splitext(script_parts[-1])[0]
    package_name = script_parts[-2]

    try:
        # Importar el módulo
        debug_print(f&quot;Intentando importar el módulo: {package_name}.{module_name}&quot;)
        module = importlib.import_module(f&quot;{package_name}.{module_name}&quot;)
        
        # Recargar el módulo
        debug_print(f&quot;Recargando el módulo: {package_name}.{module_name}&quot;)
        module = importlib.reload(module)
        
        debug_print(f&quot;Módulo importado y recargado: {module}&quot;)
        
        # Si el módulo tiene una función main(), ejecutarla
        if hasattr(module, 'main') and callable(module.main):
            debug_print(&quot;Función main() encontrada. Ejecutando...&quot;)
            module.main()
        else:
            debug_print(f&quot;El módulo {module_name} no tiene una función main() ejecutable.&quot;)
            debug_print(&quot;Contenido del módulo:&quot;)
            for attr in dir(module):
                debug_print(f&quot;  {attr}&quot;)
    except Exception as e:
        debug_print(f&quot;Error al importar o ejecutar el módulo: {e}&quot;)
        import traceback
        traceback.print_exc()
        
        debug_print(f&quot;Asegúrate de que el archivo {script_parts[-1]} está en {script_dir}&quot;)
        
        # Listar los contenidos del directorio para depuración
        debug_print(&quot;Contenidos del directorio:&quot;)
        for root, dirs, files in os.walk(script_dir):
            for file in files:
                debug_print(os.path.join(root, file))

# Ejecutar el script
ejecutar_script(ScriptPath)import sys
import os
import hiero.core
import importlib

# Variable global para activar o desactivar los prints de depuración
DEBUG = False

def debug_print(*message):
    if DEBUG:
        print(*message)

# Definir la ruta del script que quieres ejecutar
ScriptPath = &quot;Python/Startup/LGA_NKS/LGA_NKS_Timeline_Zoom.py&quot;

def ejecutar_script(script_path):
    # Obtener la ruta del directorio de plugins de Hiero
    hiero_plugin_paths = hiero.core.pluginPath()

    # Asumimos que el primer path en la tupla es el que necesitamos
    if isinstance(hiero_plugin_paths, tuple) and len(hiero_plugin_paths) &gt; 0:
        hiero_plugin_path = hiero_plugin_paths[0]
    else:
        hiero_plugin_path = hiero_plugin_paths  # En caso de que sea una cadena

    # Construir la ruta al directorio que contiene nuestro script
    script_parts = script_path.split('/')
    script_dir = os.path.join(os.path.dirname(hiero_plugin_path), *script_parts[:-1])
    
    # Añadir el directorio al path de Python si no está ya
    if script_dir not in sys.path:
        sys.path.insert(0, script_dir)

    debug_print(&quot;Python path:&quot;, sys.path)
    debug_print(&quot;Script directory:&quot;, script_dir)
    debug_print(&quot;&quot;)

    # Obtener el nombre del módulo del script
    module_name = os.path.splitext(script_parts[-1])[0]
    package_name = script_parts[-2]

    try:
        # Importar el módulo
        debug_print(f&quot;Intentando importar el módulo: {package_name}.{module_name}&quot;)
        module = importlib.import_module(f&quot;{package_name}.{module_name}&quot;)
        
        # Recargar el módulo
        debug_print(f&quot;Recargando el módulo: {package_name}.{module_name}&quot;)
        module = importlib.reload(module)
        
        debug_print(f&quot;Módulo importado y recargado: {module}&quot;)
        
        # Si el módulo tiene una función main(), ejecutarla
        if hasattr(module, 'main') and callable(module.main):
            debug_print(&quot;Función main() encontrada. Ejecutando...&quot;)
            module.main()
        else:
            debug_print(f&quot;El módulo {module_name} no tiene una función main() ejecutable.&quot;)
            debug_print(&quot;Contenido del módulo:&quot;)
            for attr in dir(module):
                debug_print(f&quot;  {attr}&quot;)
    except Exception as e:
        debug_print(f&quot;Error al importar o ejecutar el módulo: {e}&quot;)
        import traceback
        traceback.print_exc()
        
        debug_print(f&quot;Asegúrate de que el archivo {script_parts[-1]} está en {script_dir}&quot;)
        
        # Listar los contenidos del directorio para depuración
        debug_print(&quot;Contenidos del directorio:&quot;)
        for root, dirs, files in os.walk(script_dir):
            for file in files:
                debug_print(os.path.join(root, file))

# Ejecutar el script
ejecutar_script(ScriptPath)import sys
import os
import hiero.core
import importlib

# Variable global para activar o desactivar los prints de depuración
DEBUG = False

def debug_print(*message):
    if DEBUG:
        print(*message)

# Definir la ruta del script que quieres ejecutar
ScriptPath = &quot;Python/Startup/LGA_NKS/LGA_NKS_Explore_Zoom_Scroll.py&quot;

def ejecutar_script(script_path):
    # Obtener la ruta del directorio de plugins de Hiero
    hiero_plugin_paths = hiero.core.pluginPath()

    # Asumimos que el primer path en la tupla es el que necesitamos
    if isinstance(hiero_plugin_paths, tuple) and len(hiero_plugin_paths) &gt; 0:
        hiero_plugin_path = hiero_plugin_paths[0]
    else:
        hiero_plugin_path = hiero_plugin_paths  # En caso de que sea una cadena

    # Construir la ruta al directorio que contiene nuestro script
    script_parts = script_path.split('/')
    script_dir = os.path.join(os.path.dirname(hiero_plugin_path), *script_parts[:-1])
    
    # Añadir el directorio al path de Python si no está ya
    if script_dir not in sys.path:
        sys.path.insert(0, script_dir)

    debug_print(&quot;Python path:&quot;, sys.path)
    debug_print(&quot;Script directory:&quot;, script_dir)
    debug_print(&quot;&quot;)

    # Obtener el nombre del módulo del script
    module_name = os.path.splitext(script_parts[-1])[0]
    package_name = script_parts[-2]

    try:
        # Importar el módulo
        debug_print(f&quot;Intentando importar el módulo: {package_name}.{module_name}&quot;)
        module = importlib.import_module(f&quot;{package_name}.{module_name}&quot;)
        
        # Recargar el módulo
        debug_print(f&quot;Recargando el módulo: {package_name}.{module_name}&quot;)
        module = importlib.reload(module)
        
        debug_print(f&quot;Módulo importado y recargado: {module}&quot;)
        
        # Si el módulo tiene una función main(), ejecutarla
        if hasattr(module, 'main') and callable(module.main):
            debug_print(&quot;Función main() encontrada. Ejecutando...&quot;)
            module.main()
        else:
            debug_print(f&quot;El módulo {module_name} no tiene una función main() ejecutable.&quot;)
            debug_print(&quot;Contenido del módulo:&quot;)
            for attr in dir(module):
                debug_print(f&quot;  {attr}&quot;)
    except Exception as e:
        debug_print(f&quot;Error al importar o ejecutar el módulo: {e}&quot;)
        import traceback
        traceback.print_exc()
        
        debug_print(f&quot;Asegúrate de que el archivo {script_parts[-1]} está en {script_dir}&quot;)
        
        # Listar los contenidos del directorio para depuración
        debug_print(&quot;Contenidos del directorio:&quot;)
        for root, dirs, files in os.walk(script_dir):
            for file in files:
                debug_print(os.path.join(root, file))

# Ejecutar el script
ejecutar_script(ScriptPath)import sys
import os
import hiero.core
import importlib

# Variable global para activar o desactivar los prints de depuración
DEBUG = False

def debug_print(*message):
    if DEBUG:
        print(*message)

# Definir la ruta del script que quieres ejecutar
ScriptPath = &quot;Python/Startup/LGA_NKS/LGA_NKS_InOut_Editref.py&quot;

def ejecutar_script(script_path):
    # Obtener la ruta del directorio de plugins de Hiero
    hiero_plugin_paths = hiero.core.pluginPath()

    # Asumimos que el primer path en la tupla es el que necesitamos
    if isinstance(hiero_plugin_paths, tuple) and len(hiero_plugin_paths) &gt; 0:
        hiero_plugin_path = hiero_plugin_paths[0]
    else:
        hiero_plugin_path = hiero_plugin_paths  # En caso de que sea una cadena

    # Construir la ruta al directorio que contiene nuestro script
    script_parts = script_path.split('/')
    script_dir = os.path.join(os.path.dirname(hiero_plugin_path), *script_parts[:-1])
    
    # Añadir el directorio al path de Python si no está ya
    if script_dir not in sys.path:
        sys.path.insert(0, script_dir)

    debug_print(&quot;Python path:&quot;, sys.path)
    debug_print(&quot;Script directory:&quot;, script_dir)
    debug_print(&quot;&quot;)

    # Obtener el nombre del módulo del script
    module_name = os.path.splitext(script_parts[-1])[0]
    package_name = script_parts[-2]

    try:
        # Importar el módulo
        debug_print(f&quot;Intentando importar el módulo: {package_name}.{module_name}&quot;)
        module = importlib.import_module(f&quot;{package_name}.{module_name}&quot;)
        
        # Recargar el módulo
        debug_print(f&quot;Recargando el módulo: {package_name}.{module_name}&quot;)
        module = importlib.reload(module)
        
        debug_print(f&quot;Módulo importado y recargado: {module}&quot;)
        
        # Si el módulo tiene una función main(), ejecutarla
        if hasattr(module, 'main') and callable(module.main):
            debug_print(&quot;Función main() encontrada. Ejecutando...&quot;)
            module.main()
        else:
            debug_print(f&quot;El módulo {module_name} no tiene una función main() ejecutable.&quot;)
            debug_print(&quot;Contenido del módulo:&quot;)
            for attr in dir(module):
                debug_print(f&quot;  {attr}&quot;)
    except Exception as e:
        debug_print(f&quot;Error al importar o ejecutar el módulo: {e}&quot;)
        import traceback
        traceback.print_exc()
        
        debug_print(f&quot;Asegúrate de que el archivo {script_parts[-1]} está en {script_dir}&quot;)
        
        # Listar los contenidos del directorio para depuración
        debug_print(&quot;Contenidos del directorio:&quot;)
        for root, dirs, files in os.walk(script_dir):
            for file in files:
                debug_print(os.path.join(root, file))

# Ejecutar el script
ejecutar_script(ScriptPath)import sys
import os
import hiero.core
import importlib

# Variable global para activar o desactivar los prints de depuración
DEBUG = False

def debug_print(*message):
    if DEBUG:
        print(*message)

# Definir la ruta del script que quieres ejecutar
ScriptPath = &quot;Python/Startup/LGA_NKS/LGA_NKS_Next_RevLega.py&quot;

def ejecutar_script(script_path):
    # Obtener la ruta del directorio de plugins de Hiero
    hiero_plugin_paths = hiero.core.pluginPath()

    # Asumimos que el primer path en la tupla es el que necesitamos
    if isinstance(hiero_plugin_paths, tuple) and len(hiero_plugin_paths) &gt; 0:
        hiero_plugin_path = hiero_plugin_paths[0]
    else:
        hiero_plugin_path = hiero_plugin_paths  # En caso de que sea una cadena

    # Construir la ruta al directorio que contiene nuestro script
    script_parts = script_path.split('/')
    script_dir = os.path.join(os.path.dirname(hiero_plugin_path), *script_parts[:-1])
    
    # Añadir el directorio al path de Python si no está ya
    if script_dir not in sys.path:
        sys.path.insert(0, script_dir)

    debug_print(&quot;Python path:&quot;, sys.path)
    debug_print(&quot;Script directory:&quot;, script_dir)
    debug_print(&quot;&quot;)

    # Obtener el nombre del módulo del script
    module_name = os.path.splitext(script_parts[-1])[0]
    package_name = script_parts[-2]

    try:
        # Importar el módulo
        debug_print(f&quot;Intentando importar el módulo: {package_name}.{module_name}&quot;)
        module = importlib.import_module(f&quot;{package_name}.{module_name}&quot;)
        
        # Recargar el módulo
        debug_print(f&quot;Recargando el módulo: {package_name}.{module_name}&quot;)
        module = importlib.reload(module)
        
        debug_print(f&quot;Módulo importado y recargado: {module}&quot;)
        
        # Si el módulo tiene una función main(), ejecutarla
        if hasattr(module, 'main') and callable(module.main):
            debug_print(&quot;Función main() encontrada. Ejecutando...&quot;)
            module.main()
        else:
            debug_print(f&quot;El módulo {module_name} no tiene una función main() ejecutable.&quot;)
            debug_print(&quot;Contenido del módulo:&quot;)
            for attr in dir(module):
                debug_print(f&quot;  {attr}&quot;)
    except Exception as e:
        debug_print(f&quot;Error al importar o ejecutar el módulo: {e}&quot;)
        import traceback
        traceback.print_exc()
        
        debug_print(f&quot;Asegúrate de que el archivo {script_parts[-1]} está en {script_dir}&quot;)
        
        # Listar los contenidos del directorio para depuración
        debug_print(&quot;Contenidos del directorio:&quot;)
        for root, dirs, files in os.walk(script_dir):
            for file in files:
                debug_print(os.path.join(root, file))

# Ejecutar el script
ejecutar_script(ScriptPath)import sys
import os
import hiero.core
import importlib

# Variable global para activar o desactivar los prints de depuración
DEBUG = False

def debug_print(*message):
    if DEBUG:
        print(*message)

# Definir la ruta del script que quieres ejecutar
ScriptPath = &quot;Python/Startup/LGA_NKS/LGA_NKS_Next_RevLega.py&quot;

def ejecutar_script(script_path):
    # Obtener la ruta del directorio de plugins de Hiero
    hiero_plugin_paths = hiero.core.pluginPath()

    # Asumimos que el primer path en la tupla es el que necesitamos
    if isinstance(hiero_plugin_paths, tuple) and len(hiero_plugin_paths) &gt; 0:
        hiero_plugin_path = hiero_plugin_paths[0]
    else:
        hiero_plugin_path = hiero_plugin_paths  # En caso de que sea una cadena

    # Construir la ruta al directorio que contiene nuestro script
    script_parts = script_path.split('/')
    script_dir = os.path.join(os.path.dirname(hiero_plugin_path), *script_parts[:-1])
    
    # Añadir el directorio al path de Python si no está ya
    if script_dir not in sys.path:
        sys.path.insert(0, script_dir)

    debug_print(&quot;Python path:&quot;, sys.path)
    debug_print(&quot;Script directory:&quot;, script_dir)
    debug_print(&quot;&quot;)

    # Obtener el nombre del módulo del script
    module_name = os.path.splitext(script_parts[-1])[0]
    package_name = script_parts[-2]

    try:
        # Importar el módulo
        debug_print(f&quot;Intentando importar el módulo: {package_name}.{module_name}&quot;)
        module = importlib.import_module(f&quot;{package_name}.{module_name}&quot;)
        
        # Recargar el módulo
        debug_print(f&quot;Recargando el módulo: {package_name}.{module_name}&quot;)
        module = importlib.reload(module)
        
        debug_print(f&quot;Módulo importado y recargado: {module}&quot;)
        
        # Si el módulo tiene una función main(), ejecutarla
        if hasattr(module, 'main') and callable(module.main):
            debug_print(&quot;Función main() encontrada. Ejecutando...&quot;)
            module.main()
        else:
            debug_print(f&quot;El módulo {module_name} no tiene una función main() ejecutable.&quot;)
            debug_print(&quot;Contenido del módulo:&quot;)
            for attr in dir(module):
                debug_print(f&quot;  {attr}&quot;)
    except Exception as e:
        debug_print(f&quot;Error al importar o ejecutar el módulo: {e}&quot;)
        import traceback
        traceback.print_exc()
        
        debug_print(f&quot;Asegúrate de que el archivo {script_parts[-1]} está en {script_dir}&quot;)
        
        # Listar los contenidos del directorio para depuración
        debug_print(&quot;Contenidos del directorio:&quot;)
        for root, dirs, files in os.walk(script_dir):
            for file in files:
                debug_print(os.path.join(root, file))

# Ejecutar el script
ejecutar_script(ScriptPath)import sys
import os
import importlib

# Variable global para activar o desactivar los prints de depuración
DEBUG = False

def debug_print(*message):
    if DEBUG:
        print(*message)

# Definir la ruta del script que quieres ejecutar
ScriptPath = &quot;LGA_preRender2.py&quot;

def obtener_plugin_path(script_path):
    &quot;&quot;&quot;
    Determina la ruta del plugin dependiendo si es Hiero o Nuke.
    - En Hiero: usa hiero.core.pluginPath()
    - En Nuke: usa la ruta del script
    &quot;&quot;&quot;
    try:
        import hiero.core
        # Intentar obtener la ruta de plugins de Hiero
        hiero_plugin_paths = hiero.core.pluginPath()
        if isinstance(hiero_plugin_paths, (tuple, list)) and len(hiero_plugin_paths) &gt; 0:
            return hiero_plugin_paths[0]
        return hiero_plugin_paths
    except (ImportError, NotImplementedError):
        # Si no estamos en Hiero o pluginPath no está disponible, usar la ruta del script
        return os.path.dirname(os.path.abspath(script_path))

def ejecutar_script(script_path):
    plugin_path = obtener_plugin_path(script_path)
    
    # Construir la ruta al directorio que contiene nuestro script
    script_dir = os.path.join(plugin_path, os.path.dirname(script_path))
    
    # Normalizar la ruta
    script_dir = os.path.normpath(script_dir)
    
    # Añadir el directorio al path de Python si no está ya
    if script_dir not in sys.path:
        sys.path.insert(0, script_dir)
    
    debug_print(&quot;Python path:&quot;, sys.path)
    debug_print(&quot;Script directory:&quot;, script_dir)
    debug_print(&quot;&quot;)
    
    # Obtener el nombre del módulo del script
    module_name = os.path.splitext(os.path.basename(script_path))[0]
    
    try:
        # Importar el módulo
        debug_print(f&quot;Intentando importar el módulo: {module_name}&quot;)
        module = importlib.import_module(module_name)
        
        # Recargar el módulo
        debug_print(f&quot;Recargando el módulo: {module_name}&quot;)
        module = importlib.reload(module)
        
        debug_print(f&quot;Módulo importado y recargado: {module}&quot;)
        
        # Si el módulo tiene una función main(), ejecutarla
        if hasattr(module, 'main') and callable(module.main):
            debug_print(&quot;Función main() encontrada. Ejecutando...&quot;)
            module.main()
        else:
            debug_print(f&quot;El módulo {module_name} no tiene una función main() ejecutable.&quot;)
            debug_print(&quot;Contenido del módulo:&quot;)
            for attr in dir(module):
                debug_print(f&quot;  {attr}&quot;)
    except Exception as e:
        debug_print(f&quot;Error al importar o ejecutar el módulo: {e}&quot;)
        import traceback
        traceback.print_exc()
        
        debug_print(f&quot;Asegúrate de que el archivo {os.path.basename(script_path)} está en {script_dir}&quot;)
        
        # Listar los contenidos del directorio para depuración
        debug_print(&quot;Contenidos del directorio:&quot;)
        try:
            for root, dirs, files in os.walk(script_dir):
                for file in files:
                    debug_print(os.path.join(root, file))
        except Exception as walk_error:
            debug_print(f&quot;Error al listar el directorio: {walk_error}&quot;)

# Ejecutar el script
ejecutar_script(ScriptPath)
</script>
