<?xml version="1.0" encoding="UTF-8"?><script>'''
LGA_StickyNote.py - Script simple para mostrar un diálogo de entrada de texto
'''

import nuke
from PySide2 import QtWidgets, QtGui, QtCore


class StickyNote(QtWidgets.QDialog):
    def __init__(self):
        super(StickyNote, self).__init__()
        
        self.text_edit = QtWidgets.QTextEdit()
        self.text_edit.setAlignment(QtCore.Qt.AlignCenter)
        self.title = QtWidgets.QLabel(&quot;&lt;b&gt;StickyNote&lt;/b&gt;&quot;)
        self.title.setAlignment(QtCore.Qt.AlignCenter)
        self.title.setStyleSheet(&quot;color: #AAAAAA;&quot;)

        self.help = QtWidgets.QLabel('&lt;span style=&quot;font-size:7pt; color:#AAAAAA;&quot;&gt;Ctrl+Enter para confirmar&lt;/span&gt;')
        self.help.setAlignment(QtCore.Qt.AlignCenter)

        self.layout = QtWidgets.QVBoxLayout()
        self.layout.addWidget(self.title)
        self.layout.addWidget(self.text_edit)
        self.layout.addWidget(self.help)
        self.setLayout(self.layout)
        self.resize(200, 150)
        self.setStyleSheet(&quot;background-color: #242527;&quot;)
        self.setWindowFlags(QtCore.Qt.FramelessWindowHint | QtCore.Qt.WindowStaysOnTopHint)

        self.text_edit.installEventFilter(self)
        
    def eventFilter(self, widget, event):
        if isinstance(event, QtGui.QKeyEvent):
            if event.key() == QtCore.Qt.Key_Return and event.modifiers() == QtCore.Qt.ControlModifier:
                print(&quot;Texto ingresado:&quot;, self.text_edit.toPlainText())
                self.close()
                return True
            elif event.key() == QtCore.Qt.Key_Escape:
                print(&quot;Se presionó ESC para salir&quot;)
                self.close()
                return True
        return False
    
    def showEvent(self, event):
        &quot;&quot;&quot;Se llama cuando el diálogo se muestra&quot;&quot;&quot;
        super().showEvent(event)
        self.activateWindow()  # Activar la ventana
        self.raise_()          # Traer al frente
        self.text_edit.setFocus()  # Dar foco al text_edit

    def run(self):
        # Usar QApplication.primaryScreen() en lugar de QDesktopWidget
        cursor_pos = QtGui.QCursor.pos()
        screen = QtWidgets.QApplication.primaryScreen()
        avail_space = screen.availableGeometry()
        
        posx = min(max(cursor_pos.x()-100, avail_space.left()), avail_space.right()-200)
        posy = min(max(cursor_pos.y()-80, avail_space.top()), avail_space.bottom()-150)
        
        self.move(QtCore.QPoint(posx, posy))
        self.text_edit.clear()
        self.activateWindow()  # Asegurar que la ventana está activa
        self.raise_()          # Traer al frente
        self.text_edit.setFocus()
        self.show()


# Variables globales
app = None
sticky_note = None

def main():
    &quot;&quot;&quot;Función principal para mostrar el diálogo de StickyNote.&quot;&quot;&quot;
    global app, sticky_note
    app = QtWidgets.QApplication.instance() or QtWidgets.QApplication([])
    sticky_note = StickyNote()
    sticky_note.run()

# Para uso en Nuke (no crea una nueva QApplication)
def run_sticky_note():
    &quot;&quot;&quot;Mostrar el StickyNote dentro de Nuke&quot;&quot;&quot;
    global sticky_note
    if sticky_note is None:
        sticky_note = StickyNote()
    sticky_note.run()

# Ejecutar cuando se carga en Nuke
run_sticky_note() import sys
import os
import importlib

# Variable global para activar o desactivar los prints de depuración
DEBUG = False

def debug_print(*message):
    if DEBUG:
        print(*message)

# Definir la ruta del script que quieres ejecutar
ScriptPath = &quot;LGA_StickyNote.py&quot;

def obtener_plugin_path(script_path):
    &quot;&quot;&quot;
    Determina la ruta del plugin dependiendo si es Hiero o Nuke.
    - En Hiero: usa hiero.core.pluginPath()
    - En Nuke: usa la ruta del script
    &quot;&quot;&quot;
    try:
        import hiero.core
        # Intentar obtener la ruta de plugins de Hiero
        hiero_plugin_paths = hiero.core.pluginPath()
        if isinstance(hiero_plugin_paths, (tuple, list)) and len(hiero_plugin_paths) &gt; 0:
            return hiero_plugin_paths[0]
        return hiero_plugin_paths
    except (ImportError, NotImplementedError):
        # Si no estamos en Hiero o pluginPath no está disponible, usar la ruta del script
        return os.path.dirname(os.path.abspath(script_path))

def ejecutar_script(script_path):
    plugin_path = obtener_plugin_path(script_path)
    
    # Construir la ruta al directorio que contiene nuestro script
    script_dir = os.path.join(plugin_path, os.path.dirname(script_path))
    
    # Normalizar la ruta
    script_dir = os.path.normpath(script_dir)
    
    # Añadir el directorio al path de Python si no está ya
    if script_dir not in sys.path:
        sys.path.insert(0, script_dir)
    
    debug_print(&quot;Python path:&quot;, sys.path)
    debug_print(&quot;Script directory:&quot;, script_dir)
    debug_print(&quot;&quot;)
    
    # Obtener el nombre del módulo del script
    module_name = os.path.splitext(os.path.basename(script_path))[0]
    
    try:
        # Importar el módulo
        debug_print(f&quot;Intentando importar el módulo: {module_name}&quot;)
        module = importlib.import_module(module_name)
        
        # Recargar el módulo
        debug_print(f&quot;Recargando el módulo: {module_name}&quot;)
        module = importlib.reload(module)
        
        debug_print(f&quot;Módulo importado y recargado: {module}&quot;)
        
        # Si el módulo tiene una función main(), ejecutarla
        if hasattr(module, 'main') and callable(module.main):
            debug_print(&quot;Función main() encontrada. Ejecutando...&quot;)
            module.main()
        else:
            debug_print(f&quot;El módulo {module_name} no tiene una función main() ejecutable.&quot;)
            debug_print(&quot;Contenido del módulo:&quot;)
            for attr in dir(module):
                debug_print(f&quot;  {attr}&quot;)
    except Exception as e:
        debug_print(f&quot;Error al importar o ejecutar el módulo: {e}&quot;)
        import traceback
        traceback.print_exc()
        
        debug_print(f&quot;Asegúrate de que el archivo {os.path.basename(script_path)} está en {script_dir}&quot;)
        
        # Listar los contenidos del directorio para depuración
        debug_print(&quot;Contenidos del directorio:&quot;)
        try:
            for root, dirs, files in os.walk(script_dir):
                for file in files:
                    debug_print(os.path.join(root, file))
        except Exception as walk_error:
            debug_print(f&quot;Error al listar el directorio: {walk_error}&quot;)

# Ejecutar el script
ejecutar_script(ScriptPath)
import sys
import os
import importlib

# Variable global para activar o desactivar los prints de depuración
DEBUG = False

def debug_print(*message):
    if DEBUG:
        print(*message)

# Definir la ruta del script que quieres ejecutar
ScriptPath = &quot;LGA_StickyNote.py&quot;

def obtener_plugin_path(script_path):
    &quot;&quot;&quot;
    Determina la ruta del plugin dependiendo si es Hiero o Nuke.
    - En Hiero: usa hiero.core.pluginPath()
    - En Nuke: usa la ruta del script
    &quot;&quot;&quot;
    try:
        import hiero.core
        # Intentar obtener la ruta de plugins de Hiero
        hiero_plugin_paths = hiero.core.pluginPath()
        if isinstance(hiero_plugin_paths, (tuple, list)) and len(hiero_plugin_paths) &gt; 0:
            return hiero_plugin_paths[0]
        return hiero_plugin_paths
    except (ImportError, NotImplementedError):
        # Si no estamos en Hiero o pluginPath no está disponible, usar la ruta del script
        return os.path.dirname(os.path.abspath(script_path))

def ejecutar_script(script_path):
    plugin_path = obtener_plugin_path(script_path)
    
    # Construir la ruta al directorio que contiene nuestro script
    script_dir = os.path.join(plugin_path, os.path.dirname(script_path))
    
    # Normalizar la ruta
    script_dir = os.path.normpath(script_dir)
    
    # Añadir el directorio al path de Python si no está ya
    if script_dir not in sys.path:
        sys.path.insert(0, script_dir)
    
    debug_print(&quot;Python path:&quot;, sys.path)
    debug_print(&quot;Script directory:&quot;, script_dir)
    debug_print(&quot;&quot;)
    
    # Obtener el nombre del módulo del script
    module_name = os.path.splitext(os.path.basename(script_path))[0]
    
    try:
        # Importar el módulo
        debug_print(f&quot;Intentando importar el módulo: {module_name}&quot;)
        module = importlib.import_module(module_name)
        
        # Recargar el módulo
        debug_print(f&quot;Recargando el módulo: {module_name}&quot;)
        module = importlib.reload(module)
        
        debug_print(f&quot;Módulo importado y recargado: {module}&quot;)
        
        # Si el módulo tiene una función main(), ejecutarla
        if hasattr(module, 'main') and callable(module.main):
            debug_print(&quot;Función main() encontrada. Ejecutando...&quot;)
            module.main()
        else:
            debug_print(f&quot;El módulo {module_name} no tiene una función main() ejecutable.&quot;)
            debug_print(&quot;Contenido del módulo:&quot;)
            for attr in dir(module):
                debug_print(f&quot;  {attr}&quot;)
    except Exception as e:
        debug_print(f&quot;Error al importar o ejecutar el módulo: {e}&quot;)
        import traceback
        traceback.print_exc()
        
        debug_print(f&quot;Asegúrate de que el archivo {os.path.basename(script_path)} está en {script_dir}&quot;)
        
        # Listar los contenidos del directorio para depuración
        debug_print(&quot;Contenidos del directorio:&quot;)
        try:
            for root, dirs, files in os.walk(script_dir):
                for file in files:
                    debug_print(os.path.join(root, file))
        except Exception as walk_error:
            debug_print(f&quot;Error al listar el directorio: {walk_error}&quot;)

# Ejecutar el script
ejecutar_script(ScriptPath)
#!/usr/bin/env python
# -*- coding: utf-8 -*-

&quot;&quot;&quot;
LGA_NKS_Trim_In v1.0
Script para recortar el material antes del playhead en clips seleccionados.
El clip se recorta tanto en el source como en el timeline, eliminando los frames antes del playhead
y manteniendo la relación 1:1 para evitar retimes.
Si el playhead está antes del inicio del clip, extiende el clip hasta el límite mínimo posible.
&quot;&quot;&quot;

import hiero.core
import hiero.ui
from PySide2.QtWidgets import QAction
from PySide2.QtGui import QIcon

# Configurar depuración
DEBUG = True

def debug_print(message):
    &quot;&quot;&quot;Imprime mensajes de depuración si DEBUG está activado.&quot;&quot;&quot;
    if DEBUG:
        print(message)

def print_clip_properties(clip):
    &quot;&quot;&quot;Imprime todas las propiedades relevantes de un clip para debugging.&quot;&quot;&quot;
    if not DEBUG:
        return
    
    try:
        # Información sobre el clip en el timeline
        debug_print(&quot;\n=== PROPIEDADES DEL CLIP ===&quot;)
        debug_print(f&quot;Nombre: {clip.name()}&quot;)
        debug_print(f&quot;Timeline In: {clip.timelineIn()}&quot;)
        debug_print(f&quot;Timeline Out: {clip.timelineOut()}&quot;)
        debug_print(f&quot;Timeline Duration: {clip.duration()}&quot;)
        
        # Información sobre el source del clip
        debug_print(f&quot;Source In: {clip.sourceIn()}&quot;)
        debug_print(f&quot;Source Out: {clip.sourceOut()}&quot;)
        debug_print(f&quot;Source Duration: {clip.sourceDuration()}&quot;)
        
        # Obtener el source item (MediaSource)
        source_item = clip.source()
        if source_item:
            debug_print(f&quot;Media Source: {source_item.name()}&quot;)
            debug_print(f&quot;Media File Path: {source_item.mediaSource().fileinfos()[0].filename()}&quot;)
            debug_print(f&quot;Media Duration: {source_item.duration()}&quot;)
            debug_print(f&quot;Media Start Time: {source_item.sourceIn()}&quot;)
            debug_print(f&quot;Media End Time: {source_item.sourceOut()}&quot;)
            
        # Información sobre el playback speed
        debug_print(f&quot;Playback Speed: {clip.playbackSpeed()}&quot;)
        
        # Espacio adicional para separar clips
        debug_print(&quot;=============================\n&quot;)
    except Exception as e:
        debug_print(f&quot;Error al imprimir propiedades del clip: {e}&quot;)

class TrimInToPlayhead:
    &quot;&quot;&quot;
    Clase para manejar el recorte del material antes del playhead en el timeline de Nuke Studio (Hiero).
    &quot;&quot;&quot;
    
    def __init__(self):
        &quot;&quot;&quot;Inicializa el objeto y crea las acciones del menú.&quot;&quot;&quot;
        self.setup_actions()
    
    def setup_actions(self):
        &quot;&quot;&quot;Configura las acciones del menú.&quot;&quot;&quot;
        self.trim_in_action = QAction(&quot;Trim In to Playhead&quot;, None)
        self.trim_in_action.triggered.connect(self.trim_in_to_playhead)
        
        # Registrar acción en el menú Timeline
        hiero.core.events.registerInterest(&quot;kShowContextMenu/kTimeline&quot;, self.timeline_context_menu)
        
        # También podemos agregar un atajo de teclado si es necesario
        # self.trim_in_action.setShortcut(&quot;Ctrl+T&quot;)
    
    def timeline_context_menu(self, event):
        &quot;&quot;&quot;Añade nuestra acción al menú contextual del timeline.&quot;&quot;&quot;
        contextMenu = event.menu
        contextMenu.addAction(self.trim_in_action)
    
    def check_for_overlapping_items(self, track, current_item, new_in):
        &quot;&quot;&quot;
        Verifica si hay clips que se superpondrían con el nuevo in point.
        
        Args:
            track: La pista donde está el clip
            current_item: El clip actual que estamos modificando
            new_in: El nuevo valor de in point
            
        Returns:
            bool: True si hay superposición, False si no
        &quot;&quot;&quot;
        try:
            # Aseguramos que new_in sea un entero
            new_in = int(new_in)
            
            items = track.items()
            for item in items:
                if item != current_item:  # No comparar con el mismo clip
                    # Verifica si el nuevo in point superpondría con el final del clip anterior
                    if item.timelineIn() &lt; new_in and new_in &lt;= item.timelineOut():
                        debug_print(f&quot;Superposición detectada con clip: {item.name()} ({item.timelineIn()}-{item.timelineOut()})&quot;)
                        return True
            return False
        except Exception as e:
            debug_print(f&quot;Error al verificar superposiciones: {e}&quot;)
            return False
    
    def get_min_possible_timeline_in(self, clip):
        &quot;&quot;&quot;
        Calcula el mínimo in point posible teniendo en cuenta:
        1. El media source (duración del archivo)
        2. El clip anterior en la misma pista (para evitar superposiciones)
        
        Args:
            clip: El clip que estamos analizando
            
        Returns:
            int: El mínimo valor posible para timeline in
        &quot;&quot;&quot;
        try:
            # Obtenemos información del timeline
            timeline_in = clip.timelineIn()
            timeline_out = clip.timelineOut()
            source_in = clip.sourceIn()
            source_out = clip.sourceOut()
            
            # Obtenemos información del media source
            source_item = clip.source()
            if not source_item:
                debug_print(&quot;No se pudo obtener el source item del clip&quot;)
                return None
                
            # Obtenemos los límites del media source
            media_start = source_item.sourceIn()  # Típicamente 1001 para secuencias EXR
            media_end = source_item.sourceOut()
            
            # Calculamos cuántos frames hay disponibles en el source antes del source_in actual
            available_source_frames_before = source_in - 0  # source_in actual menos el mínimo posible (0)
            
            # El mínimo in point en el timeline, respetando los límites del media source
            # Convertimos a entero para evitar problemas con valores flotantes
            min_in_media = int(timeline_in - available_source_frames_before)
            
            debug_print(f&quot;Cálculo de límite de media:&quot;)
            debug_print(f&quot;  - Media Start: {media_start}&quot;)
            debug_print(f&quot;  - Media End: {media_end}&quot;)
            debug_print(f&quot;  - Source In: {source_in}&quot;)
            debug_print(f&quot;  - Available Source Frames Before: {available_source_frames_before}&quot;)
            debug_print(f&quot;  - Timeline In: {timeline_in}&quot;)
            debug_print(f&quot;  - Mínimo Timeline In basado en media: {min_in_media}&quot;)
            
            # Ahora verificamos si hay clips antes que limitarían la extensión
            parent_track = clip.parent()
            track_items = parent_track.items()
            
            # Ordenamos los items por su posición en el timeline
            sorted_items = sorted(track_items, key=lambda x: x.timelineIn())
            
            # Buscamos el índice del clip actual
            current_index = sorted_items.index(clip)
            
            # Verificamos si hay un clip antes de éste
            min_in_prev_clip = None
            if current_index &gt; 0:
                prev_clip = sorted_items[current_index - 1]
                # El límite sería el final del clip anterior
                min_in_prev_clip = prev_clip.timelineOut()
                debug_print(f&quot;  - Clip anterior: {prev_clip.name()} termina en frame {min_in_prev_clip}&quot;)
            
            # Determinar el límite final
            if min_in_prev_clip is not None:
                min_in = max(min_in_media, min_in_prev_clip)
                debug_print(f&quot;  - Límite final (mayor entre media y clip anterior): {min_in}&quot;)
            else:
                min_in = min_in_media
                debug_print(f&quot;  - Límite final (solo basado en media): {min_in}&quot;)
                
            return min_in
            
        except Exception as e:
            debug_print(f&quot;Error al calcular el mínimo in point: {e}&quot;)
            import traceback
            debug_print(traceback.format_exc())
            return None
    
    def extend_clip_to_minimum(self, clip, target_frame):
        &quot;&quot;&quot;
        Extiende el inicio del clip hasta un frame específico.
        
        Args:
            clip: El clip a extender
            target_frame: El frame objetivo para el nuevo in point
            
        Returns:
            bool: True si la extensión fue exitosa, False en caso contrario
        &quot;&quot;&quot;
        try:
            # Aseguramos que target_frame sea un entero
            target_frame = int(target_frame)
            
            # Obtenemos los valores actuales
            timeline_in = clip.timelineIn()
            source_in = clip.sourceIn()
            
            # Calculamos la diferencia entre el actual in y el nuevo in
            frame_difference = timeline_in - target_frame
            
            # Calculamos el nuevo source in
            new_source_in = float(source_in) - float(frame_difference)
            
            # Comprobamos que no sea negativo
            if new_source_in &lt; 0:
                debug_print(f&quot;El nuevo source in sería negativo ({new_source_in}). Ajustando a 0.&quot;)
                new_source_in = 0
                # Recalculamos el target_frame basado en el nuevo source_in
                target_frame = int(timeline_in - (source_in - new_source_in))
            
            # Establecemos el nuevo source in
            clip.setSourceIn(new_source_in)
            
            # Establecemos el nuevo timeline in
            clip.setTimelineIn(target_frame)
            
            # Imprimimos información sobre el ajuste
            debug_print(f&quot;Clip extendido: {clip.name()}&quot;)
            debug_print(f&quot;  - Timeline IN: {timeline_in} -&gt; {target_frame} (diferencia: {frame_difference})&quot;)
            debug_print(f&quot;  - Source IN: {source_in} -&gt; {new_source_in}&quot;)
            debug_print(f&quot;  - Nota: El playhead estaba antes del clip. Se ha extendido al mínimo posible.&quot;)
            
            return True
            
        except RuntimeError as re:
            error_msg = str(re)
            debug_print(f&quot;Error de runtime al extender clip: {error_msg}&quot;)
            return False
            
        except TypeError as te:
            error_msg = str(te)
            debug_print(f&quot;Error de tipo al extender clip: {error_msg}&quot;)
            debug_print(f&quot;  - Target frame (tipo: {type(target_frame)}): {target_frame}&quot;)
            return False
            
        except OverflowError as oe:
            error_msg = str(oe)
            debug_print(f&quot;Error de overflow al extender clip: {error_msg}&quot;)
            debug_print(f&quot;  - Target frame (tipo: {type(target_frame)}): {target_frame}&quot;)
            return False
            
        except Exception as e:
            debug_print(f&quot;Error inesperado al extender clip: {e}&quot;)
            import traceback
            debug_print(traceback.format_exc())
            return False
    
    def trim_material_to_playhead(self, clip, playhead_frame):
        &quot;&quot;&quot;
        Recorta el material del clip a partir del playhead.
        Ajusta tanto el source in como el timeline in para mantener la relación 1:1.
        
        Args:
            clip: El clip a recortar
            playhead_frame: La posición del playhead
            
        Returns:
            bool: True si el recorte fue exitoso, False en caso contrario
        &quot;&quot;&quot;
        try:
            # Obtenemos los valores actuales
            timeline_in = clip.timelineIn()
            timeline_out = clip.timelineOut()
            source_in = clip.sourceIn()
            source_out = clip.sourceOut()
            
            # Si el playhead está después del final del clip, no hacemos nada
            if playhead_frame &gt;= timeline_out:
                debug_print(f&quot;El playhead ({playhead_frame}) está después del final del clip {clip.name()} ({timeline_out})&quot;)
                return False
            
            # Calculamos cuántos frames debemos recortar desde el inicio
            frames_to_trim = playhead_frame - timeline_in
            
            # Calculamos los nuevos valores
            new_source_in = source_in + frames_to_trim
            new_timeline_in = playhead_frame
            
            # Verificamos que no estemos tratando de ir más allá de los límites del source
            if new_source_in &gt;= source_out:
                debug_print(f&quot;El recorte excedería los límites del source. No se puede recortar.&quot;)
                return False
            
            # Guardamos los valores por si necesitamos revertir el cambio
            original_timeline_in = timeline_in
            original_source_in = source_in
            
            try:
                # Primero establecemos el nuevo source in
                clip.setSourceIn(new_source_in)
                
                # Luego el nuevo timeline in
                clip.setTimelineIn(new_timeline_in)
                
            except Exception as e:
                # Si algo sale mal, intentamos revertir los cambios
                debug_print(f&quot;Error durante el recorte: {e}. Intentando revertir cambios...&quot;)
                try:
                    clip.setSourceIn(original_source_in)
                    clip.setTimelineIn(original_timeline_in)
                except:
                    debug_print(&quot;No se pudieron revertir los cambios.&quot;)
                return False
            
            # Imprimimos información sobre el ajuste
            debug_print(f&quot;Clip recortado: {clip.name()}&quot;)
            debug_print(f&quot;  - Timeline IN: {timeline_in} -&gt; {new_timeline_in} (recortado {frames_to_trim} frames)&quot;)
            debug_print(f&quot;  - Source IN: {source_in} -&gt; {new_source_in} (recortado {frames_to_trim} frames)&quot;)
            debug_print(f&quot;  - Frames recortados: {frames_to_trim}&quot;)
            
            return True
            
        except RuntimeError as re:
            error_msg = str(re)
            debug_print(f&quot;Error de runtime al recortar clip: {error_msg}&quot;)
            return False
            
        except TypeError as te:
            error_msg = str(te)
            debug_print(f&quot;Error de tipo al recortar clip: {error_msg}&quot;)
            return False
            
        except Exception as e:
            debug_print(f&quot;Error inesperado al recortar clip: {e}&quot;)
            import traceback
            debug_print(traceback.format_exc())
            return False
    
    def trim_in_to_playhead(self):
        &quot;&quot;&quot;
        Recorta el material antes del playhead en clips seleccionados.
        Ajusta tanto el source como el timeline para mantener la relación 1:1.
        Si el playhead está antes del inicio del clip, extiende el clip hasta el límite mínimo posible.
        &quot;&quot;&quot;
        seq = hiero.ui.activeSequence()
        if not seq:
            debug_print(&quot;\nNo se encontró una secuencia activa.&quot;)
            return
            
        te = hiero.ui.getTimelineEditor(seq)
        selected_clips = te.selection()
        
        current_viewer = hiero.ui.currentViewer()
        player = current_viewer.player() if current_viewer else None
        playhead_frame = player.time() if player else None

        if not selected_clips:
            debug_print(&quot;No hay clips seleccionados.&quot;)
            return
            
        if playhead_frame is None:
            debug_print(&quot;Posición del playhead no disponible.&quot;)
            return
        
        debug_print(f&quot;Posición del playhead: {playhead_frame}&quot;)
        
        for clip in selected_clips:
            try:
                # Imprimimos las propiedades del clip para debugging
                debug_print(&quot;\nPROPIEDADES ANTES DEL RECORTE:&quot;)
                print_clip_properties(clip)
                
                # Obtenemos los valores actuales del timeline
                timeline_in = clip.timelineIn()
                timeline_out = clip.timelineOut()
                
                # Comprobamos si el playhead está antes del inicio del clip
                if playhead_frame &lt; timeline_in:
                    debug_print(f&quot;El playhead ({playhead_frame}) está antes del inicio del clip {clip.name()} ({timeline_in})&quot;)
                    
                    # Calculamos el mínimo in point posible
                    min_in = self.get_min_possible_timeline_in(clip)
                    
                    if min_in is None:
                        debug_print(&quot;No se pudo determinar el mínimo in point posible.&quot;)
                        continue
                    
                    # Determinamos el frame objetivo para la extensión
                    target_frame = playhead_frame
                    
                    # Si el playhead está antes del límite mínimo, ajustamos al mínimo
                    if playhead_frame &lt; min_in:
                        target_frame = int(min_in)  # Aseguramos que sea entero
                        debug_print(f&quot;El playhead ({playhead_frame}) está antes del límite mínimo ({min_in}). Se ajustará al mínimo.&quot;)
                    
                    # Verificamos si hay superposición con otro clip en el frame objetivo
                    parent_track = clip.parent()
                    if self.check_for_overlapping_items(parent_track, clip, target_frame):
                        debug_print(f&quot;No se puede extender: causaría superposición con otro clip&quot;)
                        continue
                    
                    # Extendemos el clip hacia atrás
                    success = self.extend_clip_to_minimum(clip, target_frame)
                    if success:
                        # Imprimimos las propiedades actualizadas
                        debug_print(&quot;\nPROPIEDADES DESPUÉS DE LA EXTENSIÓN:&quot;)
                        print_clip_properties(clip)
                    
                # Si el playhead está dentro del clip, recortamos normalmente
                elif playhead_frame &lt; timeline_out:
                    # Recortamos el material
                    success = self.trim_material_to_playhead(clip, playhead_frame)
                    if success:
                        # Imprimimos las propiedades actualizadas
                        debug_print(&quot;\nPROPIEDADES DESPUÉS DEL RECORTE:&quot;)
                        print_clip_properties(clip)
                    else:
                        debug_print(f&quot;No se pudo recortar el clip {clip.name()}&quot;)
                
                # Si el playhead está después del final del clip, no hacemos nada
                else:
                    debug_print(f&quot;El playhead ({playhead_frame}) está después del final del clip {clip.name()} ({timeline_out})&quot;)
                
            except Exception as e:
                debug_print(f&quot;Error al procesar el clip: {e}&quot;)
                import traceback
                debug_print(traceback.format_exc())

# Instanciar la clase cuando se importa el módulo
trim_tool = TrimInToPlayhead()

# Función para testing/depuración
def test_trim_in():
    &quot;&quot;&quot;Función de prueba para ejecutar manualmente desde la consola de Python.&quot;&quot;&quot;
    trimmer = TrimInToPlayhead()
    trimmer.trim_in_to_playhead()
    return &quot;Test completado&quot;

# Para poder ejecutar la función desde la consola de Python directamente
if __name__ == &quot;__main__&quot;:
    test_trim_in()
&quot;&quot;&quot;
_________________________________________

  LGA_EditToolsPanel v2.7 - 2025 - Lega
  Tools panel for Hiero / Nuke Studio
_________________________________________

&quot;&quot;&quot;


import hiero.ui
import hiero.core
import os
import re
import subprocess
import socket
import PySide2, hiero
from PySide2.QtWidgets import *
from PySide2.QtGui import QIcon
from PySide2.QtCore import *
from PySide2 import QtWidgets, QtCore
import importlib.util

# Variable global para activar o desactivar los prints
DEBUG = True
DEBUG_BASIC = True

def debug_print(*message):
    if DEBUG:
        print(*message)

def debug_print_b(*message):
    if DEBUG_BASIC:
        print(*message)

class ReconnectMediaWidget(QWidget):
    def __init__(self):
        super(ReconnectMediaWidget, self).__init__()

        self.setObjectName(&quot;com.lega.toolPanel&quot;)
        self.setWindowTitle(&quot;Edit&quot;)
        self.setStyleSheet(&quot;QToolTip { color: #ffffff; background-color: #2a2a2a; border: 1px solid white; }&quot;)

        self.layout = QGridLayout(self)  # Usamos QGridLayout en lugar de QVBoxLayout
        self.setLayout(self.layout)

        # Crear el organizador
        self.organizer = OrganizeProject()

        # Crear botones y agregarlos al layout
        self.buttons = [
            (&quot;Organize Project&quot;, self.organizer.organize_project, &quot;#283548&quot;),
            (&quot;Clean Project&quot;, self.clean_project, &quot;#283548&quot;),
            (&quot;Rec709 | Clip&quot;, self.rec709_clip, &quot;#434c41&quot;),
            (&quot;Default | Clip&quot;, self.default_clip, &quot;#434c41&quot;),
            (&quot;Set Shot Name&quot;, self.set_shot_name, &quot;#453434&quot;),
            (&quot;Extend &amp;Edit&quot;, self.extend_edit_to_playhead, &quot;#453434&quot;, &quot;Alt+E&quot;, &quot;Alt+E&quot;),
            (&quot;Trim &amp;In&quot;, self.trim_in, &quot;#453434&quot;, &quot;Alt+I&quot;, &quot;Alt+I&quot;),
            (&quot;Trim &amp;Out&quot;, self.trim_out, &quot;#453434&quot;, &quot;Alt+O&quot;, &quot;Alt+O&quot;),
            (&quot;Reconnect T &gt; N&quot;, self.reconnect_t_to_n, &quot;#4a4329&quot;),
            (&quot;Reconnect N &gt; T&quot;, self.reconnect_n_to_t, &quot;#4a4329&quot;),
            (&quot;Reconnect T Win &gt; Mac&quot;, self.execute_reconnect_win_to_mac, &quot;#4a4329&quot;),
            (&quot;Reconnect Media&quot;, self.reconnectMediaFromTimeline, &quot;#4a4329&quot;, &quot;Alt+M&quot;, &quot;Alt+M&quot;),
            #(&quot;Check Frames&quot;, self.check_frames, &quot;#4a4329&quot;),  # Nuevo boton
            ]

        self.num_columns = 1  # Inicialmente una columna
        self.create_buttons()

        # Conectar la senal de cambio de tamano del widget al metodo correspondiente
        self.adjust_columns_on_resize()
        self.resizeEvent = self.adjust_columns_on_resize

    def create_buttons(self):
        for index, button_info in enumerate(self.buttons):
            name = button_info[0]
            handler = button_info[1]
            style = button_info[2]
            shortcut = button_info[3] if len(button_info) &gt; 3 else None
            tooltip = button_info[4] if len(button_info) &gt; 4 else None

            button = QPushButton(name)
            button.setStyleSheet(f&quot;background-color: {style}&quot;)
            button.clicked.connect(handler)
            if shortcut:
                button.setShortcut(shortcut)
            if tooltip:
                button.setToolTip(tooltip)

            row = index // self.num_columns
            column = index % self.num_columns
            self.layout.addWidget(button, row, column)

    def adjust_columns_on_resize(self, event=None):
        # Obtener el ancho actual del widget
        panel_width = self.width()
        button_width = 120  # Ancho aproximado de cada boton
        min_button_spacing = 10  # Espacio minimo entre botones

        # Calcular el numero de columnas en funcion del ancho del widget
        self.num_columns = max(1, (panel_width + min_button_spacing) // (button_width + min_button_spacing))

        # Limpiar el layout actual y eliminar widgets solo si existen
        while self.layout.count():
            item = self.layout.takeAt(0)
            widget = item.widget()
            if widget:
                widget.deleteLater()

        # Volver a crear los botones con el nuevo numero de columnas
        self.create_buttons()

        # Calcular el numero de filas usadas
        num_rows = (len(self.buttons) + self.num_columns - 1) // self.num_columns

        # Anadir el espaciador vertical
        spacer = QSpacerItem(20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding)
        self.layout.addItem(spacer, num_rows, 0, 1, self.num_columns)


###### Rec 709 en clips seleccionados
    def rec709_clip(self):
        # Obtener la secuencia activa y el editor de linea de tiempo
        seq = hiero.ui.activeSequence()
        if seq:  # Asegurarse de que hay una secuencia activa
            te = hiero.ui.getTimelineEditor(seq)
            selected_clips = te.selection()

            # Iterar sobre los clips seleccionados para cambiar el color transform
            for clip in selected_clips:
                try:
                    clip.setSourceMediaColourTransform(&quot;Output - Rec.709&quot;)
                    debug_print(&quot;Color transform changed successfully.&quot;)
                except Exception as e:
                    debug_print(&quot;Error changing color transform:&quot;, e)
        else:
            debug_print(&quot;No active sequence found.&quot;)

###### Default space color en clips seleccionados
    def default_clip(self):
        # Obtener la secuencia activa y el editor de linea de tiempo
        seq = hiero.ui.activeSequence()
        if seq:  # Asegurarse de que hay una secuencia activa
            te = hiero.ui.getTimelineEditor(seq)
            selected_clips = te.selection()

            # Iterar sobre los clips seleccionados para cambiar el color transform
            for clip in selected_clips:
                try:
                    clip.setSourceMediaColourTransform(&quot;default&quot;)
                    debug_print(&quot;Color transform changed successfully.&quot;)
                except Exception as e:
                    debug_print(&quot;Error changing color transform:&quot;, e)
        else:
            debug_print(&quot;No active sequence found.&quot;)




###### Shot name
    def set_shot_name(self):
        try:
            project = hiero.core.projects()[-1]
            with project.beginUndo(&quot;Set Shot Name&quot;):
                seq = hiero.ui.activeSequence()
                if not seq:
                    debug_print(&quot;No active sequence found.&quot;)
                    return

                te = hiero.ui.getTimelineEditor(seq)
                selected_clips = te.selection()

                if len(selected_clips) == 0:
                    debug_print(&quot;*** No clips selected on the track ***&quot;)
                else:
                    for shot in selected_clips:
                        # Obtener el file path del clip seleccionado
                        file_path = shot.source().mediaSource().fileinfos()[0].filename()
                        debug_print(&quot;Original file path:&quot;, file_path)

                        # Obtener el nombre del plano del path del clip
                        shot_name = self.get_shot_name(file_path)
                        debug_print(&quot;Shot name:&quot;, shot_name)

                        # Cambiar el nombre del plano al clip seleccionado
                        shot.setName(shot_name)
                        debug_print(&quot;Shot name changed successfully.&quot;)
        except Exception as e:
            debug_print(f&quot;Error: {e}&quot;)

    def get_shot_name(self, file_path):
        # Dividir el path en partes usando '/' como separador
        path_parts = file_path.split('/')
        # El shot name seria la tercera parte del path
        shot_name = path_parts[3]
        return shot_name


###### Extend edit
    def extend_edit_to_playhead(self):
        seq = hiero.ui.activeSequence()
        if not seq:
            debug_print(&quot;\nNo active sequence found.&quot;)
            return
            
        te = hiero.ui.getTimelineEditor(seq)
        selected_clips = te.selection()
        
        current_viewer = hiero.ui.currentViewer()
        player = current_viewer.player() if current_viewer else None
        playhead_frame = player.time() if player else None

        if selected_clips and playhead_frame is not None:
            for shot in selected_clips:
                try:
                    shot.setTimelineOut(playhead_frame + 1)
                    debug_print(f&quot;DST Out extended to {playhead_frame + 1} for clip: {shot.name()}&quot;)
                except Exception as e:
                    debug_print(f&quot;Error setting DST Out: {e}&quot;)
        else:
            debug_print(&quot;No clips selected or playhead position unavailable.&quot;)

###### Trim In
    def trim_in(self):
        &quot;&quot;&quot;Ejecuta el script LGA_NKS_Trim_In.py para recortar el material antes del playhead.&quot;&quot;&quot;
        self.execute_external_script('LGA_NKS_Trim_In.py')

###### Trim Out
    def trim_out(self):
        &quot;&quot;&quot;Ejecuta el script LGA_NKS_Trim_Out.py para recortar el material después del playhead.&quot;&quot;&quot;
        self.execute_external_script('LGA_NKS_Trim_Out.py')

###### Reconnect
    def reconnect_t_to_n(self):
        try:
            project = hiero.core.projects()[-1]
            project.beginUndo(&quot;Reconnect T &gt; N&quot;)
            try:
                self.reconnect_media(&quot;t:&quot;, &quot;n:&quot;)
            except Exception as e:
                debug_print(f&quot;Error: {e}&quot;)
            project.endUndo()
        except Exception as e:
            debug_print(f&quot;Error: {e}&quot;)

    def reconnect_n_to_t(self):
        try:
            project = hiero.core.projects()[-1]
            with project.beginUndo(&quot;Reconnect N &gt; T&quot;):
                self.reconnect_media(&quot;n:&quot;, &quot;t:&quot;)
        except Exception as e:
            debug_print(f&quot;Error: {e}&quot;)
        finally:
            if project.undoStack().canEnd():
                project.endUndo()
            else:
                debug_print(&quot;No current undo item to end.&quot;)

    def execute_reconnect_win_to_mac(self):
        debug_print_b(&quot;\n=== INICIANDO PROCESO DE RECONNECT + REPLACE ===&quot;)
        
        try:
            debug_print_b(&quot;\n&gt;&gt;&gt; Ejecutando Reconnect script...&quot;)
            self.execute_external_script('LGA_NKS_Reconnect.py')
            debug_print_b(&quot;&gt;&gt;&gt; Reconnect script completado&quot;)
        except Exception as e:
            debug_print_b(f&quot;Error en Reconnect: {e}&quot;)
        
        try:
            debug_print_b(&quot;\n&gt;&gt;&gt; Ejecutando SelfReplace script...&quot;)
            self.execute_external_script('LGA_NKS_SelfReplaceClip.py')
            debug_print_b(&quot;&gt;&gt;&gt; SelfReplace script completado&quot;)
        except Exception as e:
            debug_print_b(f&quot;Error en SelfReplace: {e}&quot;)
            
        debug_print_b(&quot;\n=== PROCESO COMPLETO ===&quot;)


    def reconnect_media(self, old_prefix, new_prefix):
        try:
            seq = hiero.ui.activeSequence()
            if not seq:
                debug_print(&quot;No active sequence found.&quot;)
                return

            te = hiero.ui.getTimelineEditor(seq)
            selected_clips = te.selection()

            if len(selected_clips) == 0:
                debug_print(&quot;*** No clips selected on the track ***&quot;)
            else:
                for shot in selected_clips:
                    # Obtener el file path del clip seleccionado
                    file_path = shot.source().mediaSource().fileinfos()[0].filename()
                    debug_print(&quot;Original file path:&quot;, file_path)

                    # Normalizar el path convirtiendo todo a minusculas
                    normalized_file_path = file_path.lower()

                    # Reemplazar el prefijo antiguo por el nuevo
                    new_file_path = normalized_file_path.replace(old_prefix, new_prefix)
                    debug_print(&quot;Modified file path:&quot;, new_file_path)

                    # Obtener solo la ruta del directorio sin el nombre del archivo
                    directory_path = os.path.dirname(new_file_path)

                    # Reemplazar el clip por el del nuevo path
                    try:
                        shot.reconnectMedia(directory_path)
                        debug_print(&quot;Clip reconnected successfully.&quot;)
                    except Exception as e:
                        debug_print(f&quot;Error reconnecting clip: {e}&quot;)
        except Exception as e:
            debug_print(f&quot;Error: {e}&quot;)

    def reconnectMediaFromTimeline(self): 
        seq = hiero.ui.activeSequence()
        if not seq:
            debug_print(&quot;\nNo active sequence found.&quot;)
            return
            
        te = hiero.ui.getTimelineEditor(seq)
        selected_track_items = te.selection()

        if len(selected_track_items) == 0:
            debug_print(&quot;*** No track items selected ***&quot;)
            return

        # Obtener la ruta del clip seleccionado
        selected_clip = selected_track_items[0]  # Solo usaremos el primer clip seleccionado
        file_path = selected_clip.source().mediaSource().fileinfos()[0].filename()
        initial_path = os.path.dirname(file_path)

        # Agregar una barra al final del path si no esta presente
        if not initial_path.endswith(&quot;/&quot;):
            initial_path += &quot;/&quot;

        # Abrir el file browser con la ruta inicial del clip seleccionado
        search_path = hiero.ui.openFileBrowser(&quot;Choose directory to search for media&quot;, mode=3, initialPath=initial_path)[0] 

        for track_item in selected_track_items:         
            track_item.reconnectMedia(search_path)


###### Clean Project
    def clean_project(self):
        try:
            clean_action = CleanUnusedAction()
            clean_action.CleanUnused()
        except Exception as e:
            debug_print(f&quot;Error during project cleaning: {e}&quot;)

    # Metodo para ejecutar scripts externos
    def execute_external_script(self, script_name):
        script_path = os.path.join(os.path.dirname(__file__), 'LGA_NKS', script_name)
        if os.path.exists(script_path):
            try:
                spec = importlib.util.spec_from_file_location(script_name[:-3], script_path)
                module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(module)
                module.main()
            except Exception as e:
                debug_print(f&quot;Error ejecutando el script {script_name}: {e}&quot;)
        else:
            debug_print(f&quot;Script no encontrado en la ruta: {script_path}&quot;)

    # Nuevo metodo para ejecutar LGA_NKS_mediaMissingFrames.py
    def check_frames(self):
        self.execute_external_script('LGA_NKS_mediaMissingFrames.py')


class CleanUnusedAction:

    def __init__(self):
         pass
         
    # Method to return whether a Bin is empty...
    def binIsEmpty(self,b):
        numBinItems = 0
        bItems = b.items()
        empty = False

        if len(bItems) == 0:
            empty = True
            return empty
        else:
            for b in bItems:
                if isinstance(b,hiero.core.BinItem) or isinstance(b,hiero.core.Bin):
                    numBinItems+=1
            if numBinItems == 0:
                empty = True

        return empty

    def CleanUnused(self) :

        # Get the active project
        project = get_active_project()

        # Build a list of Projects
        SEQS = hiero.core.findItems(project, &quot;Sequences&quot;)

        # Build a list of Clips
        CLIPSTOREMOVE = hiero.core.findItems(project, &quot;Clips&quot;)


        if len(SEQS)==0:
            # Present Dialog Asking if User wants to remove Clips
            msgBox = QMessageBox()
            msgBox.setText(&quot;Clean Unused Clips&quot;);
            msgBox.setInformativeText(&quot;You have no Sequences in this Project. Do you want to remove all Clips (%i) from Project: %s?&quot; % (len(CLIPSTOREMOVE), project.name()));
            msgBox.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel);
            msgBox.setDefaultButton(QMessageBox.Ok);
            ret = msgBox.exec_()
            if ret == QMessageBox.Cancel:
                debug_print('Not purging anything.')
            elif ret == QMessageBox.Ok:
                with project.beginUndo('Clean Unused Clips'):
                    BINS = []
                    for clip in CLIPSTOREMOVE:
                        BI = clip.binItem()
                        B = BI.parentBin()
                        BINS+=[B]
                        debug_print('Removing:', BI)
                        try:
                            B.removeItem(BI)
                        except:
                            debug_print('Unable to remove:', BI)
            return

        # For each sequence, iterate through each track Item, see if the Clip is in the CLIPS list.
        # Remaining items in CLIPS will be removed

        for seq in SEQS:

            #Loop through selected and make folders
            for track in seq:
                for trackitem in track:

                    if trackitem.source() in CLIPSTOREMOVE:
                        CLIPSTOREMOVE.remove(trackitem.source())

        # Present Dialog Asking if User wants to remove Clips
        msgBox = QMessageBox()
        msgBox.setText(&quot;Clean Unused Clips&quot;);
        msgBox.setInformativeText(&quot;Remove %i unused Clips from Project %s?&quot; % (len(CLIPSTOREMOVE), project.name()));
        msgBox.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel);
        msgBox.setDefaultButton(QMessageBox.Ok);
        ret = msgBox.exec_()

        if ret == QMessageBox.Cancel:
             debug_print('Cancel')
             return
        elif ret == QMessageBox.Ok:
            BINS = []
            with project.beginUndo('Clean Unused Clips'):
                # Delete the rest of the Clips
                for clip in CLIPSTOREMOVE:
                    BI = clip.binItem()
                    B = BI.parentBin()
                    BINS+=[B]
                    debug_print('Removing:', BI)
                    try:
                        B.removeItem(BI)
                    except:
                        debug_print('Unable to remove:', BI)

    def eventHandler(self, event):
        if not hasattr(event.sender, 'selection'):
                # Something has gone wrong, we shouldn't only be here if raised
                # by the Bin view which will give a selection.
                return

        self.selectedItem = None
        s = event.sender.selection()

        if len(s)&gt;=1:
            self.selectedItem = s[0]
            title = &quot;Clean Unused Clips&quot;
            self.setText(title)
            event.menu.addAction(self)

        return

def get_active_project():
    &quot;&quot;&quot;
    Obtiene el proyecto activo en Hiero.

    Returns:
    - hiero.core.Project o None: El proyecto activo, o None si no se encuentra ningun proyecto activo.
    &quot;&quot;&quot;
    projects = hiero.core.projects()
    if projects:
        return projects[0]  # Devuelve el primer proyecto en la lista
    else:
        return None


##### Organize Project
class OrganizeProject:
    def find_or_create_bin(self, root_bin, bin_name):
        for item in root_bin.items():
            if isinstance(item, hiero.core.Bin) and item.name() == bin_name:
                return item
        new_bin = hiero.core.Bin(bin_name)
        root_bin.addItem(new_bin)
        return new_bin

    def move_clips_from_bin(self, bin_item):
        if bin_item.name() == &quot;Published&quot;:  # Ignorar el bin 'Published' y sus subcarpetas
            return
        for item in bin_item.items():
            if isinstance(item, hiero.core.BinItem) and isinstance(item.activeItem(), hiero.core.Clip):
                clip = item.activeItem()
                media_source = clip.mediaSource()
                if media_source and media_source.fileinfos():
                    file_path = media_source.fileinfos()[0].filename()
                    parts = file_path.split('/')
                    if len(parts) &gt; 3:
                        folder_name = f&quot;F {parts[2]}&quot;
                        shot_name = parts[3]
                        folder_bin = self.find_or_create_bin(self.project.clipsBin(), folder_name)
                        shot_bin = self.find_or_create_bin(folder_bin, shot_name)
                        clip_item = clip.binItem()
                        if clip_item.parentBin() != shot_bin:
                            clip_item.parentBin().removeItem(clip_item)
                            shot_bin.addItem(clip_item)
            elif isinstance(item, hiero.core.Bin):
                self.move_clips_from_bin(item)

    def clean_empty_bins(self, bin_item):
        if bin_item.name() == &quot;Published&quot;:
            return
        items_to_check = list(bin_item.items())
        for item in items_to_check:
            if isinstance(item, hiero.core.Bin):
                self.clean_empty_bins(item)
        if not bin_item.items() and bin_item.parentBin():
            bin_item.parentBin().removeItem(bin_item)

    def move_clips_based_on_path(self, project):
        self.project = project
        with project.beginUndo('Reorganize Clips Based on Path'):
            for bin_item in project.clipsBin().items():
                if isinstance(bin_item, hiero.core.Bin):
                    self.move_clips_from_bin(bin_item)

            for bin_item in list(project.clipsBin().items()):
                if isinstance(bin_item, hiero.core.Bin):
                    self.clean_empty_bins(bin_item)

    def organize_project(self):
        project = hiero.core.projects()[0] if hiero.core.projects() else None
        if project:
            self.move_clips_based_on_path(project)
        else:
            debug_print(&quot;No se encontro un proyecto abierto en Hiero.&quot;)


# Crear la instancia del widget y anadirlo al gestor de ventanas de Hiero
reconnectWidget = ReconnectMediaWidget()
wm = hiero.ui.windowManager()
wm.addWindow(reconnectWidget)</script>
