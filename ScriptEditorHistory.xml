<?xml version="1.0" encoding="UTF-8"?><script>nuke.toNode('NoOp1').knob('knobChanged').setValue('n=nuke.thisNode()\nk=nuke.thisKnob()\nif k.name() in [&quot;lga_firstFrame_int&quot;, &quot;lga_lastFrame_int&quot;, &quot;lga_frameCount&quot;]:\n rife=nuke.toNode(&quot;RIFE1&quot;)\n if rife:\n  try:\n   fc=int(n[&quot;lga_frameCount&quot;].value())\n   tk=rife[&quot;timingFrame&quot;]\n   tk.clearAnimated()\n   tk.setAnimated()\n   tk.setValueAt(1, 1)\n   tk.setValueAt(2, fc)\n  except:\n   nuke.message(&quot;Error setting keyframes&quot;)')
nuke.toNode('LGA_Morph').knob('knobChanged').setValue('n=nuke.thisNode()\nk=nuke.thisKnob()\nif k.name() in [&quot;lga_firstFrame&quot;,&quot;lga_lastFrame&quot;,&quot;lga_frameRangeIn&quot;,&quot;lga_frameRangeOut&quot;,&quot;python_button&quot;,&quot;python_button_1&quot;,&quot;python_button_2&quot;]:\n data=nuke.toNode(&quot;NoOp_Morph&quot;)\n rife=nuke.toNode(&quot;RIFE_Morph&quot;)\n merge=nuke.toNode(&quot;Merge_Morph&quot;)\n try:\n  fi=int(data[&quot;lga_firstFrame_int&quot;].value())\n  fo=int(data[&quot;lga_lastFrame_int&quot;].value())\n  fc=int(data[&quot;lga_frameCount&quot;].value())\n  if rife:\n   tk=rife[&quot;timingFrame&quot;]\n   tk.clearAnimated()\n   tk.setAnimated()\n   tk.setValueAt(fi, fi)\n   tk.setValueAt(fi+1, fo)\n  for node in [rife, merge]:\n   if node:\n    dk=node[&quot;disable&quot;]\n    dk.clearAnimated()\n    dk.setAnimated()\n    dk.setValueAt(1, fi)\n    dk.setValueAt(0, fi+1)\n    dk.setValueAt(0, fo-1)\n    dk.setValueAt(1, fo)\n except Exception as e:\n  nuke.message(&quot;Keyframe error: {}&quot;.format(e))')
&quot;&quot;&quot;
______________________________________________________

  LGA_NKS_CheckProjectVersions v1.1 - 2025 - Lega
  Chequea versiones de todos los proyectos abiertos en Hiero
______________________________________________________

&quot;&quot;&quot;

import hiero.core
import hiero.ui
import re
import os
import glob
import datetime
from PySide2.QtWidgets import QMainWindow, QVBoxLayout, QLabel, QPushButton, QGridLayout, QFrame, QTableWidget, QTableWidgetItem, QWidget, QApplication, QHBoxLayout
from PySide2.QtCore import Qt, QTimer
from PySide2.QtGui import QFont, QColor

# Configuración del temporizador (en minutos)
INTERVALO_TEMPORIZADOR = 5

# Variable global para almacenar el temporizador activo
temporizador_global = None
temporizador_id = &quot;LGA_CheckProjects_Timer&quot;

DEBUG = False

def debug_print(*message):
    if DEBUG:
        print(*message)

def extraer_version(ruta_disco):
    &quot;&quot;&quot;Extrae el número de versión de la ruta del archivo en disco&quot;&quot;&quot;
    if not ruta_disco:
        return &quot;No detectada&quot;
    
    try:
        # Obtener el nombre del archivo (sin la ruta completa)
        nombre_archivo = os.path.basename(ruta_disco)
        
        # Quitar la extensión .hrox
        nombre_sin_extension = os.path.splitext(nombre_archivo)[0]
        
        # Buscar la parte que comienza con 'v' seguida de números al final del nombre
        resultado = re.search(r'(?:_|-)?(v\d+)$', nombre_sin_extension)
        if resultado:
            return resultado.group(1)  # Devuelve 'v###'
        
        # Si no encuentra 'v', buscar solo números al final después de un guion bajo o guion
        resultado = re.search(r'(?:_|-)?(\d+)$', nombre_sin_extension)
        if resultado:
            return 'v' + resultado.group(1)  # Añade 'v' a los números encontrados
        
        return &quot;No detectada&quot;
    except Exception as e:
        debug_print(f&quot;Error al extraer versión: {str(e)}&quot;)
        return &quot;Error&quot;

def comparar_versiones(version1, version2):
    &quot;&quot;&quot;Compara dos versiones en formato 'v###' y devuelve la mayor&quot;&quot;&quot;
    try:
        # Extraer solo los números de las versiones
        match1 = re.search(r'v?(\d+)', version1)
        match2 = re.search(r'v?(\d+)', version2)
        
        if not match1 or not match2:
            return version1  # Si no se pueden extraer números, devuelve la primera versión
            
        num1 = int(match1.group(1))
        num2 = int(match2.group(1))
        
        if num1 &gt; num2:
            return version1
        else:
            return version2
    except Exception as e:
        debug_print(f&quot;Error al comparar versiones {version1} y {version2}: {str(e)}&quot;)
        return version1  # En caso de error, devuelve la primera versión

def encontrar_version_mas_alta(ruta_actual):
    &quot;&quot;&quot;Encuentra la ruta del archivo con la versión más alta en la misma carpeta&quot;&quot;&quot;
    if not ruta_actual or not os.path.exists(ruta_actual):
        return &quot;No disponible&quot;
    
    try:
        # Obtener la carpeta que contiene el archivo actual
        directorio = os.path.dirname(ruta_actual)
        
        # Obtener el nombre base del proyecto (sin versión ni extensión)
        nombre_archivo = os.path.basename(ruta_actual)
        
        # Extraer la parte base del nombre (antes de la versión)
        base_match = re.match(r'(.+?)(?:_|-)?v?\d+\.hrox$', nombre_archivo)
        if not base_match:
            base_match = re.match(r'(.+?)\.hrox$', nombre_archivo)
            if not base_match:
                return &quot;No detectada&quot;
        
        base_nombre = base_match.group(1)
        
        # Buscar todos los archivos .hrox en el directorio con el mismo nombre base
        patron_busqueda = os.path.join(directorio, f&quot;{base_nombre}*v*.hrox&quot;)
        archivos = glob.glob(patron_busqueda)
        
        # Si no encuentra con el patrón v*.hrox, intentar con cualquier número
        if not archivos:
            patron_busqueda = os.path.join(directorio, f&quot;{base_nombre}*[0-9]*.hrox&quot;)
            archivos = glob.glob(patron_busqueda)
        
        if not archivos:
            return &quot;No hay otras versiones&quot;
        
        # Extraer versiones de todos los archivos encontrados
        version_mas_alta = None
        archivo_mas_alto = None
        
        for archivo in archivos:
            version = extraer_version(archivo)
            if version == &quot;No detectada&quot; or version == &quot;Error&quot;:
                continue
                
            if version_mas_alta is None:
                version_mas_alta = version
                archivo_mas_alto = archivo
            else:
                version_previa = version_mas_alta
                version_mas_alta = comparar_versiones(version_mas_alta, version)
                
                if version_mas_alta != version_previa:
                    archivo_mas_alto = archivo
        
        if version_mas_alta and archivo_mas_alto:
            # Devolver la ruta completa del archivo con la versión más alta
            return archivo_mas_alto
        else:
            return &quot;No detectada&quot;
            
    except Exception as e:
        debug_print(f&quot;Error al buscar versión más alta: {str(e)}&quot;)
        return &quot;Error&quot;

def obtener_timestamp():
    &quot;&quot;&quot;Devuelve una cadena formateada con la fecha y hora actual&quot;&quot;&quot;
    ahora = datetime.datetime.now()
    return ahora.strftime(&quot;%d/%m/%Y %H:%M:%S&quot;)

class ProyectosAbertosDialog(QMainWindow):
    def __init__(self, parent=None):
        super(ProyectosAbertosDialog, self).__init__(parent)
        self.setWindowTitle(&quot;Proyectos Abiertos&quot;)
        self.setMinimumSize(900, 200)  # Reducir la altura a la mitad
        
        # Establecer un nombre de objeto único para esta ventana
        self.setObjectName(&quot;LGA_ProyectosAbertosDialog&quot;)
        
        # Configurar banderas de ventana para permitir minimizar, maximizar y cerrar
        self.setWindowFlags(Qt.Window | Qt.WindowMinimizeButtonHint | Qt.WindowMaximizeButtonHint | Qt.WindowCloseButtonHint)
        
        # Hacer que la ventana se destruya completamente cuando se cierra
        self.setAttribute(Qt.WA_DeleteOnClose, True)
        
        # Conectar el evento de cierre para detener el temporizador
        self.destroyed.connect(self.on_destroyed)
        
        # Mostrar IDs de la ventana
        print(f&quot;ID de ventana nativo: {self.winId()}&quot;)
        print(f&quot;Nombre de objeto: {self.objectName()}&quot;)
        
        # Widget central y layout
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)
        
        # Añadir título
        titulo = QLabel(&quot;Versiones de Proyectos Abiertos&quot;)
        titulo.setAlignment(Qt.AlignCenter)
        font = QFont()
        font.setBold(True)
        font.setPointSize(12)
        titulo.setFont(font)
        layout.addWidget(titulo)
        
        # Añadir información del temporizador
        self.label_timer = QLabel(f&quot;Actualizando cada {INTERVALO_TEMPORIZADOR} minutos&quot;)
        self.label_timer.setAlignment(Qt.AlignCenter)
        layout.addWidget(self.label_timer)
        
        # Tabla para mostrar los datos
        self.tabla_proyectos = QTableWidget()
        self.tabla_proyectos.setColumnCount(3)
        self.tabla_proyectos.setHorizontalHeaderLabels([
            &quot;Nombre del Proyecto&quot;, 
            &quot;Ruta en Disco&quot;,
            &quot;Versión Más Alta en Disco&quot;
        ])
        self.tabla_proyectos.horizontalHeader().setStretchLastSection(True)
        self.tabla_proyectos.setColumnWidth(0, 200)  # Nombre del proyecto
        self.tabla_proyectos.setColumnWidth(1, 350)  # Ruta en disco
        
        layout.addWidget(self.tabla_proyectos)
        
        # Botones inferiores en layout horizontal
        botones_layout = QHBoxLayout()
        
        # Botón para actualizar
        boton_actualizar = QPushButton(&quot;Actualizar Ahora&quot;)
        boton_actualizar.clicked.connect(self.actualizar_proyectos)
        botones_layout.addWidget(boton_actualizar)
        
        # Botón para cerrar
        boton_cerrar = QPushButton(&quot;Cerrar&quot;)
        boton_cerrar.clicked.connect(self.close)
        botones_layout.addWidget(boton_cerrar)
        
        layout.addLayout(botones_layout)
        
        # Cargar proyectos
        self.actualizar_proyectos()
    
    def on_destroyed(self):
        &quot;&quot;&quot;Se llama cuando la ventana se destruye&quot;&quot;&quot;
        # Detener el temporizador si la ventana se cierra
        detener_temporizador()
    
    def actualizar_proyectos(self):
        &quot;&quot;&quot;Actualiza la información de los proyectos abiertos en la tabla&quot;&quot;&quot;
        print(&quot;Actualizando información de proyectos...&quot;)
        # Limpiar tabla existente
        self.tabla_proyectos.clearContents()
        self.tabla_proyectos.setRowCount(0)
        
        # Actualizar etiqueta de temporizador
        self.label_timer.setText(f&quot;Actualizando cada {INTERVALO_TEMPORIZADOR} minutos. Última: {obtener_timestamp()}&quot;)
        
        # Llamar al método original de carga
        self.cargar_proyectos()
    
    def cargar_proyectos(self):
        &quot;&quot;&quot;Carga la información de los proyectos abiertos en la tabla&quot;&quot;&quot;
        proyectos = hiero.core.projects()
        
        if not proyectos:
            self.tabla_proyectos.setRowCount(1)
            self.tabla_proyectos.setItem(0, 0, QTableWidgetItem(&quot;No hay proyectos abiertos&quot;))
            self.tabla_proyectos.setSpan(0, 0, 1, 3)  # Combinar celdas para el mensaje
            return
        
        # Filtrar proyectos que tienen una versión más alta disponible
        proyectos_con_version_alta = []
        
        for proyecto in proyectos:
            # Obtener nombre de la interfaz
            nombre_interfaz = proyecto.name()
            
            # Obtener ruta del disco
            ruta_disco = proyecto.path()
            
            # Extraer versión de la ruta en disco (para comparación)
            version_actual = extraer_version(ruta_disco)
            
            # Encontrar la ruta de la versión más alta en disco
            ruta_version_alta = encontrar_version_mas_alta(ruta_disco)
            
            # Verificar si tiene una versión más alta que la actual
            version_actual_num = -1
            version_alta_num = -1
            
            try:
                if version_actual != &quot;No detectada&quot; and version_actual != &quot;Error&quot;:
                    match_actual = re.search(r'v?(\d+)', version_actual)
                    if match_actual:
                        version_actual_num = int(match_actual.group(1))
                
                if ruta_version_alta != &quot;No detectada&quot; and ruta_version_alta != &quot;Error&quot; and ruta_version_alta != &quot;No disponible&quot; and ruta_version_alta != &quot;No hay otras versiones&quot;:
                    version_alta = extraer_version(ruta_version_alta)
                    if version_alta != &quot;No detectada&quot; and version_alta != &quot;Error&quot;:
                        match_alta = re.search(r'v?(\d+)', version_alta)
                        if match_alta:
                            version_alta_num = int(match_alta.group(1))
            except Exception as e:
                debug_print(f&quot;Error al comparar versiones: {str(e)}&quot;)
            
            # Solo incluir proyectos con versión más alta disponible
            if version_actual_num &gt; 0 and version_alta_num &gt; 0 and version_actual_num &lt; version_alta_num:
                proyectos_con_version_alta.append({
                    'proyecto': proyecto,
                    'nombre': nombre_interfaz,
                    'ruta_actual': ruta_disco,
                    'ruta_alta': ruta_version_alta
                })
                debug_print(f&quot;Proyecto {nombre_interfaz} - Versión actual: {version_actual}, Versión más alta: {version_alta}&quot;)
        
        # Si no hay proyectos con versión más alta, mostrar mensaje
        if not proyectos_con_version_alta:
            self.tabla_proyectos.setRowCount(1)
            mensaje = QTableWidgetItem(&quot;No hay proyectos con versiones más altas disponibles&quot;)
            mensaje.setTextAlignment(Qt.AlignCenter)
            self.tabla_proyectos.setItem(0, 0, mensaje)
            self.tabla_proyectos.setSpan(0, 0, 1, 3)
            return
        
        # Configurar el número de filas para los proyectos con versión más alta
        self.tabla_proyectos.setRowCount(len(proyectos_con_version_alta))
        
        # Cargar datos de proyectos con versión más alta
        for i, proyecto_data in enumerate(proyectos_con_version_alta):
            # Crear elementos de tabla
            item_nombre = QTableWidgetItem(proyecto_data['nombre'])
            item_ruta = QTableWidgetItem(proyecto_data['ruta_actual'])
            item_ruta_alta = QTableWidgetItem(proyecto_data['ruta_alta'])
            
            # Asignar a la tabla
            self.tabla_proyectos.setItem(i, 0, item_nombre)
            self.tabla_proyectos.setItem(i, 1, item_ruta)
            self.tabla_proyectos.setItem(i, 2, item_ruta_alta)
            
            debug_print(f&quot;Añadido a tabla: {proyecto_data['nombre']}&quot;)

def buscar_ventana_existente(nombre_objeto):
    &quot;&quot;&quot;
    Busca si ya existe una ventana con el nombre de objeto especificado
    Devuelve la ventana si existe y está visible, None en caso contrario
    &quot;&quot;&quot;
    for widget in QApplication.instance().allWidgets():
        if (widget.objectName() == nombre_objeto and 
            isinstance(widget, QMainWindow) and 
            widget.isVisible()):
            return widget
    return None

def detener_temporizador():
    &quot;&quot;&quot;Detiene el temporizador global si existe&quot;&quot;&quot;
    global temporizador_global
    if temporizador_global is not None and temporizador_global.isActive():
        print(f&quot;Deteniendo temporizador con ID: {temporizador_id}&quot;)
        temporizador_global.stop()
        temporizador_global = None

def iniciar_temporizador():
    &quot;&quot;&quot;Inicia o reinicia el temporizador global&quot;&quot;&quot;
    global temporizador_global, INTERVALO_TEMPORIZADOR
    
    # Detener temporizador existente si hay alguno
    detener_temporizador()
    
    # Crear un nuevo temporizador
    temporizador_global = QTimer()
    temporizador_global.setObjectName(temporizador_id)
    temporizador_global.timeout.connect(main)
    temporizador_global.start(INTERVALO_TEMPORIZADOR * 60 * 1000)  # Convertir minutos a milisegundos
    
    print(f&quot;Iniciado temporizador con ID: {temporizador_id}, intervalo: {INTERVALO_TEMPORIZADOR} minutos&quot;)

def actualizar_intervalo_temporizador(nuevo_intervalo):
    &quot;&quot;&quot;Actualiza el intervalo del temporizador y lo reinicia&quot;&quot;&quot;
    global INTERVALO_TEMPORIZADOR
    
    # Actualizar la variable global
    INTERVALO_TEMPORIZADOR = nuevo_intervalo
    
    # Reiniciar el temporizador con el nuevo intervalo
    iniciar_temporizador()
    
    # Actualizar la etiqueta en la ventana si existe
    ventana_existente = buscar_ventana_existente(&quot;LGA_ProyectosAbertosDialog&quot;)
    if ventana_existente:
        ventana_existente.label_timer.setText(f&quot;Actualizando cada {INTERVALO_TEMPORIZADOR} minutos&quot;)

def main():
    &quot;&quot;&quot;Función principal que muestra el diálogo con los proyectos abiertos&quot;&quot;&quot;
    # Verificar si ya existe una ventana abierta con el mismo nombre de objeto
    ventana_existente = buscar_ventana_existente(&quot;LGA_ProyectosAbertosDialog&quot;)
    
    if ventana_existente:
        # Si ya existe, mostrar su ID y activarla
        print(f&quot;Ya existe una ventana con ID: {ventana_existente.winId()}&quot;)
        print(f&quot;Usando ventana existente con nombre de objeto: {ventana_existente.objectName()}&quot;)
        
        # Actualizar los datos de la ventana existente
        ventana_existente.actualizar_proyectos()
        
        # Activar la ventana existente (traerla al frente)
        ventana_existente.setWindowState(ventana_existente.windowState() &amp; ~Qt.WindowMinimized | Qt.WindowActive)
        ventana_existente.activateWindow()
        ventana_existente.raise_()
    else:
        # Si no existe, crear una nueva ventana
        global ventana_proyectos
        ventana_proyectos = ProyectosAbertosDialog(hiero.ui.mainWindow())
        ventana_proyectos.show()  # Usar show() en lugar de exec_() para modo no modal
    
    # Iniciar o reiniciar el temporizador
    iniciar_temporizador()

if __name__ == &quot;__main__&quot;:
    main() &quot;&quot;&quot;
__________________________________________________________

  LGA_build_iteration v1.2 | 2024 | Lega
  Genera un arbol de nodos usado para generar variaciones
  de una imagen.

  Si no hay nodo seleccionado, crea el árbol de nodos
  en la posición del cursor.
__________________________________________________________

&quot;&quot;&quot;

import nuke
from PySide2.QtGui import QCursor, QMouseEvent
from PySide2.QtWidgets import QApplication
from PySide2.QtCore import Qt, QEvent, QPoint

# Variable global para activar o desactivar los prints
DEBUG = False

# Valor predeterminado por si el nodo preferences no existe
DEFAULT_DOT_WIDTH = 12


def debug_print(message):
    if DEBUG:
        print(message)


def simulate_dag_click():
    &quot;&quot;&quot;Simula un click en el DAG en la posición actual del cursor&quot;&quot;&quot;
    widget = QApplication.widgetAt(QCursor.pos())
    if widget:
        cursor_pos = QCursor.pos()
        local_pos = widget.mapFromGlobal(cursor_pos)

        # Mouse press
        press_event = QMouseEvent(
            QEvent.MouseButtonPress,
            local_pos,
            Qt.LeftButton,
            Qt.LeftButton,
            Qt.NoModifier,
        )
        QApplication.sendEvent(widget, press_event)

        # Mouse release
        release_event = QMouseEvent(
            QEvent.MouseButtonRelease,
            local_pos,
            Qt.LeftButton,
            Qt.LeftButton,
            Qt.NoModifier,
        )
        QApplication.sendEvent(widget, release_event)


def gen_iteration():
    # Distancia entre nodos
    distanciaY = 70
    distanciaY_columna_lateral = (
        30  # Distancia vertical entre nodos en la columna lateral
    )
    distanciaX = -140  # Distancia fija a la izquierda (versión lejana)

    # Intentar obtener dot_width desde las preferencias, usar valor predeterminado si falla
    prefs_node = nuke.toNode(&quot;preferences&quot;)
    if prefs_node and &quot;dot_node_scale&quot; in prefs_node.knobs():
        dot_width = int(prefs_node[&quot;dot_node_scale&quot;].value() * 12)
    else:
        dot_width = DEFAULT_DOT_WIDTH  # Usar valor predeterminado

    # Obtener el nodo seleccionado
    selected_node = None
    no_op = None

    try:
        selected_node = nuke.selectedNode()
    except ValueError:
        # Si no hay nodo seleccionado, simular click en el DAG antes de crear el NoOp
        simulate_dag_click()

        # Crear un NoOp en la posición del cursor, pero más arriba para que el dot quede en la posición del cursor
        no_op = nuke.createNode(&quot;NoOp&quot;)

        # Ajustar la posición vertical del NoOp para que el dot quede cerca de donde estaba el cursor
        no_op.setYpos(no_op.ypos() - distanciaY)

        selected_node = no_op

    debug_print(f&quot;Nodo seleccionado/creado: {selected_node.name()}&quot;)

    pos_tolerance = 120  # Tolerancia para la posicion en X
    current_node_center_x = selected_node.xpos() + (selected_node.screenWidth() / 2)
    current_node_center_y = selected_node.ypos() + (selected_node.screenHeight() / 2)

    # Buscar el primer nodo que este debajo del nodo seleccionado con una tolerancia en X
    all_nodes = [
        n
        for n in nuke.allNodes()
        if n != selected_node and n.Class() != &quot;Root&quot; and n.Class() != &quot;BackdropNode&quot;
    ]
    nodo_siguiente_en_columna = None
    distMedia_NodoSiguiente = float(&quot;inf&quot;)

    for node in all_nodes:
        node_center_x = node.xpos() + (node.screenWidth() / 2)
        node_center_y = node.ypos() + (node.screenHeight() / 2)

        # Verifica si el nodo esta dentro de la tolerancia y en la direccion correcta (debajo del nodo actual)
        if (
            abs(node_center_x - current_node_center_x) &lt;= pos_tolerance
            and node_center_y &gt; current_node_center_y
        ):
            distance = node_center_y - current_node_center_y
            if distance &gt; 0 and distance &lt; distMedia_NodoSiguiente:
                distMedia_NodoSiguiente = distance
                nodo_siguiente_en_columna = node
                debug_print(
                    f&quot;Nodo siguiente en la misma columna encontrado: {nodo_siguiente_en_columna.name()} a distancia {distMedia_NodoSiguiente}&quot;
                )

    # Ajuste de la distancia Y si es necesario
    if distMedia_NodoSiguiente != float(&quot;inf&quot;):
        if distMedia_NodoSiguiente &lt; distanciaY * 2:
            distanciaY = distMedia_NodoSiguiente / 2 - (dot_width / 2) - 6
        debug_print(f&quot;Distancia Y ajustada a: {distanciaY}&quot;)

    # Calcular la posicion Y del dot
    new_y_pos = int(selected_node.ypos() + selected_node.screenHeight() + distanciaY)
    debug_print(f&quot;Posicion Y del nuevo Dot: {new_y_pos}&quot;)

    # Crear un nuevo nodo de Dot debajo del nodo seleccionado
    dot_node = nuke.nodes.Dot()

    # Calcular la posicion X para centrar el Dot horizontalmente
    dot_xpos = int(
        selected_node.xpos() + (selected_node.screenWidth() / 2) - (dot_width / 2)
    )

    # Establecer la nueva posicion del nodo Dot
    dot_node.setXpos(dot_xpos)
    dot_node.setYpos(new_y_pos)

    # Conectar el nodo seleccionado al nodo de Dot
    dot_node.setInput(0, selected_node)
    debug_print(
        f&quot;Nuevo Dot creado y conectado al nodo seleccionado: {selected_node.name()}&quot;
    )

    # Guardar la conexión original del nodo siguiente antes de modificarla
    next_node_input_index = -1
    if (
        nodo_siguiente_en_columna
        and selected_node in nodo_siguiente_en_columna.dependencies(nuke.INPUTS)
    ):
        for i in range(nodo_siguiente_en_columna.inputs()):
            if nodo_siguiente_en_columna.input(i) == selected_node:
                # Reconectar la entrada del nodo siguiente al dot principal
                nodo_siguiente_en_columna.setInput(i, dot_node)
                next_node_input_index = i  # Guardamos el indice donde estaba conectado
                debug_print(
                    f&quot;Nodo siguiente en la columna conectado al nuevo Dot principal: {nodo_siguiente_en_columna.name()}&quot;
                )
                break

    # Crear un nuevo nodo de Dot a la izquierda del Dot recien creado
    dot_side = nuke.nodes.Dot()
    dot_side.setXpos(dot_node.xpos() + distanciaX)
    dot_side.setYpos(dot_node.ypos())
    dot_side.setInput(0, dot_node)
    debug_print(f&quot;Nuevo Dot lateral creado y conectado al Dot principal&quot;)

    # Crear un nodo TimeOffset debajo del dot lateral
    timeoffset = nuke.nodes.TimeOffset()
    timeoffset.setXpos(
        dot_side.xpos() - (timeoffset.screenWidth() // 2) + (dot_width // 2)
    )
    timeoffset.setYpos(
        dot_side.ypos() + dot_side.screenHeight() + distanciaY_columna_lateral
    )
    timeoffset.setInput(0, dot_side)
    timeoffset[&quot;time_offset&quot;].setValue(-1)
    debug_print(f&quot;Nuevo TimeOffset creado y conectado al Dot lateral&quot;)

    # Crear un nodo Transform debajo del TimeOffset
    transform = nuke.nodes.Transform()
    transform.setXpos(timeoffset.xpos())
    transform.setYpos(
        timeoffset.ypos() + timeoffset.screenHeight() + distanciaY_columna_lateral
    )
    transform.setInput(0, timeoffset)
    debug_print(f&quot;Nuevo Transform creado y conectado al TimeOffset&quot;)

    # Crear un dot debajo del Transform
    dot_transform = nuke.nodes.Dot()
    # Calcular la posición X para centrar el Dot horizontalmente respecto al Transform
    dot_transform_xpos = int(
        transform.xpos() + (transform.screenWidth() / 2) - (dot_width / 2)
    )
    dot_transform.setXpos(dot_transform_xpos)
    dot_transform.setYpos(
        transform.ypos() + transform.screenHeight() + distanciaY_columna_lateral
    )
    dot_transform.setInput(0, transform)
    debug_print(f&quot;Nuevo Dot creado debajo del Transform y conectado a él&quot;)

    # Crear un nodo Merge debajo del dot principal
    merge = nuke.nodes.Merge2()

    # Posicionar el Merge debajo del dot principal y alineado verticalmente con el último dot
    merge.setXpos(dot_node.xpos() - (merge.screenWidth() // 2) + (dot_width // 2))

    # Calculamos la posición Y del Merge para alinear su centro con el centro del último dot
    # Obtenemos el centro del dot_transform
    dot_transform_center_y = dot_transform.ypos() + (dot_transform.screenHeight() // 2)
    # Posicionamos el Merge para que su centro coincida con el centro del dot
    merge.setYpos(dot_transform_center_y - (merge.screenHeight() // 2))

    # Configurar el nodo Merge
    merge[&quot;operation&quot;].setValue(&quot;over&quot;)
    merge[&quot;bbox&quot;].setValue(&quot;union&quot;)

    # Conectar el dot principal al input B (input 0) del Merge
    merge.setInput(0, dot_node)
    # Conectar el último dot (debajo del Transform) al input A (input 1) del Merge
    merge.setInput(1, dot_transform)

    debug_print(
        f&quot;Nuevo Merge creado y conectado al Dot principal en el input B y al último dot en el input A&quot;
    )

    # Reconectar el nodo siguiente (si existia y estaba conectado al dot principal) a la salida del Merge
    if nodo_siguiente_en_columna and next_node_input_index != -1:
        # Verificamos si la entrada sigue conectada al dot_node (podria haber cambiado por otra operacion)
        if nodo_siguiente_en_columna.input(next_node_input_index) == dot_node:
            nodo_siguiente_en_columna.setInput(next_node_input_index, merge)
            debug_print(
                f&quot;Nodo siguiente en la columna reconectado a la salida del Merge: {nodo_siguiente_en_columna.name()}&quot;
            )

    # Deseleccionar todos los nodos existentes
    for n in nuke.allNodes():
        n[&quot;selected&quot;].setValue(False)

    # Al final de la función, seleccionar solo los nuevos nodos
    dot_node[&quot;selected&quot;].setValue(True)
    dot_side[&quot;selected&quot;].setValue(True)
    timeoffset[&quot;selected&quot;].setValue(True)
    transform[&quot;selected&quot;].setValue(True)
    dot_transform[&quot;selected&quot;].setValue(True)
    merge[&quot;selected&quot;].setValue(True)

    # Eliminar el NoOp si fue creado
    if no_op:
        nuke.delete(no_op)
        debug_print(&quot;NoOp temporal eliminado&quot;)


gen_iteration()
&quot;&quot;&quot;
_____________________________________________________________________________________________________

  LGA_showInFlow v2.1 | 2024 | Lega
  Abre la URL de la task Comp del shot, tomando la informacion del nombre del script

  Para el login en Windows hay que guardar la informacion del sitio variables de entorno:

  1- Abrir el cmd como administrador.

  2- Usar los siguientes comandos para establecer las variables de entorno (ponerlos uno por uno):

  setx SHOTGRID_URL &quot;https://pagina.shotgrid.autodesk.com&quot;
  setx SHOTGRID_LOGIN &quot;tu_usuario&quot;
  setx SHOTGRID_PASSWORD &quot;tu_contrasena&quot;

  (el usuario es el mail que se usa para login)
_____________________________________________________________________________________________________
&quot;&quot;&quot;

import os
import sys
import re
import platform
import nuke
import webbrowser
import threading
import subprocess
import configparser

# Agregar la ruta de la carpeta shotgun_api3 al sys.path
script_dir = os.path.dirname(os.path.abspath(__file__))
shotgun_api_path = os.path.join(script_dir, &quot;shotgun_api3&quot;)
sys.path.append(shotgun_api_path)

# Ahora importamos shotgun_api3
import shotgun_api3

# Constantes para el archivo de configuracion
CONFIG_FILE_NAME = &quot;ShowInFlow.ini&quot;
CONFIG_SECTION = &quot;Credentials&quot;
CONFIG_URL_KEY = &quot;shotgrid_url&quot;
CONFIG_LOGIN_KEY = &quot;shotgrid_login&quot;
CONFIG_PASSWORD_KEY = &quot;shotgrid_password&quot;


# --- Inicio: Funciones de manejo de configuracion ---


def get_config_path():
    &quot;&quot;&quot;Devuelve la ruta completa al archivo de configuracion.&quot;&quot;&quot;
    try:
        appdata_path = os.getenv(&quot;APPDATA&quot;)
        if not appdata_path:
            print(&quot;Error: No se pudo encontrar la variable de entorno APPDATA.&quot;)
            return None
        config_dir = os.path.join(appdata_path, &quot;LGA&quot;, &quot;ToolPack&quot;)
        return os.path.join(config_dir, CONFIG_FILE_NAME)
    except Exception as e:
        print(f&quot;Error al obtener la ruta de configuracion: {e}&quot;)
        return None


def ensure_config_exists():
    &quot;&quot;&quot;
    Asegura que el directorio de configuracion y el archivo .ini existan.
    Si no existen, los crea vacios.
    &quot;&quot;&quot;
    config_file_path = get_config_path()
    if not config_file_path:
        return False  # Indicar fallo si no se pudo obtener la ruta

    config_dir = os.path.dirname(config_file_path)

    try:
        # Crear el directorio si no existe
        if not os.path.exists(config_dir):
            os.makedirs(config_dir)
            print(f&quot;Directorio creado: {config_dir}&quot;)

        # Crear el archivo .ini si no existe
        if not os.path.exists(config_file_path):
            config = configparser.ConfigParser()
            config[CONFIG_SECTION] = {}  # Crear seccion vacia
            with open(config_file_path, &quot;w&quot;) as configfile:
                config.write(configfile)
            print(
                f&quot;Archivo de configuración creado: {config_file_path}. Por favor, complételo con sus credenciales.&quot;
            )
            return False  # Indicar que el archivo fue creado y esta vacio
        return True  # Indicar que el archivo ya existia (o se creo correctamente antes)

    except Exception as e:
        print(f&quot;Error al asegurar la configuración: {e}&quot;)
        return False


def get_credentials_from_config():
    &quot;&quot;&quot;
    Lee las credenciales de ShotGrid desde el archivo de configuracion .ini.
    Devuelve (url, login, password) o (None, None, None) si hay errores o faltan datos.
    &quot;&quot;&quot;
    config_file_path = get_config_path()
    if not config_file_path or not os.path.exists(config_file_path):
        print(&quot;Archivo de configuración no encontrado.&quot;)
        return None, None, None

    try:
        config = configparser.ConfigParser()
        config.read(config_file_path)

        # Verificar si la seccion y las claves existen
        if (
            config.has_section(CONFIG_SECTION)
            and config.has_option(CONFIG_SECTION, CONFIG_URL_KEY)
            and config.has_option(CONFIG_SECTION, CONFIG_LOGIN_KEY)
            and config.has_option(CONFIG_SECTION, CONFIG_PASSWORD_KEY)
        ):

            sg_url = config.get(CONFIG_SECTION, CONFIG_URL_KEY).strip()
            sg_login = config.get(CONFIG_SECTION, CONFIG_LOGIN_KEY).strip()
            sg_password = config.get(CONFIG_SECTION, CONFIG_PASSWORD_KEY).strip()

            # Validar que los valores no esten vacios
            if sg_url and sg_login and sg_password:
                return sg_url, sg_login, sg_password
            else:
                print(f&quot;Una o más credenciales en {config_file_path} están vacías.&quot;)
                return None, None, None
        else:
            print(
                f&quot;Sección [{CONFIG_SECTION}] o alguna de las claves '{CONFIG_URL_KEY}', '{CONFIG_LOGIN_KEY}', '{CONFIG_PASSWORD_KEY}' no encontrada en {config_file_path}.&quot;
            )
            return None, None, None

    except configparser.Error as e:
        print(f&quot;Error al leer el archivo de configuración {config_file_path}: {e}.&quot;)
        return None, None, None
    except Exception as e:
        print(f&quot;Error inesperado al leer la configuración: {e}.&quot;)
        return None, None, None


# --- Fin: Funciones de manejo de configuracion ---


# Verificacion del sistema operativo y configuracion de la ruta del navegador
if platform.system() == &quot;Windows&quot;:
    # print(&quot;Windows&quot;)
    browser_path = &quot;C:/Program Files/Google/Chrome/Application/chrome.exe %s&quot;
elif platform.system() == &quot;Darwin&quot;:  # macOS
    # print(&quot;mac&quot;)
    browser_path = &quot;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome&quot;
else:
    # No es necesario el debug_print aqui, la ruta quedara vacia si no es Win/Mac
    browser_path = &quot;&quot;

use_default_browser = False  # Si esta en True, usa el navegador por defecto, si esta en False, usa browser_path

DEBUG = False


def debug_print(*message):
    if DEBUG:
        print(*message)


class ShotGridManager:
    def __init__(self, url, login, password):
        self.sg = shotgun_api3.Shotgun(url, login=login, password=password)

    def find_shot_and_tasks(self, project_name, shot_code):
        debug_print(f&quot;Buscando proyecto: {project_name}, shot: {shot_code}&quot;)
        projects = self.sg.find(
            &quot;Project&quot;, [[&quot;name&quot;, &quot;is&quot;, project_name]], [&quot;id&quot;, &quot;name&quot;]
        )
        if projects:
            project_id = projects[0][&quot;id&quot;]
            debug_print(f&quot;Proyecto encontrado: {project_id}&quot;)
            filters = [
                [&quot;project&quot;, &quot;is&quot;, {&quot;type&quot;: &quot;Project&quot;, &quot;id&quot;: project_id}],
                [&quot;code&quot;, &quot;is&quot;, shot_code],
            ]
            fields = [&quot;id&quot;, &quot;code&quot;, &quot;description&quot;]
            shots = self.sg.find(&quot;Shot&quot;, filters, fields)
            if shots:
                shot_id = shots[0][&quot;id&quot;]
                debug_print(f&quot;Shot encontrado: {shot_id}&quot;)
                tasks = self.find_tasks_for_shot(shot_id)
                return shots[0], tasks
            else:
                debug_print(&quot;No se encontro el shot.&quot;)
        else:
            debug_print(&quot;No se encontro el proyecto en ShotGrid.&quot;)
        return None, None

    def find_tasks_for_shot(self, shot_id):
        debug_print(f&quot;Buscando tareas para el shot: {shot_id}&quot;)
        filters = [[&quot;entity&quot;, &quot;is&quot;, {&quot;type&quot;: &quot;Shot&quot;, &quot;id&quot;: shot_id}]]
        fields = [&quot;id&quot;, &quot;content&quot;, &quot;sg_status_list&quot;]
        tasks = self.sg.find(&quot;Task&quot;, filters, fields)
        debug_print(f&quot;Tareas encontradas: {tasks}&quot;)
        return tasks

    def get_task_url(self, task_id):
        # Usa self.sg.base_url que ya contiene la URL base leida
        return f&quot;{self.sg.base_url}/detail/Task/{task_id}&quot;


class NukeOperations:
    def __init__(self, shotgrid_manager):
        self.sg_manager = shotgrid_manager

    def parse_nuke_script_name(self, file_name):
        base_name = re.sub(r&quot;_%04d\.nk$&quot;, &quot;&quot;, file_name)
        version_match = re.search(r&quot;_v(\d+)&quot;, base_name)
        version_number = version_match.group(1) if version_match else &quot;Unknown&quot;
        return base_name, version_number

    def process_current_script(self):
        file_path = nuke.root().name()
        debug_print(f&quot;Nuke script file path: {file_path}&quot;)
        if file_path:
            nuke_script_name = os.path.basename(file_path)
            debug_print(f&quot;Nuke script name: {nuke_script_name}&quot;)
            base_name, nuke_version_number = self.parse_nuke_script_name(
                nuke_script_name
            )
            debug_print(
                f&quot;Parsed base name: {base_name}, version number: {nuke_version_number}&quot;
            )
            project_name = base_name.split(&quot;_&quot;)[0]
            parts = base_name.split(&quot;_&quot;)
            shot_code = &quot;_&quot;.join(parts[:5])
            debug_print(f&quot;Project name: {project_name}, shot code: {shot_code}&quot;)

            shot, tasks = self.sg_manager.find_shot_and_tasks(project_name, shot_code)
            if shot:
                for task in tasks:
                    if task[&quot;content&quot;] == &quot;Comp&quot;:
                        task_url = self.sg_manager.get_task_url(task[&quot;id&quot;])
                        debug_print(
                            f&quot;  - Task: {task['content']} (Status: {task['sg_status_list']}) URL: {task_url}&quot;
                        )
                        if use_default_browser:
                            webbrowser.open(task_url)
                        else:
                            self.open_url_in_browser(task_url)
            else:
                debug_print(&quot;No se encontro el shot correspondiente en ShotGrid.&quot;)
        else:
            debug_print(&quot;No se encontro un script activo en Nuke.&quot;)

    def open_url_in_browser(self, url):
        if platform.system() == &quot;Darwin&quot;:  # macOS
            try:
                subprocess.run([browser_path, url])
                debug_print(f&quot;Opening {url} in specified browser on macOS...&quot;)
            except Exception as e:
                debug_print(f&quot;Failed to open URL in specified browser on macOS: {e}&quot;)
        elif platform.system() == &quot;Windows&quot;:
            debug_print(&quot;Windows&quot;)
            try:
                webbrowser.get(browser_path).open(url)
                debug_print(f&quot;Opening {url} in specified browser on Windows...&quot;)
            except Exception as e:
                debug_print(f&quot;Failed to open URL in specified browser on Windows: {e}&quot;)


def threaded_function():
    # Primero asegurar que el archivo de config existe
    if not ensure_config_exists():
        # Si ensure_config_exists devuelve False, significa que se creo el archivo
        # o hubo un error. En ambos casos, no podemos proceder sin credenciales.
        nuke.message(
            &quot;Archivo de configuración 'ShowInFlow.ini' no encontrado o recién creado.\nPor favor, configúrelo con sus credenciales en:\n%APPDATA%\\LGA\\ToolPack\\&quot;
        )
        return

    # Leer credenciales desde el archivo .ini
    sg_url, sg_login, sg_password = get_credentials_from_config()

    if not sg_url or not sg_login or not sg_password:
        debug_print(
            &quot;Las credenciales de ShotGrid no se encontraron o están incompletas en el archivo de configuración.&quot;
        )
        # Mostrar mensaje al usuario tambien
        config_path = get_config_path()
        nuke.message(
            f&quot;No se pudieron leer las credenciales de ShotGrid desde:\n{config_path}\n\nAsegúrese de que el archivo exista y contenga las claves '{CONFIG_URL_KEY}', '{CONFIG_LOGIN_KEY}', y '{CONFIG_PASSWORD_KEY}' en la sección '[{CONFIG_SECTION}]'.&quot;
        )
        return

    try:
        sg_manager = ShotGridManager(sg_url, sg_login, sg_password)
        nuke_ops = NukeOperations(sg_manager)
        nuke_ops.process_current_script()
    except shotgun_api3.AuthenticationFault:
        nuke.message(
            f&quot;Error de autenticación con ShotGrid. Verifique las credenciales en:\n{get_config_path()}&quot;
        )
    except Exception as e:
        nuke.message(f&quot;Ocurrió un error inesperado: {e}&quot;)
        debug_print(f&quot;Error detallado: {e}&quot;)


def main():
    thread = threading.Thread(target=threaded_function)
    thread.start()

    # Este join lo tuve que agregar en MAC. Volver a probar en mac y si es necesario agregarlo,
    # entonces le ponemos un IF porque me cuelga la interface en windows mientras se ejecuta:
    # thread.join() #


if __name__ == &quot;__main__&quot;:
    main()
&quot;&quot;&quot;
_____________________________________________________________________________________________________

  LGA_showInFlow v2.1 | 2024 | Lega
  Abre la URL de la task Comp del shot, tomando la informacion del nombre del script

  Para el login en Windows hay que guardar la informacion del sitio variables de entorno:

  1- Abrir el cmd como administrador.

  2- Usar los siguientes comandos para establecer las variables de entorno (ponerlos uno por uno):

  setx SHOTGRID_URL &quot;https://pagina.shotgrid.autodesk.com&quot;
  setx SHOTGRID_LOGIN &quot;tu_usuario&quot;
  setx SHOTGRID_PASSWORD &quot;tu_contrasena&quot;

  (el usuario es el mail que se usa para login)
_____________________________________________________________________________________________________
&quot;&quot;&quot;

import os
import sys
import re
import platform
import nuke
import webbrowser
import threading
import subprocess
import configparser

# Agregar la ruta de la carpeta shotgun_api3 al sys.path
script_dir = os.path.dirname(os.path.abspath(__file__))
shotgun_api_path = os.path.join(script_dir, &quot;shotgun_api3&quot;)
sys.path.append(shotgun_api_path)

# Ahora importamos shotgun_api3
import shotgun_api3

# Constantes para el archivo de configuracion
CONFIG_FILE_NAME = &quot;ShowInFlow.ini&quot;
CONFIG_SECTION = &quot;Credentials&quot;
CONFIG_URL_KEY = &quot;shotgrid_url&quot;
CONFIG_LOGIN_KEY = &quot;shotgrid_login&quot;
CONFIG_PASSWORD_KEY = &quot;shotgrid_password&quot;

# --- Inicio: Funciones de manejo de configuracion ---


def get_config_path():
    &quot;&quot;&quot;Devuelve la ruta completa al archivo de configuracion.&quot;&quot;&quot;
    try:
        appdata_path = os.getenv(&quot;APPDATA&quot;)
        if not appdata_path:
            # Usar nuke.message para errores criticos en Nuke
            nuke.message(&quot;Error: No se pudo encontrar la variable de entorno APPDATA.&quot;)
            return None
        config_dir = os.path.join(appdata_path, &quot;LGA&quot;, &quot;ToolPack&quot;)
        return os.path.join(config_dir, CONFIG_FILE_NAME)
    except Exception as e:
        nuke.message(f&quot;Error al obtener la ruta de configuracion: {e}&quot;)
        return None


def ensure_config_exists():
    &quot;&quot;&quot;
    Asegura que el directorio de configuracion y el archivo .ini existan.
    Si no existen, los crea vacios y devuelve False.
    Devuelve True si el archivo ya existe.
    &quot;&quot;&quot;
    config_file_path = get_config_path()
    if not config_file_path:
        return False  # Fallo al obtener la ruta

    config_dir = os.path.dirname(config_file_path)

    try:
        # Crear el directorio si no existe
        if not os.path.exists(config_dir):
            os.makedirs(config_dir)
            print(f&quot;Directorio de configuracion creado: {config_dir}&quot;)

        # Crear el archivo .ini si no existe
        if not os.path.exists(config_file_path):
            config = configparser.ConfigParser()
            config[CONFIG_SECTION] = {
                CONFIG_URL_KEY: &quot;&quot;,
                CONFIG_LOGIN_KEY: &quot;&quot;,
                CONFIG_PASSWORD_KEY: &quot;&quot;,
            }
            with open(config_file_path, &quot;w&quot;) as configfile:
                config.write(configfile)
            nuke.message(
                f&quot;Archivo de configuración creado: {config_file_path}\n&quot;
                + &quot;Por favor, complételo con sus credenciales de ShotGrid.&quot;
            )
            return False  # Indicar que el archivo fue creado y necesita datos
        return True  # Indicar que el archivo ya existia

    except Exception as e:
        nuke.message(f&quot;Error al asegurar la configuración: {e}&quot;)
        return False


def get_credentials_from_config():
    &quot;&quot;&quot;
    Lee las credenciales de ShotGrid desde el archivo .ini.
    Devuelve (url, login, password) o (None, None, None) si hay errores o faltan datos.
    &quot;&quot;&quot;
    config_file_path = get_config_path()
    if not config_file_path or not os.path.exists(config_file_path):
        # ensure_config_exists deberia haberlo creado o mostrado error
        return None, None, None

    try:
        config = configparser.ConfigParser()
        # Leer el archivo especificando la codificacion por si acaso
        config.read(config_file_path, encoding=&quot;utf-8&quot;)

        # Verificar si la seccion existe
        if not config.has_section(CONFIG_SECTION):
            nuke.message(f&quot;Falta la sección [{CONFIG_SECTION}] en {config_file_path}&quot;)
            return None, None, None

        # Obtener valores, usando None como default si falta la clave
        sg_url = config.get(CONFIG_SECTION, CONFIG_URL_KEY, fallback=None)
        sg_login = config.get(CONFIG_SECTION, CONFIG_LOGIN_KEY, fallback=None)
        sg_password = config.get(CONFIG_SECTION, CONFIG_PASSWORD_KEY, fallback=None)

        # Verificar que todas las credenciales se hayan obtenido y no esten vacias
        if sg_url and sg_login and sg_password:
            return sg_url.strip(), sg_login.strip(), sg_password.strip()
        else:
            missing = []
            if not sg_url:
                missing.append(CONFIG_URL_KEY)
            if not sg_login:
                missing.append(CONFIG_LOGIN_KEY)
            if not sg_password:
                missing.append(CONFIG_PASSWORD_KEY)
            nuke.message(
                f&quot;Faltan o están vacías las siguientes credenciales en {config_file_path}:\n&quot;
                + &quot;, &quot;.join(missing)
            )
            return None, None, None

    except configparser.Error as e:
        nuke.message(
            f&quot;Error al leer el archivo de configuración {config_file_path}: {e}&quot;
        )
        return None, None, None
    except Exception as e:
        nuke.message(f&quot;Error inesperado al leer la configuración: {e}&quot;)
        return None, None, None


# --- Fin: Funciones de manejo de configuracion ---


def debug_print(*message):
    if DEBUG:
        print(*message)


# Verificacion del sistema operativo y configuracion de la ruta del navegador
if platform.system() == &quot;Windows&quot;:
    # print(&quot;Windows&quot;)
    browser_path = &quot;C:/Program Files/Google/Chrome/Application/chrome.exe %s&quot;
elif platform.system() == &quot;Darwin&quot;:  # macOS
    # print(&quot;mac&quot;)
    browser_path = &quot;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome&quot;
else:
    browser_path = &quot;&quot;  # Ruta del navegador para otros sistemas, si aplica
    debug_print(&quot;No se detecto el OS&quot;)

use_default_browser = False  # Si esta en True, usa el navegador por defecto, si esta en False, usa browser_path

DEBUG = False


class ShotGridManager:
    def __init__(self, url, login, password):
        self.sg = shotgun_api3.Shotgun(url, login=login, password=password)

    def find_shot_and_tasks(self, project_name, shot_code):
        debug_print(f&quot;Buscando proyecto: {project_name}, shot: {shot_code}&quot;)
        projects = self.sg.find(
            &quot;Project&quot;, [[&quot;name&quot;, &quot;is&quot;, project_name]], [&quot;id&quot;, &quot;name&quot;]
        )
        if projects:
            project_id = projects[0][&quot;id&quot;]
            debug_print(f&quot;Proyecto encontrado: {project_id}&quot;)
            filters = [
                [&quot;project&quot;, &quot;is&quot;, {&quot;type&quot;: &quot;Project&quot;, &quot;id&quot;: project_id}],
                [&quot;code&quot;, &quot;is&quot;, shot_code],
            ]
            fields = [&quot;id&quot;, &quot;code&quot;, &quot;description&quot;]
            shots = self.sg.find(&quot;Shot&quot;, filters, fields)
            if shots:
                shot_id = shots[0][&quot;id&quot;]
                debug_print(f&quot;Shot encontrado: {shot_id}&quot;)
                tasks = self.find_tasks_for_shot(shot_id)
                return shots[0], tasks
            else:
                debug_print(&quot;No se encontro el shot.&quot;)
        else:
            debug_print(&quot;No se encontro el proyecto en ShotGrid.&quot;)
        return None, None

    def find_tasks_for_shot(self, shot_id):
        debug_print(f&quot;Buscando tareas para el shot: {shot_id}&quot;)
        filters = [[&quot;entity&quot;, &quot;is&quot;, {&quot;type&quot;: &quot;Shot&quot;, &quot;id&quot;: shot_id}]]
        fields = [&quot;id&quot;, &quot;content&quot;, &quot;sg_status_list&quot;]
        tasks = self.sg.find(&quot;Task&quot;, filters, fields)
        debug_print(f&quot;Tareas encontradas: {tasks}&quot;)
        return tasks

    def get_task_url(self, task_id):
        return f&quot;{self.sg.base_url}/detail/Task/{task_id}&quot;


class NukeOperations:
    def __init__(self, shotgrid_manager):
        self.sg_manager = shotgrid_manager

    def parse_nuke_script_name(self, file_name):
        base_name = re.sub(r&quot;_%04d\.nk$&quot;, &quot;&quot;, file_name)
        version_match = re.search(r&quot;_v(\d+)&quot;, base_name)
        version_number = version_match.group(1) if version_match else &quot;Unknown&quot;
        return base_name, version_number

    def process_current_script(self):
        file_path = nuke.root().name()
        debug_print(f&quot;Nuke script file path: {file_path}&quot;)
        if file_path:
            nuke_script_name = os.path.basename(file_path)
            debug_print(f&quot;Nuke script name: {nuke_script_name}&quot;)
            base_name, nuke_version_number = self.parse_nuke_script_name(
                nuke_script_name
            )
            debug_print(
                f&quot;Parsed base name: {base_name}, version number: {nuke_version_number}&quot;
            )
            project_name = base_name.split(&quot;_&quot;)[0]
            parts = base_name.split(&quot;_&quot;)
            shot_code = &quot;_&quot;.join(parts[:5])
            debug_print(f&quot;Project name: {project_name}, shot code: {shot_code}&quot;)

            shot, tasks = self.sg_manager.find_shot_and_tasks(project_name, shot_code)
            if shot:
                for task in tasks:
                    if task[&quot;content&quot;] == &quot;Comp&quot;:
                        task_url = self.sg_manager.get_task_url(task[&quot;id&quot;])
                        debug_print(
                            f&quot;  - Task: {task['content']} (Status: {task['sg_status_list']}) URL: {task_url}&quot;
                        )
                        if use_default_browser:
                            webbrowser.open(task_url)
                        else:
                            self.open_url_in_browser(task_url)
            else:
                debug_print(&quot;No se encontro el shot correspondiente en ShotGrid.&quot;)
        else:
            debug_print(&quot;No se encontro un script activo en Nuke.&quot;)

    def open_url_in_browser(self, url):
        if platform.system() == &quot;Darwin&quot;:  # macOS
            try:
                subprocess.run([browser_path, url])
                debug_print(f&quot;Opening {url} in specified browser on macOS...&quot;)
            except Exception as e:
                debug_print(f&quot;Failed to open URL in specified browser on macOS: {e}&quot;)
        elif platform.system() == &quot;Windows&quot;:
            debug_print(&quot;Windows&quot;)
            try:
                webbrowser.get(browser_path).open(url)
                debug_print(f&quot;Opening {url} in specified browser on Windows...&quot;)
            except Exception as e:
                debug_print(f&quot;Failed to open URL in specified browser on Windows: {e}&quot;)


def threaded_function():
    # 1. Asegurar que el archivo de configuracion existe
    if not ensure_config_exists():
        # Si devuelve False, ya se mostro un mensaje desde ensure_config_exists
        # sobre creacion o error. No continuar.
        return

    # 2. Leer credenciales desde el archivo .ini
    sg_url, sg_login, sg_password = get_credentials_from_config()

    # 3. Verificar que las credenciales se leyeron correctamente
    if not sg_url or not sg_login or not sg_password:
        # Si faltan credenciales, get_credentials_from_config ya mostro un mensaje
        debug_print(&quot;Credenciales no encontradas o incompletas en el archivo INI.&quot;)
        return

    # 4. Proceder con la logica principal usando las credenciales del archivo
    try:
        debug_print(f&quot;Conectando a ShotGrid URL: {sg_url} con login: {sg_login}&quot;)
        sg_manager = ShotGridManager(sg_url, sg_login, sg_password)
        nuke_ops = NukeOperations(sg_manager)
        nuke_ops.process_current_script()
    except shotgun_api3.AuthenticationFault:
        nuke.message(
            f&quot;Error de autenticación con ShotGrid.\nVerifique las credenciales en:\n{get_config_path()}&quot;
        )
        debug_print(&quot;Error de autenticación con ShotGrid.&quot;)
    except Exception as e:
        # Capturar otros posibles errores durante la ejecucion
        nuke.message(
            f&quot;Ocurrió un error inesperado al procesar la información de ShotGrid: {e}&quot;
        )
        debug_print(f&quot;Error detallado: {e}&quot;)


def main():
    thread = threading.Thread(target=threaded_function)
    thread.start()

    # Este join lo tuve que agregar en MAC. Volver a probar en mac y si es necesario agregarlo,
    # entonces le ponemos un IF porque me cuelga la interface en windows mientras se ejecuta:
    # thread.join() #


if __name__ == &quot;__main__&quot;:
    main()
&quot;&quot;&quot;
_____________________________________________________________________________________________________

  LGA_showInFlow v2.1 | 2024 | Lega
  Abre la URL de la task Comp del shot, tomando la informacion del nombre del script

  Para el login en Windows hay que guardar la informacion del sitio variables de entorno:

  1- Abrir el cmd como administrador.

  2- Usar los siguientes comandos para establecer las variables de entorno (ponerlos uno por uno):

  setx SHOTGRID_URL &quot;https://pagina.shotgrid.autodesk.com&quot;
  setx SHOTGRID_LOGIN &quot;tu_usuario&quot;
  setx SHOTGRID_PASSWORD &quot;tu_contrasena&quot;

  (el usuario es el mail que se usa para login)
_____________________________________________________________________________________________________
&quot;&quot;&quot;

import os
import sys
import re
import platform
import nuke
import webbrowser
import threading
import subprocess
import configparser

# Agregar la ruta de la carpeta shotgun_api3 al sys.path
script_dir = os.path.dirname(os.path.abspath(__file__))
shotgun_api_path = os.path.join(script_dir, &quot;shotgun_api3&quot;)
sys.path.append(shotgun_api_path)

# Ahora importamos shotgun_api3
import shotgun_api3

# Constantes para el archivo de configuracion (adaptadas del ejemplo)
CONFIG_FILE_NAME = &quot;ShowInFlow.ini&quot;
CONFIG_SECTION = &quot;Credentials&quot;
CONFIG_URL_KEY = &quot;shotgrid_url&quot;
CONFIG_LOGIN_KEY = &quot;shotgrid_login&quot;
CONFIG_PASSWORD_KEY = &quot;shotgrid_password&quot;

# --- Inicio: Funciones de manejo de configuracion (basadas en LGA_Write_Focus.py) ---


def get_config_path():
    &quot;&quot;&quot;Devuelve la ruta completa al archivo de configuracion.&quot;&quot;&quot;
    try:
        appdata_path = os.getenv(&quot;APPDATA&quot;)
        if not appdata_path:
            print(&quot;Error: No se pudo encontrar la variable de entorno APPDATA.&quot;)
            return None
        config_dir = os.path.join(appdata_path, &quot;LGA&quot;, &quot;ToolPack&quot;)
        return os.path.join(config_dir, CONFIG_FILE_NAME)
    except Exception as e:
        print(f&quot;Error al obtener la ruta de configuracion: {e}&quot;)
        return None


def ensure_config_exists():
    &quot;&quot;&quot;
    Asegura que el directorio de configuracion y el archivo .ini existan.
    Si no existen, los crea con valores vacios.
    &quot;&quot;&quot;
    config_file_path = get_config_path()
    if not config_file_path:
        return  # Salir si no se pudo obtener la ruta

    config_dir = os.path.dirname(config_file_path)

    try:
        # Crear el directorio si no existe
        if not os.path.exists(config_dir):
            os.makedirs(config_dir)
            print(f&quot;Directorio de configuracion creado: {config_dir}&quot;)

        # Crear el archivo .ini si no existe
        if not os.path.exists(config_file_path):
            config = configparser.ConfigParser()
            config[CONFIG_SECTION] = {
                CONFIG_URL_KEY: &quot;&quot;,
                CONFIG_LOGIN_KEY: &quot;&quot;,
                CONFIG_PASSWORD_KEY: &quot;&quot;,
            }
            with open(config_file_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as configfile:
                config.write(configfile)
            print(
                f&quot;Archivo de configuración creado: {config_file_path}. Por favor, complételo con sus credenciales.&quot;
            )
        # else: # Debugging opcional como en el ejemplo
        #     print(f&quot;Archivo de configuración ya existe: {config_file_path}&quot;)

    except Exception as e:
        print(f&quot;Error al asegurar la configuración: {e}&quot;)


def get_credentials_from_config():
    &quot;&quot;&quot;
    Lee las credenciales de ShotGrid desde el archivo .ini.
    Devuelve (url, login, password) o (None, None, None) si hay errores o faltan datos.
    Usa print para errores internos, similar al ejemplo.
    &quot;&quot;&quot;
    config_file_path = get_config_path()
    if not config_file_path or not os.path.exists(config_file_path):
        print(
            f&quot;Archivo de configuración no encontrado en la ruta esperada: {config_file_path}&quot;
        )
        return None, None, None

    try:
        config = configparser.ConfigParser()
        config.read(config_file_path, encoding=&quot;utf-8&quot;)

        # Verificar si la seccion y las claves existen
        if (
            config.has_section(CONFIG_SECTION)
            and config.has_option(CONFIG_SECTION, CONFIG_URL_KEY)
            and config.has_option(CONFIG_SECTION, CONFIG_LOGIN_KEY)
            and config.has_option(CONFIG_SECTION, CONFIG_PASSWORD_KEY)
        ):

            sg_url = config.get(CONFIG_SECTION, CONFIG_URL_KEY).strip()
            sg_login = config.get(CONFIG_SECTION, CONFIG_LOGIN_KEY).strip()
            sg_password = config.get(CONFIG_SECTION, CONFIG_PASSWORD_KEY).strip()

            # Validar que los valores no esten vacios
            if sg_url and sg_login and sg_password:
                return sg_url, sg_login, sg_password
            else:
                print(f&quot;Una o más credenciales en {config_file_path} están vacías.&quot;)
                return None, None, None
        else:
            missing = []
            if not config.has_section(CONFIG_SECTION):
                missing.append(f&quot;Seccion [{CONFIG_SECTION}]&quot;)
            if not config.has_option(CONFIG_SECTION, CONFIG_URL_KEY):
                missing.append(f&quot;Clave {CONFIG_URL_KEY}&quot;)
            if not config.has_option(CONFIG_SECTION, CONFIG_LOGIN_KEY):
                missing.append(f&quot;Clave {CONFIG_LOGIN_KEY}&quot;)
            if not config.has_option(CONFIG_SECTION, CONFIG_PASSWORD_KEY):
                missing.append(f&quot;Clave {CONFIG_PASSWORD_KEY}&quot;)
            print(
                f&quot;Configuración incompleta en {config_file_path}. Falta: {', '.join(missing)}&quot;
            )
            return None, None, None

    except configparser.Error as e:
        print(f&quot;Error al leer el archivo de configuración {config_file_path}: {e}.&quot;)
        return None, None, None
    except Exception as e:
        print(f&quot;Error inesperado al leer la configuración: {e}.&quot;)
        return None, None, None


# --- Fin: Funciones de manejo de configuracion ---

# Asegurarse de que el archivo de configuracion existe al iniciar (como en el ejemplo)
ensure_config_exists()

# Verificacion del sistema operativo y configuracion de la ruta del navegador
if platform.system() == &quot;Windows&quot;:
    # print(&quot;Windows&quot;)
    browser_path = &quot;C:/Program Files/Google/Chrome/Application/chrome.exe %s&quot;
elif platform.system() == &quot;Darwin&quot;:  # macOS
    # print(&quot;mac&quot;)
    browser_path = &quot;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome&quot;
else:
    browser_path = &quot;&quot;  # Ruta del navegador para otros sistemas, si aplica
    # debug_print (&quot;No se detecto el OS&quot;) # Corregido: Eliminado/Comentado

use_default_browser = False  # Si esta en True, usa el navegador por defecto, si esta en False, usa browser_path

DEBUG = False


def debug_print(*message):
    if DEBUG:
        print(*message)


class ShotGridManager:
    def __init__(self, url, login, password):
        self.sg = shotgun_api3.Shotgun(url, login=login, password=password)

    def find_shot_and_tasks(self, project_name, shot_code):
        debug_print(f&quot;Buscando proyecto: {project_name}, shot: {shot_code}&quot;)
        projects = self.sg.find(
            &quot;Project&quot;, [[&quot;name&quot;, &quot;is&quot;, project_name]], [&quot;id&quot;, &quot;name&quot;]
        )
        if projects:
            project_id = projects[0][&quot;id&quot;]
            debug_print(f&quot;Proyecto encontrado: {project_id}&quot;)
            filters = [
                [&quot;project&quot;, &quot;is&quot;, {&quot;type&quot;: &quot;Project&quot;, &quot;id&quot;: project_id}],
                [&quot;code&quot;, &quot;is&quot;, shot_code],
            ]
            fields = [&quot;id&quot;, &quot;code&quot;, &quot;description&quot;]
            shots = self.sg.find(&quot;Shot&quot;, filters, fields)
            if shots:
                shot_id = shots[0][&quot;id&quot;]
                debug_print(f&quot;Shot encontrado: {shot_id}&quot;)
                tasks = self.find_tasks_for_shot(shot_id)
                return shots[0], tasks
            else:
                debug_print(&quot;No se encontro el shot.&quot;)
        else:
            debug_print(&quot;No se encontro el proyecto en ShotGrid.&quot;)
        return None, None

    def find_tasks_for_shot(self, shot_id):
        debug_print(f&quot;Buscando tareas para el shot: {shot_id}&quot;)
        filters = [[&quot;entity&quot;, &quot;is&quot;, {&quot;type&quot;: &quot;Shot&quot;, &quot;id&quot;: shot_id}]]
        fields = [&quot;id&quot;, &quot;content&quot;, &quot;sg_status_list&quot;]
        tasks = self.sg.find(&quot;Task&quot;, filters, fields)
        debug_print(f&quot;Tareas encontradas: {tasks}&quot;)
        return tasks

    def get_task_url(self, task_id):
        return f&quot;{self.sg.base_url}/detail/Task/{task_id}&quot;


class NukeOperations:
    def __init__(self, shotgrid_manager):
        self.sg_manager = shotgrid_manager

    def parse_nuke_script_name(self, file_name):
        base_name = re.sub(r&quot;_%04d\.nk$&quot;, &quot;&quot;, file_name)
        version_match = re.search(r&quot;_v(\d+)&quot;, base_name)
        version_number = version_match.group(1) if version_match else &quot;Unknown&quot;
        return base_name, version_number

    def process_current_script(self):
        file_path = nuke.root().name()
        debug_print(f&quot;Nuke script file path: {file_path}&quot;)
        if file_path:
            nuke_script_name = os.path.basename(file_path)
            debug_print(f&quot;Nuke script name: {nuke_script_name}&quot;)
            base_name, nuke_version_number = self.parse_nuke_script_name(
                nuke_script_name
            )
            debug_print(
                f&quot;Parsed base name: {base_name}, version number: {nuke_version_number}&quot;
            )
            project_name = base_name.split(&quot;_&quot;)[0]
            parts = base_name.split(&quot;_&quot;)
            shot_code = &quot;_&quot;.join(parts[:5])
            debug_print(f&quot;Project name: {project_name}, shot code: {shot_code}&quot;)

            shot, tasks = self.sg_manager.find_shot_and_tasks(project_name, shot_code)
            if shot:
                for task in tasks:
                    if task[&quot;content&quot;] == &quot;Comp&quot;:
                        task_url = self.sg_manager.get_task_url(task[&quot;id&quot;])
                        debug_print(
                            f&quot;  - Task: {task['content']} (Status: {task['sg_status_list']}) URL: {task_url}&quot;
                        )
                        if use_default_browser:
                            webbrowser.open(task_url)
                        else:
                            self.open_url_in_browser(task_url)
            else:
                debug_print(&quot;No se encontro el shot correspondiente en ShotGrid.&quot;)
        else:
            debug_print(&quot;No se encontro un script activo en Nuke.&quot;)

    def open_url_in_browser(self, url):
        if platform.system() == &quot;Darwin&quot;:  # macOS
            try:
                subprocess.run([browser_path, url])
                debug_print(f&quot;Opening {url} in specified browser on macOS...&quot;)
            except Exception as e:
                debug_print(f&quot;Failed to open URL in specified browser on macOS: {e}&quot;)
        elif platform.system() == &quot;Windows&quot;:
            debug_print(&quot;Windows&quot;)
            try:
                webbrowser.get(browser_path).open(url)
                debug_print(f&quot;Opening {url} in specified browser on Windows...&quot;)
            except Exception as e:
                debug_print(f&quot;Failed to open URL in specified browser on Windows: {e}&quot;)


def threaded_function():
    # Leer credenciales desde el archivo .ini usando la funcion adaptada
    sg_url, sg_login, sg_password = get_credentials_from_config()

    # Verificar si las credenciales se leyeron correctamente
    if not sg_url or not sg_login or not sg_password:
        # Si fallo, get_credentials_from_config ya imprimio el error.
        # Mostrar mensaje en Nuke y salir del hilo.
        config_path = get_config_path() or &quot;AppData\\LGA\\ToolPack\\ShowInFlow.ini&quot;
        nuke.message(
            f&quot;No se pudieron leer las credenciales de ShotGrid desde:\n{config_path}\n\nRevise la consola para detalles y asegúrese de que el archivo esté completo.&quot;
        )
        return

    # Si las credenciales son validas, proceder con la logica original
    try:
        debug_print(f&quot;Conectando a ShotGrid URL: {sg_url} con login: {sg_login}&quot;)
        sg_manager = ShotGridManager(sg_url, sg_login, sg_password)
        nuke_ops = NukeOperations(sg_manager)
        nuke_ops.process_current_script()
    except shotgun_api3.AuthenticationFault:
        # Error especifico de autenticacion
        nuke.message(
            f&quot;Error de autenticación con ShotGrid.\nVerifique las credenciales en:\n{get_config_path()}&quot;
        )
        debug_print(&quot;Error de autenticación con ShotGrid.&quot;)
    except Exception as e:
        # Otros errores durante la conexion o procesamiento
        nuke.message(
            f&quot;Ocurrió un error al conectar o procesar la información de ShotGrid: {e}&quot;
        )
        debug_print(f&quot;Error detallado: {e}&quot;)


def main():
    thread = threading.Thread(target=threaded_function)
    thread.start()

    # Este join lo tuve que agregar en MAC. Volver a probar en mac y si es necesario agregarlo,
    # entonces le ponemos un IF porque me cuelga la interface en windows mientras se ejecuta:
    # thread.join() #


if __name__ == &quot;__main__&quot;:
    main()
&quot;&quot;&quot;
_____________________________________________________________________________________________________

  LGA_showInFlow v2.1 | 2024 | Lega
  Abre la URL de la task Comp del shot, tomando la informacion del nombre del script

  Para el login en Windows hay que guardar la informacion del sitio variables de entorno:

  1- Abrir el cmd como administrador.

  2- Usar los siguientes comandos para establecer las variables de entorno (ponerlos uno por uno):

  setx SHOTGRID_URL &quot;https://pagina.shotgrid.autodesk.com&quot;
  setx SHOTGRID_LOGIN &quot;tu_usuario&quot;
  setx SHOTGRID_PASSWORD &quot;tu_contrasena&quot;

  (el usuario es el mail que se usa para login)
_____________________________________________________________________________________________________
&quot;&quot;&quot;

import os
import sys
import re
import platform
import nuke
import webbrowser
import threading
import subprocess
import configparser

# Agregar la ruta de la carpeta shotgun_api3 al sys.path
script_dir = os.path.dirname(os.path.abspath(__file__))
shotgun_api_path = os.path.join(script_dir, &quot;shotgun_api3&quot;)
sys.path.append(shotgun_api_path)

# Ahora importamos shotgun_api3
import shotgun_api3

# Constantes para el archivo de configuracion (adaptadas del ejemplo)
CONFIG_FILE_NAME = &quot;ShowInFlow.ini&quot;
CONFIG_SECTION = &quot;Credentials&quot;
CONFIG_URL_KEY = &quot;shotgrid_url&quot;
CONFIG_LOGIN_KEY = &quot;shotgrid_login&quot;
CONFIG_PASSWORD_KEY = &quot;shotgrid_password&quot;

# --- Inicio: Funciones de manejo de configuracion (basadas en LGA_Write_Focus.py) ---


def get_config_path():
    &quot;&quot;&quot;Devuelve la ruta completa al archivo de configuracion.&quot;&quot;&quot;
    try:
        appdata_path = os.getenv(&quot;APPDATA&quot;)
        if not appdata_path:
            print(&quot;Error: No se pudo encontrar la variable de entorno APPDATA.&quot;)
            return None
        config_dir = os.path.join(appdata_path, &quot;LGA&quot;, &quot;ToolPack&quot;)
        return os.path.join(config_dir, CONFIG_FILE_NAME)
    except Exception as e:
        print(f&quot;Error al obtener la ruta de configuracion: {e}&quot;)
        return None


def ensure_config_exists():
    &quot;&quot;&quot;
    Asegura que el directorio de configuracion y el archivo .ini existan.
    Si no existen, los crea con valores vacios.
    &quot;&quot;&quot;
    config_file_path = get_config_path()
    if not config_file_path:
        return  # Salir si no se pudo obtener la ruta

    config_dir = os.path.dirname(config_file_path)

    try:
        # Crear el directorio si no existe
        if not os.path.exists(config_dir):
            os.makedirs(config_dir)
            print(f&quot;Directorio de configuracion creado: {config_dir}&quot;)

        # Crear el archivo .ini si no existe
        if not os.path.exists(config_file_path):
            config = configparser.ConfigParser()
            config[CONFIG_SECTION] = {
                CONFIG_URL_KEY: &quot;&quot;,
                CONFIG_LOGIN_KEY: &quot;&quot;,
                CONFIG_PASSWORD_KEY: &quot;&quot;,
            }
            with open(config_file_path, &quot;w&quot;, encoding=&quot;utf-8&quot;) as configfile:
                config.write(configfile)
            print(
                f&quot;Archivo de configuración creado: {config_file_path}. Por favor, complételo con sus credenciales.&quot;
            )
        # else: # Debugging opcional como en el ejemplo
        #     print(f&quot;Archivo de configuración ya existe: {config_file_path}&quot;)

    except Exception as e:
        print(f&quot;Error al asegurar la configuración: {e}&quot;)


def get_credentials_from_config():
    &quot;&quot;&quot;
    Lee las credenciales de ShotGrid desde el archivo .ini.
    Devuelve (url, login, password) o (None, None, None) si hay errores o faltan datos.
    Usa print para errores internos, similar al ejemplo.
    &quot;&quot;&quot;
    config_file_path = get_config_path()
    if not config_file_path or not os.path.exists(config_file_path):
        print(
            f&quot;Archivo de configuración no encontrado en la ruta esperada: {config_file_path}&quot;
        )
        return None, None, None

    try:
        config = configparser.ConfigParser()
        config.read(config_file_path, encoding=&quot;utf-8&quot;)

        # Verificar si la seccion y las claves existen
        if (
            config.has_section(CONFIG_SECTION)
            and config.has_option(CONFIG_SECTION, CONFIG_URL_KEY)
            and config.has_option(CONFIG_SECTION, CONFIG_LOGIN_KEY)
            and config.has_option(CONFIG_SECTION, CONFIG_PASSWORD_KEY)
        ):

            sg_url = config.get(CONFIG_SECTION, CONFIG_URL_KEY).strip()
            sg_login = config.get(CONFIG_SECTION, CONFIG_LOGIN_KEY).strip()
            sg_password = config.get(CONFIG_SECTION, CONFIG_PASSWORD_KEY).strip()

            # Validar que los valores no esten vacios
            if sg_url and sg_login and sg_password:
                return sg_url, sg_login, sg_password
            else:
                print(f&quot;Una o más credenciales en {config_file_path} están vacías.&quot;)
                return None, None, None
        else:
            missing = []
            if not config.has_section(CONFIG_SECTION):
                missing.append(f&quot;Seccion [{CONFIG_SECTION}]&quot;)
            if not config.has_option(CONFIG_SECTION, CONFIG_URL_KEY):
                missing.append(f&quot;Clave {CONFIG_URL_KEY}&quot;)
            if not config.has_option(CONFIG_SECTION, CONFIG_LOGIN_KEY):
                missing.append(f&quot;Clave {CONFIG_LOGIN_KEY}&quot;)
            if not config.has_option(CONFIG_SECTION, CONFIG_PASSWORD_KEY):
                missing.append(f&quot;Clave {CONFIG_PASSWORD_KEY}&quot;)
            print(
                f&quot;Configuración incompleta en {config_file_path}. Falta: {', '.join(missing)}&quot;
            )
            return None, None, None

    except configparser.Error as e:
        print(f&quot;Error al leer el archivo de configuración {config_file_path}: {e}.&quot;)
        return None, None, None
    except Exception as e:
        print(f&quot;Error inesperado al leer la configuración: {e}.&quot;)
        return None, None, None


# --- Fin: Funciones de manejo de configuracion ---

# Asegurarse de que el archivo de configuracion existe al iniciar (como en el ejemplo)
ensure_config_exists()

# Verificacion del sistema operativo y configuracion de la ruta del navegador
if platform.system() == &quot;Windows&quot;:
    # print(&quot;Windows&quot;)
    browser_path = &quot;C:/Program Files/Google/Chrome/Application/chrome.exe %s&quot;
elif platform.system() == &quot;Darwin&quot;:  # macOS
    # print(&quot;mac&quot;)
    browser_path = &quot;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome&quot;
else:
    browser_path = &quot;&quot;  # Ruta del navegador para otros sistemas, si aplica
    # debug_print (&quot;No se detecto el OS&quot;) # Corregido: Eliminado/Comentado

use_default_browser = False  # Si esta en True, usa el navegador por defecto, si esta en False, usa browser_path

DEBUG = False


# Definir debug_print aqui para que siempre exista
def debug_print(*message):
    if DEBUG:
        print(*message)


class ShotGridManager:
    def __init__(self, url, login, password):
        self.sg = shotgun_api3.Shotgun(url, login=login, password=password)

    def find_shot_and_tasks(self, project_name, shot_code):
        debug_print(f&quot;Buscando proyecto: {project_name}, shot: {shot_code}&quot;)
        projects = self.sg.find(
            &quot;Project&quot;, [[&quot;name&quot;, &quot;is&quot;, project_name]], [&quot;id&quot;, &quot;name&quot;]
        )
        if projects:
            project_id = projects[0][&quot;id&quot;]
            debug_print(f&quot;Proyecto encontrado: {project_id}&quot;)
            filters = [
                [&quot;project&quot;, &quot;is&quot;, {&quot;type&quot;: &quot;Project&quot;, &quot;id&quot;: project_id}],
                [&quot;code&quot;, &quot;is&quot;, shot_code],
            ]
            fields = [&quot;id&quot;, &quot;code&quot;, &quot;description&quot;]
            shots = self.sg.find(&quot;Shot&quot;, filters, fields)
            if shots:
                shot_id = shots[0][&quot;id&quot;]
                debug_print(f&quot;Shot encontrado: {shot_id}&quot;)
                tasks = self.find_tasks_for_shot(shot_id)
                return shots[0], tasks
            else:
                debug_print(&quot;No se encontro el shot.&quot;)
        else:
            debug_print(&quot;No se encontro el proyecto en ShotGrid.&quot;)
        return None, None

    def find_tasks_for_shot(self, shot_id):
        debug_print(f&quot;Buscando tareas para el shot: {shot_id}&quot;)
        filters = [[&quot;entity&quot;, &quot;is&quot;, {&quot;type&quot;: &quot;Shot&quot;, &quot;id&quot;: shot_id}]]
        fields = [&quot;id&quot;, &quot;content&quot;, &quot;sg_status_list&quot;]
        tasks = self.sg.find(&quot;Task&quot;, filters, fields)
        debug_print(f&quot;Tareas encontradas: {tasks}&quot;)
        return tasks

    def get_task_url(self, task_id):
        return f&quot;{self.sg.base_url}/detail/Task/{task_id}&quot;


class NukeOperations:
    def __init__(self, shotgrid_manager):
        self.sg_manager = shotgrid_manager

    def parse_nuke_script_name(self, file_name):
        base_name = re.sub(r&quot;_%04d\.nk$&quot;, &quot;&quot;, file_name)
        version_match = re.search(r&quot;_v(\d+)&quot;, base_name)
        version_number = version_match.group(1) if version_match else &quot;Unknown&quot;
        return base_name, version_number

    def process_current_script(self):
        file_path = nuke.root().name()
        debug_print(f&quot;Nuke script file path: {file_path}&quot;)
        if file_path:
            nuke_script_name = os.path.basename(file_path)
            debug_print(f&quot;Nuke script name: {nuke_script_name}&quot;)
            base_name, nuke_version_number = self.parse_nuke_script_name(
                nuke_script_name
            )
            debug_print(
                f&quot;Parsed base name: {base_name}, version number: {nuke_version_number}&quot;
            )
            project_name = base_name.split(&quot;_&quot;)[0]
            parts = base_name.split(&quot;_&quot;)
            shot_code = &quot;_&quot;.join(parts[:5])
            debug_print(f&quot;Project name: {project_name}, shot code: {shot_code}&quot;)

            shot, tasks = self.sg_manager.find_shot_and_tasks(project_name, shot_code)
            if shot:
                for task in tasks:
                    if task[&quot;content&quot;] == &quot;Comp&quot;:
                        task_url = self.sg_manager.get_task_url(task[&quot;id&quot;])
                        debug_print(
                            f&quot;  - Task: {task['content']} (Status: {task['sg_status_list']}) URL: {task_url}&quot;
                        )
                        if use_default_browser:
                            webbrowser.open(task_url)
                        else:
                            self.open_url_in_browser(task_url)
            else:
                debug_print(&quot;No se encontro el shot correspondiente en ShotGrid.&quot;)
        else:
            debug_print(&quot;No se encontro un script activo en Nuke.&quot;)

    def open_url_in_browser(self, url):
        if platform.system() == &quot;Darwin&quot;:  # macOS
            try:
                subprocess.run([browser_path, url])
                debug_print(f&quot;Opening {url} in specified browser on macOS...&quot;)
            except Exception as e:
                debug_print(f&quot;Failed to open URL in specified browser on macOS: {e}&quot;)
        elif platform.system() == &quot;Windows&quot;:
            debug_print(&quot;Windows&quot;)
            try:
                webbrowser.get(browser_path).open(url)
                debug_print(f&quot;Opening {url} in specified browser on Windows...&quot;)
            except Exception as e:
                debug_print(f&quot;Failed to open URL in specified browser on Windows: {e}&quot;)


def threaded_function():
    # Leer credenciales desde el archivo .ini usando la funcion adaptada
    sg_url, sg_login, sg_password = get_credentials_from_config()

    # Verificar si las credenciales se leyeron correctamente
    if not sg_url or not sg_login or not sg_password:
        # Si fallo, get_credentials_from_config ya imprimio el error.
        # Mostrar mensaje en Nuke y salir del hilo.
        config_path = get_config_path() or &quot;AppData\\LGA\\ToolPack\\ShowInFlow.ini&quot;
        nuke.message(
            f&quot;No se pudieron leer las credenciales de ShotGrid desde:\n{config_path}\n\nRevise la consola para detalles y asegúrese de que el archivo esté completo.&quot;
        )
        return

    # Si las credenciales son validas, proceder con la logica original
    try:
        debug_print(f&quot;Conectando a ShotGrid URL: {sg_url} con login: {sg_login}&quot;)
        sg_manager = ShotGridManager(sg_url, sg_login, sg_password)
        nuke_ops = NukeOperations(sg_manager)
        nuke_ops.process_current_script()
    except shotgun_api3.AuthenticationFault:
        # Error especifico de autenticacion
        nuke.message(
            f&quot;Error de autenticación con ShotGrid.\nVerifique las credenciales en:\n{get_config_path()}&quot;
        )
        debug_print(&quot;Error de autenticación con ShotGrid.&quot;)
    except Exception as e:
        # Otros errores durante la conexion o procesamiento
        nuke.message(
            f&quot;Ocurrió un error al conectar o procesar la información de ShotGrid: {e}&quot;
        )
        debug_print(f&quot;Error detallado: {e}&quot;)


def main():
    thread = threading.Thread(target=threaded_function)
    thread.start()

    # Este join lo tuve que agregar en MAC. Volver a probar en mac y si es necesario agregarlo,
    # entonces le ponemos un IF porque me cuelga la interface en windows mientras se ejecuta:
    # thread.join() #


if __name__ == &quot;__main__&quot;:
    main()
import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_writePresets
importlib.reload(LGA_RnW_ColorSpace_Favs)&quot;&quot;&quot;
____________________________________________________________________________________

  LGA_NKS_Flow_Assignee_Panel v1.0 - 2025 - Lega Pugliese
  Panel para obtener los asignados de la tarea del clip seleccionado en Flow
____________________________________________________________________________________
&quot;&quot;&quot;

import hiero.ui
import hiero.core
import sys
import os
from PySide2.QtWidgets import (
    QWidget,
    QPushButton,
    QGridLayout,
    QMessageBox,
)
from PySide2.QtCore import Qt


def debug_print(*message):
    print(*message)


class AssigneePanel(QWidget):
    def __init__(self):
        super(AssigneePanel, self).__init__()
        self.setObjectName(&quot;com.lega.FPTAssigneePanel&quot;)
        self.setWindowTitle(&quot;Get Assignees&quot;)
        self.layout = QGridLayout()
        self.setLayout(self.layout)

        self.get_assignees_button = QPushButton(&quot;Get Assignees&quot;)
        self.get_assignees_button.clicked.connect(self.get_assignees_for_selected_clip)
        self.layout.addWidget(self.get_assignees_button, 0, 0)

    def parse_exr_name(self, exr_name):
        # Ajustar el manejo del formato del nombre del archivo EXR
        if &quot;%04d&quot; in exr_name:
            exr_name = exr_name.replace(&quot;.%&quot;, &quot;_%&quot;)  # Reemplazar patron para analisis
        parts = exr_name.split(&quot;_&quot;)
        if len(parts) &lt; 7 or not parts[-2].startswith(&quot;v&quot;):
            raise ValueError(
                f&quot;Nombre del archivo EXR no tiene el formato esperado: {exr_name}&quot;
            )
        base_name = &quot;_&quot;.join(parts[:-1])
        return base_name

    def get_assignees_for_selected_clip(self):
        seq = hiero.ui.activeSequence()
        if not seq:
            QMessageBox.warning(self, &quot;No Sequence&quot;, &quot;No hay una secuencia activa.&quot;)
            return
        te = hiero.ui.getTimelineEditor(seq)
        selected_items = te.selection()
        if not selected_items:
            QMessageBox.warning(
                self, &quot;No Selection&quot;, &quot;Selecciona un clip en el timeline.&quot;
            )
            return
        for item in selected_items:
            if not isinstance(item, hiero.core.EffectTrackItem):
                if item.source().mediaSource().isMediaPresent():
                    fileinfos = item.source().mediaSource().fileinfos()
                    if not fileinfos:
                        continue
                    file_path = fileinfos[0].filename()
                    exr_name = os.path.basename(file_path)
                    exr_name = exr_name.replace(&quot;.%&quot;, &quot;_%&quot;)
                    try:
                        base_name = self.parse_exr_name(exr_name)
                        self.call_assignee_script(base_name)
                    except Exception as e:
                        QMessageBox.warning(self, &quot;Formato Incorrecto&quot;, str(e))
                else:
                    QMessageBox.warning(
                        self, &quot;Media Missing&quot;, &quot;El clip no tiene media presente.&quot;
                    )

    def call_assignee_script(self, base_name):
        # Llama al script LGA_NKS_Flow_Assignee.py enviando el base_name como argumento
        script_path = os.path.join(
            os.path.dirname(__file__), &quot;LGA_NKS_Flow&quot;, &quot;LGA_NKS_Flow_Assignee.py&quot;
        )
        if not os.path.exists(script_path):
            QMessageBox.warning(
                self,
                &quot;Script no encontrado&quot;,
                f&quot;No se encontró el script en la ruta: {script_path}&quot;,
            )
            return
        # Ejecutar el script en un subproceso
        import subprocess

        env = os.environ.copy()
        try:
            subprocess.Popen([sys.executable, script_path, base_name], env=env)
        except Exception as e:
            QMessageBox.warning(self, &quot;Error al ejecutar&quot;, str(e))


# Crear la instancia del panel y agregarlo al windowManager de Hiero
assigneePanel = AssigneePanel()
wm = hiero.ui.windowManager()
wm.addWindow(assigneePanel)
&quot;&quot;&quot;
_____________________________________________________________________________________________________

  LGA_ToolPack_settings v0.4 | Lega
  Configuracion de la herramienta LGA_ToolPack
_____________________________________________________________________________________________________
&quot;&quot;&quot;

import sys
import os
import configparser
import typing  # Importar typing
from typing import Optional, Tuple

from PySide2.QtWidgets import (
    QApplication,
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QGroupBox,
    QLabel,
    QLineEdit,
    QFormLayout,
    QPushButton,
    QTextEdit,  # Importar QTextEdit
    QMessageBox,  # Importar QMessageBox
    QCheckBox,
    QFileDialog,
)
from PySide2.QtCore import Qt

# Importar funciones y constantes desde LGA_Write_Focus
# Asumiendo que ambos scripts estan en el mismo directorio o en el sys.path
try:
    from LGA_Write_Focus import (
        get_config_path as wf_get_config_path,  # Renombrar para claridad
        ensure_config_exists as wf_ensure_config_exists,
        get_node_name_from_config as wf_get_node_name_from_config,
        DEFAULT_NODE_NAME as WF_DEFAULT_NODE_NAME,  # Renombrar constante
        CONFIG_SECTION as WF_CONFIG_SECTION,  # Renombrar constante
        CONFIG_NODE_NAME_KEY as WF_CONFIG_NODE_NAME_KEY,  # Renombrar constante
    )
except ImportError as e_wf:
    print(f&quot;Error al importar LGA_Write_Focus.py: {e_wf}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def wf_ensure_config_exists():
        pass

    def wf_get_node_name_from_config() -&gt; str:
        return &quot;Write_Pub&quot;

    def wf_get_config_path() -&gt; typing.Optional[str]:
        return None

    WF_DEFAULT_NODE_NAME = &quot;Write_Pub&quot;
    WF_CONFIG_SECTION = &quot;Settings&quot;
    WF_CONFIG_NODE_NAME_KEY = &quot;node_name&quot;

# --- Importaciones de LGA_showInlFlow ---
try:
    from LGA_showInlFlow import (
        get_config_path as sif_get_config_path,
        ensure_config_exists as sif_ensure_config_exists,
        get_credentials_from_config as sif_get_credentials_from_config,
        save_credentials_to_config as sif_save_credentials_to_config,
    )
except ImportError as e_sif:
    print(f&quot;Error al importar LGA_showInlFlow.py: {e_sif}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def sif_ensure_config_exists():
        pass

    def sif_get_credentials_from_config() -&gt; (
        typing.Tuple[typing.Optional[str], typing.Optional[str], typing.Optional[str]]
    ):
        return None, None, None

    def sif_get_config_path() -&gt; typing.Optional[str]:
        return None

    # Funcion save dummy
    def sif_save_credentials_to_config(url, login, password) -&gt; bool:
        print(
            &quot;Error: LGA_showInlFlow.py no encontrado, no se pueden guardar credenciales.&quot;
        )
        return False


# --- Importaciones de LGA_RnW_ColorSpace_Favs --- Nuevo
try:
    from LGA_RnW_ColorSpace_Favs import (
        get_colorspace_ini_path,
        read_colorspaces_from_ini,
        save_colorspaces_to_ini,
        COLORSPACE_SECTION,  # Importar tambien la constante de seccion
    )
except ImportError as e_csf:
    print(
        f&quot;Error al importar LGA_RnW_ColorSpace_Favs.py: {e_csf}. Funcionalidad limitada.&quot;
    )

    # Definir funciones dummy
    def get_colorspace_ini_path(create_if_missing: bool = True) -&gt; typing.Optional[str]:
        return None

    def read_colorspaces_from_ini(ini_path: typing.Optional[str]) -&gt; typing.List[str]:
        return []

    def save_colorspaces_to_ini(
        ini_path: typing.Optional[str], colorspaces_list: typing.List[str]
    ) -&gt; bool:
        return False

    COLORSPACE_SECTION = &quot;ColorSpaces&quot;

# --- Importaciones de LGA_Render_Complete --- NUEVO
try:
    from LGA_Render_Complete import (
        get_config_path as rc_get_config_path,
        ensure_config_exists as rc_ensure_config_exists,
        get_mail_settings_from_config as rc_get_mail_settings_from_config,
        save_mail_settings_to_config as rc_save_mail_settings_to_config,
        CONFIG_FROM_KEY as RC_CONFIG_FROM_KEY,
        CONFIG_PASS_KEY as RC_CONFIG_PASS_KEY,
        CONFIG_TO_KEY as RC_CONFIG_TO_KEY,
    )
except ImportError as e_rc:
    print(f&quot;Error al importar LGA_Render_Complete.py: {e_rc}. Funcionalidad limitada.&quot;)

    def rc_ensure_config_exists() -&gt; None:
        pass

    def rc_get_mail_settings_from_config() -&gt; (
        Tuple[Optional[str], Optional[str], Optional[str]]
    ):
        return None, None, None

    def rc_save_mail_settings_to_config(from_email, from_password, to_email) -&gt; bool:
        return False

    def rc_get_config_path() -&gt; Optional[str]:
        return None

    RC_CONFIG_FROM_KEY = &quot;from_email&quot;
    RC_CONFIG_PASS_KEY = &quot;from_password&quot;
    RC_CONFIG_TO_KEY = &quot;to_email&quot;


class SettingsWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(&quot;LGA ToolPack Settings&quot;)
        self.setMinimumWidth(450)  # Un poco mas ancho para el QTextEdit
        self.initUI()

    def initUI(self):
        main_layout = QVBoxLayout(self)

        # --- Write Presets Section (Placeholder) ---
        write_presets_group = QGroupBox(&quot;Write Presets&quot;)
        write_presets_layout = QVBoxLayout()
        write_presets_layout.addWidget(
            QLabel(&quot;(Placeholder for Write Presets functionality)&quot;)
        )
        self.save_write_presets_button = QPushButton(&quot;Save&quot;)
        # self.save_write_presets_button.clicked.connect(self.save_write_presets) # Placeholder
        write_presets_layout.addWidget(self.save_write_presets_button, 0, Qt.AlignRight)
        write_presets_group.setLayout(write_presets_layout)
        main_layout.addWidget(write_presets_group)

        # --- Write Focus Section ---
        write_focus_group = QGroupBox(&quot;Write Focus&quot;)
        write_focus_layout_container = QVBoxLayout()
        write_focus_form_layout = QFormLayout()
        self.write_focus_input = QLineEdit()
        try:
            wf_ensure_config_exists()  # Usar funcion importada
            current_node_name = wf_get_node_name_from_config()  # Usar funcion importada
            self.write_focus_input.setText(current_node_name or WF_DEFAULT_NODE_NAME)
        except Exception as e:
            print(f&quot;Error al cargar config de Write Focus: {e}&quot;)
            self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)

        write_focus_form_layout.addRow(
            &quot;Name of the Write Node to Focus:&quot;, self.write_focus_input
        )
        write_focus_layout_container.addLayout(write_focus_form_layout)
        self.save_write_focus_button = QPushButton(&quot;Save&quot;)
        self.save_write_focus_button.clicked.connect(self.save_write_focus_settings)
        write_focus_layout_container.addWidget(
            self.save_write_focus_button, 0, Qt.AlignRight
        )
        write_focus_group.setLayout(write_focus_layout_container)
        main_layout.addWidget(write_focus_group)

        # --- Show in Flow Section ---
        show_flow_group = QGroupBox(&quot;Show in Flow&quot;)
        show_flow_layout_container = QVBoxLayout()
        show_flow_form_layout = QFormLayout()
        self.username_input = QLineEdit()
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.Password)
        self.site_input = QLineEdit()
        # Placeholders para los campos de ShotGrid
        self.site_input.setPlaceholderText(&quot;e.g., https://studio.shotgrid.autodesk.com&quot;)
        self.username_input.setPlaceholderText(&quot;e.g., artist@studio.com&quot;)
        self.password_input.setPlaceholderText(&quot;&quot;)
        show_flow_form_layout.addRow(
            &quot;ShotGrid URL:&quot;,
            self.site_input,
        )
        show_flow_form_layout.addRow(&quot;ShotGrid Login:&quot;, self.username_input)
        show_flow_form_layout.addRow(&quot;ShotGrid Password:&quot;, self.password_input)

        try:
            sif_ensure_config_exists()  # Usar funcion importada
            sif_url, sif_login, sif_password = (
                sif_get_credentials_from_config()
            )  # Usar funcion importada
            self.site_input.setText(sif_url or &quot;&quot;)
            self.username_input.setText(sif_login or &quot;&quot;)
            self.password_input.setText(sif_password or &quot;&quot;)
        except Exception as e:
            print(f&quot;Error al cargar credenciales de Show in Flow: {e}&quot;)

        show_flow_layout_container.addLayout(show_flow_form_layout)
        self.save_show_flow_button = QPushButton(&quot;Save&quot;)
        self.save_show_flow_button.clicked.connect(self.save_show_flow_settings)
        show_flow_layout_container.addWidget(
            self.save_show_flow_button, 0, Qt.AlignRight
        )
        show_flow_group.setLayout(show_flow_layout_container)
        main_layout.addWidget(show_flow_group)

        # --- Color Space Favs Section --- Modificado
        color_space_group = QGroupBox(&quot;Color Space Favorites&quot;)  # Titulo mas descriptivo
        color_space_layout = QVBoxLayout()
        color_space_layout.addWidget(
            QLabel(
                &quot;Enter favorite OCIO color spaces (one per line):&quot;
            )  # Label explicativo
        )
        # Crear el QTextEdit
        self.color_space_edit = QTextEdit()
        self.color_space_edit.setPlaceholderText(
            &quot;e.g.,\nOutput - sRGB\nUtility - Raw\nACES - ACEScg&quot;
        )
        self.color_space_edit.setMinimumHeight(80)  # Altura minima
        color_space_layout.addWidget(self.color_space_edit)

        # --- Cargar favoritos existentes --- Nuevo
        try:
            self.colorspace_ini_path = get_colorspace_ini_path(create_if_missing=True)
            if self.colorspace_ini_path:
                fav_list = read_colorspaces_from_ini(self.colorspace_ini_path)
                self.color_space_edit.setText(&quot;\n&quot;.join(fav_list))
            else:
                print(&quot;Advertencia: No se pudo obtener la ruta del INI de ColorSpaces.&quot;)
                # Podriamos deshabilitar el campo/boton si no hay ruta
                # self.color_space_edit.setEnabled(False)
        except Exception as e:
            print(f&quot;Error al cargar Color Space Favs: {e}&quot;)
            QMessageBox.warning(
                self, &quot;Error&quot;, f&quot;Could not load Color Space Favorites:\n{e}&quot;
            )
        # ---------------------------------

        self.save_color_space_button = QPushButton(&quot;Save&quot;)
        self.save_color_space_button.clicked.connect(
            self.save_color_space_settings
        )  # Conectar al nuevo metodo
        color_space_layout.addWidget(self.save_color_space_button, 0, Qt.AlignRight)
        color_space_group.setLayout(color_space_layout)
        main_layout.addWidget(color_space_group)

        # --- Render Complete Mail Settings Section --- NUEVO
        render_mail_group = QGroupBox(&quot;Render Complete Mail Settings&quot;)
        render_mail_layout_container = QVBoxLayout()
        render_mail_form_layout = QFormLayout()
        self.render_mail_from_input = QLineEdit()
        self.render_mail_pass_input = QLineEdit()
        self.render_mail_pass_input.setEchoMode(QLineEdit.Password)
        self.render_mail_to_input = QLineEdit()
        # Placeholders para los campos de mail
        self.render_mail_from_input.setPlaceholderText(&quot;e.g., tuMail@outlook.com&quot;)
        self.render_mail_pass_input.setPlaceholderText(&quot;&quot;)
        self.render_mail_to_input.setPlaceholderText(&quot;e.g., tuMail@gmail.com&quot;)
        # Cargar valores actuales
        try:
            rc_ensure_config_exists()
            from_email, from_password, to_email = rc_get_mail_settings_from_config()
            self.render_mail_from_input.setText(from_email or &quot;&quot;)
            self.render_mail_pass_input.setText(from_password or &quot;&quot;)
            self.render_mail_to_input.setText(to_email or &quot;&quot;)
        except Exception as e:
            print(f&quot;Error al cargar config de Render Complete Mail: {e}&quot;)
        render_mail_form_layout.addRow(&quot;From (Outlook):&quot;, self.render_mail_from_input)
        render_mail_form_layout.addRow(&quot;Password:&quot;, self.render_mail_pass_input)
        render_mail_form_layout.addRow(&quot;To (Recipient):&quot;, self.render_mail_to_input)
        render_mail_layout_container.addLayout(render_mail_form_layout)
        # --- NUEVOS SETTINGS ---
        self.cb_enable_mail = QCheckBox(&quot;Enable mail sending&quot;)
        self.cb_enable_render_time = QCheckBox(&quot;Enable render time calculation&quot;)
        self.cb_enable_sound = QCheckBox(&quot;Enable sound notification&quot;)
        render_mail_layout_container.addWidget(self.cb_enable_mail)
        render_mail_layout_container.addWidget(self.cb_enable_render_time)
        render_mail_layout_container.addWidget(self.cb_enable_sound)
        # Selector de archivo .wav
        wav_layout = QHBoxLayout()
        self.wav_path_input = QLineEdit()
        self.wav_path_input.setPlaceholderText(&quot;Select .wav file...&quot;)
        self.wav_browse_btn = QPushButton(&quot;Browse&quot;)
        self.wav_browse_btn.clicked.connect(self.browse_wav_file)
        wav_layout.addWidget(self.wav_path_input)
        wav_layout.addWidget(self.wav_browse_btn)
        render_mail_layout_container.addLayout(wav_layout)
        # ---

        self.save_render_mail_button = QPushButton(&quot;Save&quot;)
        self.save_render_mail_button.clicked.connect(self.save_render_mail_settings)
        render_mail_layout_container.addWidget(
            self.save_render_mail_button, 0, Qt.AlignRight
        )
        render_mail_group.setLayout(render_mail_layout_container)
        main_layout.addWidget(render_mail_group)
        # ---
        main_layout.addStretch()

    def save_write_focus_settings(self):
        &quot;&quot;&quot;Guarda el nombre del nodo de Write Focus en su archivo .ini.&quot;&quot;&quot;
        config_file_path = wf_get_config_path()
        if not config_file_path:
            print(&quot;Error: No se pudo obtener la ruta para guardar Write Focus.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Write Focus.&quot;,
            )
            return

        new_node_name = self.write_focus_input.text().strip()
        if not new_node_name:
            QMessageBox.warning(
                self, &quot;Input Error&quot;, &quot;Write Focus node name cannot be empty.&quot;
            )
            # Revertir al valor anterior o al por defecto
            try:
                current_node_name = wf_get_node_name_from_config()
                self.write_focus_input.setText(
                    current_node_name or WF_DEFAULT_NODE_NAME
                )
            except Exception:
                self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)
            return

        config = configparser.ConfigParser()
        try:
            # Leer existente para preservar otras secciones/claves
            if os.path.exists(config_file_path):
                config.read(config_file_path)

            if not config.has_section(WF_CONFIG_SECTION):
                config.add_section(WF_CONFIG_SECTION)

            config.set(WF_CONFIG_SECTION, WF_CONFIG_NODE_NAME_KEY, new_node_name)

            with open(config_file_path, &quot;w&quot;) as configfile:
                config.write(configfile)

            print(f&quot;Configuracion de Write Focus guardada: {new_node_name}&quot;)
            QMessageBox.information(self, &quot;Success&quot;, &quot;Write Focus settings saved.&quot;)

        except Exception as e:
            print(f&quot;Error al guardar la configuracion de Write Focus: {e}&quot;)
            QMessageBox.critical(
                self, &quot;Save Error&quot;, f&quot;Could not save Write Focus settings:\n{e}&quot;
            )

    def save_show_flow_settings(self):
        &quot;&quot;&quot;Guarda las credenciales de Show in Flow en su archivo .ini.&quot;&quot;&quot;
        config_file_path = sif_get_config_path()
        if not config_file_path:
            print(&quot;Error: No se pudo obtener la ruta para guardar Show in Flow.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Show in Flow.&quot;,
            )
            return

        new_url = self.site_input.text().strip()
        new_login = self.username_input.text().strip()
        new_password = self.password_input.text()  # No hacer strip a la password

        if not new_url or not new_login or not new_password:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;Show in Flow URL, Login, and Password cannot be empty.&quot;,
            )
            # No revertimos aqui, dejamos que el usuario corrija
            return

        # Llamar a la nueva funcion de guardado que maneja la codificacion
        try:
            success = sif_save_credentials_to_config(new_url, new_login, new_password)
            if success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(self, &quot;Success&quot;, &quot;Show in Flow settings saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Show in Flow settings. Check console for details.&quot;,
                )
        except Exception as e:
            print(f&quot;Error al llamar a save_credentials_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Show in Flow settings:\n{e}&quot;,
            )

    def save_color_space_settings(self):  # Nuevo metodo
        &quot;&quot;&quot;Guarda la lista de Color Space Favorites en su archivo .ini.&quot;&quot;&quot;
        # Re-obtener la ruta por si acaso, pero no forzar creacion/copia aqui
        ini_path = getattr(
            self,
            &quot;colorspace_ini_path&quot;,
            get_colorspace_ini_path(create_if_missing=False),
        )

        if not ini_path:
            print(&quot;Error: No se pudo obtener la ruta para guardar Color Space Favs.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Color Space Favorites.&quot;,
            )
            return

        # Obtener texto del QTextEdit
        text = self.color_space_edit.toPlainText()
        # Dividir en lineas, quitar espacios y filtrar vacias/solo espacios
        favorites_list = [line.strip() for line in text.split(&quot;\n&quot;) if line.strip()]

        # Usar la funcion importada para guardar
        try:
            success = save_colorspaces_to_ini(ini_path, favorites_list)
            if success:
                print(&quot;Configuracion de Color Space Favorites guardada.&quot;)
                QMessageBox.information(self, &quot;Success&quot;, &quot;Color Space Favorites saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso en la funcion save_colorspaces_to_ini
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Color Space Favorites. Check console for details.&quot;,
                )

        except Exception as e:
            # Captura por si save_colorspaces_to_ini lanza una excepcion inesperada
            print(f&quot;Error inesperado al llamar a save_colorspaces_to_ini: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Color Space Favorites:\n{e}&quot;,
            )

    def save_render_mail_settings(self):
        &quot;&quot;&quot;Guarda los datos de mail de Render Complete en su archivo .ini.&quot;&quot;&quot;
        config_file_path = rc_get_config_path()
        if not config_file_path:
            print(
                &quot;Error: No se pudo obtener la ruta para guardar Render Complete Mail.&quot;
            )
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Render Complete Mail.&quot;,
            )
            return
        from_email = self.render_mail_from_input.text().strip()
        from_password = self.render_mail_pass_input.text()
        to_email = self.render_mail_to_input.text().strip()
        if not from_email or not from_password or not to_email:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;All mail fields must be filled (From, Password, To).&quot;,
            )
            # No revertimos, dejamos que el usuario corrija
            return
        try:
            # La funcion rc_save_mail_settings_to_config ahora maneja la codificacion interna
            success = rc_save_mail_settings_to_config(
                from_email, from_password, to_email
            )
            if success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(
                    self, &quot;Success&quot;, &quot;Render Complete Mail settings saved.&quot;
                )
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Render Complete Mail settings. Check console for details.&quot;,
                )
        except Exception as e:
            print(f&quot;Error al llamar a save_mail_settings_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Render Complete Mail settings:\n{e}&quot;,
            )

    def browse_wav_file(self):
        &quot;&quot;&quot;Abre un diálogo para seleccionar un archivo .wav y lo pone en el QLineEdit.&quot;&quot;&quot;
        file_path, _ = QFileDialog.getOpenFileName(
            self, &quot;Select WAV file&quot;, &quot;&quot;, &quot;WAV Files (*.wav)&quot;
        )
        if file_path:
            self.wav_path_input.setText(file_path)


# --- Main Execution ---
if __name__ == &quot;__main__&quot;:
    # Necesario para ejecucion standalone fuera de Nuke
    app = QApplication.instance() or QApplication(sys.argv)

    settings_window = SettingsWindow()
    settings_window.show()

    # Mantener el bucle para ejecucion standalone
    if not QApplication.instance():  # Solo si no estamos en Nuke
        sys.exit(app.exec_())
    # Si estamos en Nuke, no llamamos a sys.exit()
&quot;&quot;&quot;
_____________________________________________________________________________________________________

  LGA_ToolPack_settings v0.4 | Lega
  Configuracion de la herramienta LGA_ToolPack
_____________________________________________________________________________________________________
&quot;&quot;&quot;

import sys
import os
import configparser
import typing  # Importar typing
from typing import Optional, Tuple

from PySide2.QtWidgets import (
    QApplication,
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QGroupBox,
    QLabel,
    QLineEdit,
    QFormLayout,
    QPushButton,
    QTextEdit,  # Importar QTextEdit
    QMessageBox,  # Importar QMessageBox
    QCheckBox,
    QFileDialog,
)
from PySide2.QtCore import Qt

# Importar funciones y constantes desde LGA_Write_Focus
# Asumiendo que ambos scripts estan en el mismo directorio o en el sys.path
try:
    from LGA_Write_Focus import (
        get_config_path as wf_get_config_path,  # Renombrar para claridad
        ensure_config_exists as wf_ensure_config_exists,
        get_node_name_from_config as wf_get_node_name_from_config,
        DEFAULT_NODE_NAME as WF_DEFAULT_NODE_NAME,  # Renombrar constante
        CONFIG_SECTION as WF_CONFIG_SECTION,  # Renombrar constante
        CONFIG_NODE_NAME_KEY as WF_CONFIG_NODE_NAME_KEY,  # Renombrar constante
    )
except ImportError as e_wf:
    print(f&quot;Error al importar LGA_Write_Focus.py: {e_wf}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def wf_ensure_config_exists():
        pass

    def wf_get_node_name_from_config() -&gt; str:
        return &quot;Write_Pub&quot;

    def wf_get_config_path() -&gt; typing.Optional[str]:
        return None

    WF_DEFAULT_NODE_NAME = &quot;Write_Pub&quot;
    WF_CONFIG_SECTION = &quot;Settings&quot;
    WF_CONFIG_NODE_NAME_KEY = &quot;node_name&quot;

# --- Importaciones de LGA_showInlFlow ---
try:
    from LGA_showInlFlow import (
        get_config_path as sif_get_config_path,
        ensure_config_exists as sif_ensure_config_exists,
        get_credentials_from_config as sif_get_credentials_from_config,
        save_credentials_to_config as sif_save_credentials_to_config,
    )
except ImportError as e_sif:
    print(f&quot;Error al importar LGA_showInlFlow.py: {e_sif}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def sif_ensure_config_exists():
        pass

    def sif_get_credentials_from_config() -&gt; (
        typing.Tuple[typing.Optional[str], typing.Optional[str], typing.Optional[str]]
    ):
        return None, None, None

    def sif_get_config_path() -&gt; typing.Optional[str]:
        return None

    # Funcion save dummy
    def sif_save_credentials_to_config(url, login, password) -&gt; bool:
        print(
            &quot;Error: LGA_showInlFlow.py no encontrado, no se pueden guardar credenciales.&quot;
        )
        return False


# --- Importaciones de LGA_RnW_ColorSpace_Favs --- Nuevo
try:
    from LGA_RnW_ColorSpace_Favs import (
        get_colorspace_ini_path,
        read_colorspaces_from_ini,
        save_colorspaces_to_ini,
        COLORSPACE_SECTION,  # Importar tambien la constante de seccion
    )
except ImportError as e_csf:
    print(
        f&quot;Error al importar LGA_RnW_ColorSpace_Favs.py: {e_csf}. Funcionalidad limitada.&quot;
    )

    # Definir funciones dummy
    def get_colorspace_ini_path(create_if_missing: bool = True) -&gt; typing.Optional[str]:
        return None

    def read_colorspaces_from_ini(ini_path: typing.Optional[str]) -&gt; typing.List[str]:
        return []

    def save_colorspaces_to_ini(
        ini_path: typing.Optional[str], colorspaces_list: typing.List[str]
    ) -&gt; bool:
        return False

    COLORSPACE_SECTION = &quot;ColorSpaces&quot;

# --- Importaciones de LGA_Render_Complete --- NUEVO
try:
    from LGA_Render_Complete import (
        get_config_path as rc_get_config_path,
        ensure_config_exists as rc_ensure_config_exists,
        get_mail_settings_from_config as rc_get_mail_settings_from_config,
        save_mail_settings_to_config as rc_save_mail_settings_to_config,
        CONFIG_FROM_KEY as RC_CONFIG_FROM_KEY,
        CONFIG_PASS_KEY as RC_CONFIG_PASS_KEY,
        CONFIG_TO_KEY as RC_CONFIG_TO_KEY,
    )
except ImportError as e_rc:
    print(f&quot;Error al importar LGA_Render_Complete.py: {e_rc}. Funcionalidad limitada.&quot;)

    def rc_ensure_config_exists() -&gt; None:
        pass

    def rc_get_mail_settings_from_config() -&gt; (
        Tuple[Optional[str], Optional[str], Optional[str]]
    ):
        return None, None, None

    def rc_save_mail_settings_to_config(from_email, from_password, to_email) -&gt; bool:
        return False

    def rc_get_config_path() -&gt; Optional[str]:
        return None

    RC_CONFIG_FROM_KEY = &quot;from_email&quot;
    RC_CONFIG_PASS_KEY = &quot;from_password&quot;
    RC_CONFIG_TO_KEY = &quot;to_email&quot;


class SettingsWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(&quot;LGA ToolPack Settings&quot;)
        self.setMinimumWidth(450)  # Un poco mas ancho para el QTextEdit
        self.initUI()

    def initUI(self):
        main_layout = QVBoxLayout(self)

        # --- Write Presets Section (Placeholder) ---
        write_presets_group = QGroupBox(&quot;Write Presets&quot;)
        write_presets_layout = QVBoxLayout()
        write_presets_layout.addWidget(
            QLabel(&quot;(Placeholder for Write Presets functionality)&quot;)
        )
        self.save_write_presets_button = QPushButton(&quot;Save&quot;)
        # self.save_write_presets_button.clicked.connect(self.save_write_presets) # Placeholder
        write_presets_layout.addWidget(self.save_write_presets_button, 0, Qt.AlignRight)
        write_presets_group.setLayout(write_presets_layout)
        main_layout.addWidget(write_presets_group)

        # --- Write Focus Section ---
        write_focus_group = QGroupBox(&quot;Write Focus&quot;)
        write_focus_layout_container = QVBoxLayout()
        write_focus_form_layout = QFormLayout()
        self.write_focus_input = QLineEdit()
        try:
            wf_ensure_config_exists()  # Usar funcion importada
            current_node_name = wf_get_node_name_from_config()  # Usar funcion importada
            self.write_focus_input.setText(current_node_name or WF_DEFAULT_NODE_NAME)
        except Exception as e:
            print(f&quot;Error al cargar config de Write Focus: {e}&quot;)
            self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)

        write_focus_form_layout.addRow(
            &quot;Name of the Write Node to Focus:&quot;, self.write_focus_input
        )
        write_focus_layout_container.addLayout(write_focus_form_layout)
        self.save_write_focus_button = QPushButton(&quot;Save&quot;)
        self.save_write_focus_button.clicked.connect(self.save_write_focus_settings)
        write_focus_layout_container.addWidget(
            self.save_write_focus_button, 0, Qt.AlignRight
        )
        write_focus_group.setLayout(write_focus_layout_container)
        main_layout.addWidget(write_focus_group)

        # --- Show in Flow Section ---
        show_flow_group = QGroupBox(&quot;Show in Flow&quot;)
        show_flow_layout_container = QVBoxLayout()
        show_flow_form_layout = QFormLayout()
        self.username_input = QLineEdit()
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.Password)
        self.site_input = QLineEdit()
        # Placeholders para los campos de ShotGrid
        self.site_input.setPlaceholderText(&quot;e.g., https://studio.shotgrid.autodesk.com&quot;)
        self.username_input.setPlaceholderText(&quot;e.g., artist@studio.com&quot;)
        self.password_input.setPlaceholderText(&quot;&quot;)
        show_flow_form_layout.addRow(
            &quot;ShotGrid URL:&quot;,
            self.site_input,
        )
        show_flow_form_layout.addRow(&quot;ShotGrid Login:&quot;, self.username_input)
        show_flow_form_layout.addRow(&quot;ShotGrid Password:&quot;, self.password_input)

        try:
            sif_ensure_config_exists()  # Usar funcion importada
            sif_url, sif_login, sif_password = (
                sif_get_credentials_from_config()
            )  # Usar funcion importada
            self.site_input.setText(sif_url or &quot;&quot;)
            self.username_input.setText(sif_login or &quot;&quot;)
            self.password_input.setText(sif_password or &quot;&quot;)
        except Exception as e:
            print(f&quot;Error al cargar credenciales de Show in Flow: {e}&quot;)

        show_flow_layout_container.addLayout(show_flow_form_layout)
        self.save_show_flow_button = QPushButton(&quot;Save&quot;)
        self.save_show_flow_button.clicked.connect(self.save_show_flow_settings)
        show_flow_layout_container.addWidget(
            self.save_show_flow_button, 0, Qt.AlignRight
        )
        show_flow_group.setLayout(show_flow_layout_container)
        main_layout.addWidget(show_flow_group)

        # --- Color Space Favs Section --- Modificado
        color_space_group = QGroupBox(&quot;Color Space Favorites&quot;)  # Titulo mas descriptivo
        color_space_layout = QVBoxLayout()
        color_space_layout.addWidget(
            QLabel(
                &quot;Enter favorite OCIO color spaces (one per line):&quot;
            )  # Label explicativo
        )
        # Crear el QTextEdit
        self.color_space_edit = QTextEdit()
        self.color_space_edit.setPlaceholderText(
            &quot;e.g.,\nOutput - sRGB\nUtility - Raw\nACES - ACEScg&quot;
        )
        self.color_space_edit.setMinimumHeight(80)  # Altura minima
        color_space_layout.addWidget(self.color_space_edit)

        # --- Cargar favoritos existentes --- Nuevo
        try:
            self.colorspace_ini_path = get_colorspace_ini_path(create_if_missing=True)
            if self.colorspace_ini_path:
                fav_list = read_colorspaces_from_ini(self.colorspace_ini_path)
                self.color_space_edit.setText(&quot;\n&quot;.join(fav_list))
            else:
                print(&quot;Advertencia: No se pudo obtener la ruta del INI de ColorSpaces.&quot;)
                # Podriamos deshabilitar el campo/boton si no hay ruta
                # self.color_space_edit.setEnabled(False)
        except Exception as e:
            print(f&quot;Error al cargar Color Space Favs: {e}&quot;)
            QMessageBox.warning(
                self, &quot;Error&quot;, f&quot;Could not load Color Space Favorites:\n{e}&quot;
            )
        # ---------------------------------

        self.save_color_space_button = QPushButton(&quot;Save&quot;)
        self.save_color_space_button.clicked.connect(
            self.save_color_space_settings
        )  # Conectar al nuevo metodo
        color_space_layout.addWidget(self.save_color_space_button, 0, Qt.AlignRight)
        color_space_group.setLayout(color_space_layout)
        main_layout.addWidget(color_space_group)

        # --- Render Complete Mail Settings Section --- NUEVO
        render_mail_group = QGroupBox(&quot;Render Complete Mail Settings&quot;)
        render_mail_layout_container = QVBoxLayout()
        render_mail_form_layout = QFormLayout()
        self.render_mail_from_input = QLineEdit()
        self.render_mail_pass_input = QLineEdit()
        self.render_mail_pass_input.setEchoMode(QLineEdit.Password)
        self.render_mail_to_input = QLineEdit()
        # Placeholders para los campos de mail
        self.render_mail_from_input.setPlaceholderText(&quot;e.g., tuMail@outlook.com&quot;)
        self.render_mail_pass_input.setPlaceholderText(&quot;&quot;)
        self.render_mail_to_input.setPlaceholderText(&quot;e.g., tuMail@gmail.com&quot;)
        # Cargar valores actuales
        try:
            rc_ensure_config_exists()
            from_email, from_password, to_email = rc_get_mail_settings_from_config()
            self.render_mail_from_input.setText(from_email or &quot;&quot;)
            self.render_mail_pass_input.setText(from_password or &quot;&quot;)
            self.render_mail_to_input.setText(to_email or &quot;&quot;)
        except Exception as e:
            print(f&quot;Error al cargar config de Render Complete Mail: {e}&quot;)
        render_mail_form_layout.addRow(&quot;From (Outlook):&quot;, self.render_mail_from_input)
        render_mail_form_layout.addRow(&quot;Password:&quot;, self.render_mail_pass_input)
        render_mail_form_layout.addRow(&quot;To (Recipient):&quot;, self.render_mail_to_input)
        render_mail_layout_container.addLayout(render_mail_form_layout)
        # --- NUEVOS SETTINGS ---
        self.cb_enable_mail = QCheckBox(&quot;Enable mail sending&quot;)
        self.cb_enable_render_time = QCheckBox(&quot;Enable render time calculation&quot;)
        self.cb_enable_sound = QCheckBox(&quot;Enable sound notification&quot;)
        render_mail_layout_container.addWidget(self.cb_enable_mail)
        render_mail_layout_container.addWidget(self.cb_enable_render_time)
        render_mail_layout_container.addWidget(self.cb_enable_sound)
        # Selector de archivo .wav
        wav_layout = QHBoxLayout()
        self.wav_path_input = QLineEdit()
        self.wav_path_input.setPlaceholderText(&quot;Select .wav file...&quot;)
        self.wav_browse_btn = QPushButton(&quot;Browse&quot;)
        self.wav_browse_btn.clicked.connect(self.browse_wav_file)
        wav_layout.addWidget(self.wav_path_input)
        wav_layout.addWidget(self.wav_browse_btn)
        render_mail_layout_container.addLayout(wav_layout)
        # ---

        self.save_render_mail_button = QPushButton(&quot;Save&quot;)
        self.save_render_mail_button.clicked.connect(self.save_render_mail_settings)
        render_mail_layout_container.addWidget(
            self.save_render_mail_button, 0, Qt.AlignRight
        )
        render_mail_group.setLayout(render_mail_layout_container)
        main_layout.addWidget(render_mail_group)
        # ---
        main_layout.addStretch()

    def save_write_focus_settings(self):
        &quot;&quot;&quot;Guarda el nombre del nodo de Write Focus en su archivo .ini.&quot;&quot;&quot;
        config_file_path = wf_get_config_path()
        if not config_file_path:
            print(&quot;Error: No se pudo obtener la ruta para guardar Write Focus.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Write Focus.&quot;,
            )
            return

        new_node_name = self.write_focus_input.text().strip()
        if not new_node_name:
            QMessageBox.warning(
                self, &quot;Input Error&quot;, &quot;Write Focus node name cannot be empty.&quot;
            )
            # Revertir al valor anterior o al por defecto
            try:
                current_node_name = wf_get_node_name_from_config()
                self.write_focus_input.setText(
                    current_node_name or WF_DEFAULT_NODE_NAME
                )
            except Exception:
                self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)
            return

        config = configparser.ConfigParser()
        try:
            # Leer existente para preservar otras secciones/claves
            if os.path.exists(config_file_path):
                config.read(config_file_path)

            if not config.has_section(WF_CONFIG_SECTION):
                config.add_section(WF_CONFIG_SECTION)

            config.set(WF_CONFIG_SECTION, WF_CONFIG_NODE_NAME_KEY, new_node_name)

            with open(config_file_path, &quot;w&quot;) as configfile:
                config.write(configfile)

            print(f&quot;Configuracion de Write Focus guardada: {new_node_name}&quot;)
            QMessageBox.information(self, &quot;Success&quot;, &quot;Write Focus settings saved.&quot;)

        except Exception as e:
            print(f&quot;Error al guardar la configuracion de Write Focus: {e}&quot;)
            QMessageBox.critical(
                self, &quot;Save Error&quot;, f&quot;Could not save Write Focus settings:\n{e}&quot;
            )

    def save_show_flow_settings(self):
        &quot;&quot;&quot;Guarda las credenciales de Show in Flow en su archivo .ini.&quot;&quot;&quot;
        config_file_path = sif_get_config_path()
        if not config_file_path:
            print(&quot;Error: No se pudo obtener la ruta para guardar Show in Flow.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Show in Flow.&quot;,
            )
            return

        new_url = self.site_input.text().strip()
        new_login = self.username_input.text().strip()
        new_password = self.password_input.text()  # No hacer strip a la password

        if not new_url or not new_login or not new_password:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;Show in Flow URL, Login, and Password cannot be empty.&quot;,
            )
            # No revertimos aqui, dejamos que el usuario corrija
            return

        # Llamar a la nueva funcion de guardado que maneja la codificacion
        try:
            success = sif_save_credentials_to_config(new_url, new_login, new_password)
            if success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(self, &quot;Success&quot;, &quot;Show in Flow settings saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Show in Flow settings. Check console for details.&quot;,
                )
        except Exception as e:
            print(f&quot;Error al llamar a save_credentials_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Show in Flow settings:\n{e}&quot;,
            )

    def save_color_space_settings(self):  # Nuevo metodo
        &quot;&quot;&quot;Guarda la lista de Color Space Favorites en su archivo .ini.&quot;&quot;&quot;
        # Re-obtener la ruta por si acaso, pero no forzar creacion/copia aqui
        ini_path = getattr(
            self,
            &quot;colorspace_ini_path&quot;,
            get_colorspace_ini_path(create_if_missing=False),
        )

        if not ini_path:
            print(&quot;Error: No se pudo obtener la ruta para guardar Color Space Favs.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Color Space Favorites.&quot;,
            )
            return

        # Obtener texto del QTextEdit
        text = self.color_space_edit.toPlainText()
        # Dividir en lineas, quitar espacios y filtrar vacias/solo espacios
        favorites_list = [line.strip() for line in text.split(&quot;\n&quot;) if line.strip()]

        # Usar la funcion importada para guardar
        try:
            success = save_colorspaces_to_ini(ini_path, favorites_list)
            if success:
                print(&quot;Configuracion de Color Space Favorites guardada.&quot;)
                QMessageBox.information(self, &quot;Success&quot;, &quot;Color Space Favorites saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso en la funcion save_colorspaces_to_ini
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Color Space Favorites. Check console for details.&quot;,
                )

        except Exception as e:
            # Captura por si save_colorspaces_to_ini lanza una excepcion inesperada
            print(f&quot;Error inesperado al llamar a save_colorspaces_to_ini: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Color Space Favorites:\n{e}&quot;,
            )

    def save_render_mail_settings(self):
        &quot;&quot;&quot;Guarda los datos de mail de Render Complete en su archivo .ini.&quot;&quot;&quot;
        config_file_path = rc_get_config_path()
        if not config_file_path:
            print(
                &quot;Error: No se pudo obtener la ruta para guardar Render Complete Mail.&quot;
            )
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Render Complete Mail.&quot;,
            )
            return
        from_email = self.render_mail_from_input.text().strip()
        from_password = self.render_mail_pass_input.text()
        to_email = self.render_mail_to_input.text().strip()
        if not from_email or not from_password or not to_email:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;All mail fields must be filled (From, Password, To).&quot;,
            )
            # No revertimos, dejamos que el usuario corrija
            return
        try:
            # La funcion rc_save_mail_settings_to_config ahora maneja la codificacion interna
            success = rc_save_mail_settings_to_config(
                from_email, from_password, to_email
            )
            if success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(
                    self, &quot;Success&quot;, &quot;Render Complete Mail settings saved.&quot;
                )
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Render Complete Mail settings. Check console for details.&quot;,
                )
        except Exception as e:
            print(f&quot;Error al llamar a save_mail_settings_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Render Complete Mail settings:\n{e}&quot;,
            )

    def browse_wav_file(self):
        &quot;&quot;&quot;Abre un diálogo para seleccionar un archivo .wav y lo pone en el QLineEdit.&quot;&quot;&quot;
        file_path, _ = QFileDialog.getOpenFileName(
            self, &quot;Select WAV file&quot;, &quot;&quot;, &quot;WAV Files (*.wav)&quot;
        )
        if file_path:
            self.wav_path_input.setText(file_path)


# --- Main Execution ---
if __name__ == &quot;__main__&quot;:
    # Necesario para ejecucion standalone fuera de Nuke
    app = QApplication.instance() or QApplication(sys.argv)

    settings_window = SettingsWindow()
    settings_window.show()

    # Mantener el bucle para ejecucion standalone
    if not QApplication.instance():  # Solo si no estamos en Nuke
        sys.exit(app.exec_())
    # Si estamos en Nuke, no llamamos a sys.exit()
&quot;&quot;&quot;
_____________________________________________________________________________________________________

  LGA_ToolPack_settings v0.4 | Lega
  Configuracion de la herramienta LGA_ToolPack
_____________________________________________________________________________________________________
&quot;&quot;&quot;

import sys
import os
import configparser
import typing  # Importar typing
from typing import Optional, Tuple

from PySide2.QtWidgets import (
    QApplication,
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QGroupBox,
    QLabel,
    QLineEdit,
    QFormLayout,
    QPushButton,
    QTextEdit,  # Importar QTextEdit
    QMessageBox,  # Importar QMessageBox
    QCheckBox,
    QFileDialog,
)
from PySide2.QtCore import Qt

# Importar funciones y constantes desde LGA_Write_Focus
# Asumiendo que ambos scripts estan en el mismo directorio o en el sys.path
try:
    from LGA_Write_Focus import (
        get_config_path as wf_get_config_path,  # Renombrar para claridad
        ensure_config_exists as wf_ensure_config_exists,
        get_node_name_from_config as wf_get_node_name_from_config,
        DEFAULT_NODE_NAME as WF_DEFAULT_NODE_NAME,  # Renombrar constante
        CONFIG_SECTION as WF_CONFIG_SECTION,  # Renombrar constante
        CONFIG_NODE_NAME_KEY as WF_CONFIG_NODE_NAME_KEY,  # Renombrar constante
    )
except ImportError as e_wf:
    print(f&quot;Error al importar LGA_Write_Focus.py: {e_wf}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def wf_ensure_config_exists():
        pass

    def wf_get_node_name_from_config() -&gt; str:
        return &quot;Write_Pub&quot;

    def wf_get_config_path() -&gt; typing.Optional[str]:
        return None

    WF_DEFAULT_NODE_NAME = &quot;Write_Pub&quot;
    WF_CONFIG_SECTION = &quot;Settings&quot;
    WF_CONFIG_NODE_NAME_KEY = &quot;node_name&quot;

# --- Importaciones de LGA_showInlFlow ---
try:
    from LGA_showInlFlow import (
        get_config_path as sif_get_config_path,
        ensure_config_exists as sif_ensure_config_exists,
        get_credentials_from_config as sif_get_credentials_from_config,
        save_credentials_to_config as sif_save_credentials_to_config,
    )
except ImportError as e_sif:
    print(f&quot;Error al importar LGA_showInlFlow.py: {e_sif}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def sif_ensure_config_exists():
        pass

    def sif_get_credentials_from_config() -&gt; (
        typing.Tuple[typing.Optional[str], typing.Optional[str], typing.Optional[str]]
    ):
        return None, None, None

    def sif_get_config_path() -&gt; typing.Optional[str]:
        return None

    # Funcion save dummy
    def sif_save_credentials_to_config(url, login, password) -&gt; bool:
        print(
            &quot;Error: LGA_showInlFlow.py no encontrado, no se pueden guardar credenciales.&quot;
        )
        return False


# --- Importaciones de LGA_RnW_ColorSpace_Favs --- Nuevo
try:
    from LGA_RnW_ColorSpace_Favs import (
        get_colorspace_ini_path,
        read_colorspaces_from_ini,
        save_colorspaces_to_ini,
        COLORSPACE_SECTION,  # Importar tambien la constante de seccion
    )
except ImportError as e_csf:
    print(
        f&quot;Error al importar LGA_RnW_ColorSpace_Favs.py: {e_csf}. Funcionalidad limitada.&quot;
    )

    # Definir funciones dummy
    def get_colorspace_ini_path(create_if_missing: bool = True) -&gt; typing.Optional[str]:
        return None

    def read_colorspaces_from_ini(ini_path: typing.Optional[str]) -&gt; typing.List[str]:
        return []

    def save_colorspaces_to_ini(
        ini_path: typing.Optional[str], colorspaces_list: typing.List[str]
    ) -&gt; bool:
        return False

    COLORSPACE_SECTION = &quot;ColorSpaces&quot;

# --- Importaciones de LGA_Render_Complete --- NUEVO
try:
    from LGA_Render_Complete import (
        get_config_path as rc_get_config_path,
        ensure_config_exists as rc_ensure_config_exists,
        get_mail_settings_from_config as rc_get_mail_settings_from_config,
        save_mail_settings_to_config as rc_save_mail_settings_to_config,
        CONFIG_FROM_KEY as RC_CONFIG_FROM_KEY,
        CONFIG_PASS_KEY as RC_CONFIG_PASS_KEY,
        CONFIG_TO_KEY as RC_CONFIG_TO_KEY,
    )
except ImportError as e_rc:
    print(f&quot;Error al importar LGA_Render_Complete.py: {e_rc}. Funcionalidad limitada.&quot;)

    def rc_ensure_config_exists() -&gt; None:
        pass

    def rc_get_mail_settings_from_config() -&gt; (
        Tuple[Optional[str], Optional[str], Optional[str]]
    ):
        return None, None, None

    def rc_save_mail_settings_to_config(from_email, from_password, to_email) -&gt; bool:
        return False

    def rc_get_config_path() -&gt; Optional[str]:
        return None

    RC_CONFIG_FROM_KEY = &quot;from_email&quot;
    RC_CONFIG_PASS_KEY = &quot;from_password&quot;
    RC_CONFIG_TO_KEY = &quot;to_email&quot;


class SettingsWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(&quot;LGA ToolPack Settings&quot;)
        self.setMinimumWidth(450)  # Un poco mas ancho para el QTextEdit
        self.initUI()

    def initUI(self):
        main_layout = QVBoxLayout(self)

        # --- Write Presets Section (Placeholder) ---
        write_presets_group = QGroupBox(&quot;Write Presets&quot;)
        write_presets_layout = QVBoxLayout()
        write_presets_layout.addWidget(
            QLabel(&quot;(Placeholder for Write Presets functionality)&quot;)
        )
        self.save_write_presets_button = QPushButton(&quot;Save&quot;)
        # self.save_write_presets_button.clicked.connect(self.save_write_presets) # Placeholder
        write_presets_layout.addWidget(self.save_write_presets_button, 0, Qt.AlignRight)
        write_presets_group.setLayout(write_presets_layout)
        main_layout.addWidget(write_presets_group)

        # --- Write Focus Section ---
        write_focus_group = QGroupBox(&quot;Write Focus&quot;)
        write_focus_layout_container = QVBoxLayout()
        write_focus_form_layout = QFormLayout()
        self.write_focus_input = QLineEdit()
        try:
            wf_ensure_config_exists()  # Usar funcion importada
            current_node_name = wf_get_node_name_from_config()  # Usar funcion importada
            self.write_focus_input.setText(current_node_name or WF_DEFAULT_NODE_NAME)
        except Exception as e:
            print(f&quot;Error al cargar config de Write Focus: {e}&quot;)
            self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)

        write_focus_form_layout.addRow(
            &quot;Name of the Write Node to Focus:&quot;, self.write_focus_input
        )
        write_focus_layout_container.addLayout(write_focus_form_layout)
        self.save_write_focus_button = QPushButton(&quot;Save&quot;)
        self.save_write_focus_button.clicked.connect(self.save_write_focus_settings)
        write_focus_layout_container.addWidget(
            self.save_write_focus_button, 0, Qt.AlignRight
        )
        write_focus_group.setLayout(write_focus_layout_container)
        main_layout.addWidget(write_focus_group)

        # --- Show in Flow Section ---
        show_flow_group = QGroupBox(&quot;Show in Flow&quot;)
        show_flow_layout_container = QVBoxLayout()
        show_flow_form_layout = QFormLayout()
        self.username_input = QLineEdit()
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.Password)
        self.site_input = QLineEdit()
        # Placeholders para los campos de ShotGrid
        self.site_input.setPlaceholderText(&quot;e.g., https://studio.shotgrid.autodesk.com&quot;)
        self.username_input.setPlaceholderText(&quot;e.g., artist@studio.com&quot;)
        self.password_input.setPlaceholderText(&quot;&quot;)
        show_flow_form_layout.addRow(
            &quot;ShotGrid URL:&quot;,
            self.site_input,
        )
        show_flow_form_layout.addRow(&quot;ShotGrid Login:&quot;, self.username_input)
        show_flow_form_layout.addRow(&quot;ShotGrid Password:&quot;, self.password_input)

        try:
            sif_ensure_config_exists()  # Usar funcion importada
            sif_url, sif_login, sif_password = (
                sif_get_credentials_from_config()
            )  # Usar funcion importada
            self.site_input.setText(sif_url or &quot;&quot;)
            self.username_input.setText(sif_login or &quot;&quot;)
            self.password_input.setText(sif_password or &quot;&quot;)
        except Exception as e:
            print(f&quot;Error al cargar credenciales de Show in Flow: {e}&quot;)

        show_flow_layout_container.addLayout(show_flow_form_layout)
        self.save_show_flow_button = QPushButton(&quot;Save&quot;)
        self.save_show_flow_button.clicked.connect(self.save_show_flow_settings)
        show_flow_layout_container.addWidget(
            self.save_show_flow_button, 0, Qt.AlignRight
        )
        show_flow_group.setLayout(show_flow_layout_container)
        main_layout.addWidget(show_flow_group)

        # --- Color Space Favs Section --- Modificado
        color_space_group = QGroupBox(&quot;Color Space Favorites&quot;)  # Titulo mas descriptivo
        color_space_layout = QVBoxLayout()
        color_space_layout.addWidget(
            QLabel(
                &quot;Enter favorite OCIO color spaces (one per line):&quot;
            )  # Label explicativo
        )
        # Crear el QTextEdit
        self.color_space_edit = QTextEdit()
        self.color_space_edit.setPlaceholderText(
            &quot;e.g.,\nOutput - sRGB\nUtility - Raw\nACES - ACEScg&quot;
        )
        self.color_space_edit.setMinimumHeight(80)  # Altura minima
        color_space_layout.addWidget(self.color_space_edit)

        # --- Cargar favoritos existentes --- Nuevo
        try:
            self.colorspace_ini_path = get_colorspace_ini_path(create_if_missing=True)
            if self.colorspace_ini_path:
                fav_list = read_colorspaces_from_ini(self.colorspace_ini_path)
                self.color_space_edit.setText(&quot;\n&quot;.join(fav_list))
            else:
                print(&quot;Advertencia: No se pudo obtener la ruta del INI de ColorSpaces.&quot;)
                # Podriamos deshabilitar el campo/boton si no hay ruta
                # self.color_space_edit.setEnabled(False)
        except Exception as e:
            print(f&quot;Error al cargar Color Space Favs: {e}&quot;)
            QMessageBox.warning(
                self, &quot;Error&quot;, f&quot;Could not load Color Space Favorites:\n{e}&quot;
            )
        # ---------------------------------

        self.save_color_space_button = QPushButton(&quot;Save&quot;)
        self.save_color_space_button.clicked.connect(
            self.save_color_space_settings
        )  # Conectar al nuevo metodo
        color_space_layout.addWidget(self.save_color_space_button, 0, Qt.AlignRight)
        color_space_group.setLayout(color_space_layout)
        main_layout.addWidget(color_space_group)

        # --- Render Complete Mail Settings Section --- NUEVO
        render_mail_group = QGroupBox(&quot;Render Complete Mail Settings&quot;)
        render_mail_layout_container = QVBoxLayout()
        render_mail_form_layout = QFormLayout()
        self.render_mail_from_input = QLineEdit()
        self.render_mail_pass_input = QLineEdit()
        self.render_mail_pass_input.setEchoMode(QLineEdit.Password)
        self.render_mail_to_input = QLineEdit()
        # Placeholders para los campos de mail
        self.render_mail_from_input.setPlaceholderText(&quot;e.g., tuMail@outlook.com&quot;)
        self.render_mail_pass_input.setPlaceholderText(&quot;&quot;)
        self.render_mail_to_input.setPlaceholderText(&quot;e.g., tuMail@gmail.com&quot;)
        # Cargar valores actuales
        try:
            rc_ensure_config_exists()
            from_email, from_password, to_email = rc_get_mail_settings_from_config()
            self.render_mail_from_input.setText(from_email or &quot;&quot;)
            self.render_mail_pass_input.setText(from_password or &quot;&quot;)
            self.render_mail_to_input.setText(to_email or &quot;&quot;)
        except Exception as e:
            print(f&quot;Error al cargar config de Render Complete Mail: {e}&quot;)
        render_mail_form_layout.addRow(&quot;From (Outlook):&quot;, self.render_mail_from_input)
        render_mail_form_layout.addRow(&quot;Password:&quot;, self.render_mail_pass_input)
        render_mail_form_layout.addRow(&quot;To (Recipient):&quot;, self.render_mail_to_input)
        render_mail_layout_container.addLayout(render_mail_form_layout)
        # --- NUEVOS SETTINGS ---
        self.cb_enable_mail = QCheckBox(&quot;Enable mail sending&quot;)
        self.cb_enable_render_time = QCheckBox(&quot;Enable render time calculation&quot;)
        self.cb_enable_sound = QCheckBox(&quot;Enable sound notification&quot;)
        render_mail_layout_container.addWidget(self.cb_enable_mail)
        render_mail_layout_container.addWidget(self.cb_enable_render_time)
        render_mail_layout_container.addWidget(self.cb_enable_sound)
        # Selector de archivo .wav
        wav_layout = QHBoxLayout()
        self.wav_path_input = QLineEdit()
        self.wav_path_input.setPlaceholderText(&quot;Select .wav file...&quot;)
        self.wav_browse_btn = QPushButton(&quot;Browse&quot;)
        self.wav_browse_btn.clicked.connect(self.browse_wav_file)
        wav_layout.addWidget(self.wav_path_input)
        wav_layout.addWidget(self.wav_browse_btn)
        render_mail_layout_container.addLayout(wav_layout)
        # ---

        self.save_render_mail_button = QPushButton(&quot;Save&quot;)
        self.save_render_mail_button.clicked.connect(self.save_render_mail_settings)
        render_mail_layout_container.addWidget(
            self.save_render_mail_button, 0, Qt.AlignRight
        )
        render_mail_group.setLayout(render_mail_layout_container)
        main_layout.addWidget(render_mail_group)
        # ---
        main_layout.addStretch()

    def save_write_focus_settings(self):
        &quot;&quot;&quot;Guarda el nombre del nodo de Write Focus en su archivo .ini.&quot;&quot;&quot;
        config_file_path = wf_get_config_path()
        if not config_file_path:
            print(&quot;Error: No se pudo obtener la ruta para guardar Write Focus.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Write Focus.&quot;,
            )
            return

        new_node_name = self.write_focus_input.text().strip()
        if not new_node_name:
            QMessageBox.warning(
                self, &quot;Input Error&quot;, &quot;Write Focus node name cannot be empty.&quot;
            )
            # Revertir al valor anterior o al por defecto
            try:
                current_node_name = wf_get_node_name_from_config()
                self.write_focus_input.setText(
                    current_node_name or WF_DEFAULT_NODE_NAME
                )
            except Exception:
                self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)
            return

        config = configparser.ConfigParser()
        try:
            # Leer existente para preservar otras secciones/claves
            if os.path.exists(config_file_path):
                config.read(config_file_path)

            if not config.has_section(WF_CONFIG_SECTION):
                config.add_section(WF_CONFIG_SECTION)

            config.set(WF_CONFIG_SECTION, WF_CONFIG_NODE_NAME_KEY, new_node_name)

            with open(config_file_path, &quot;w&quot;) as configfile:
                config.write(configfile)

            print(f&quot;Configuracion de Write Focus guardada: {new_node_name}&quot;)
            QMessageBox.information(self, &quot;Success&quot;, &quot;Write Focus settings saved.&quot;)

        except Exception as e:
            print(f&quot;Error al guardar la configuracion de Write Focus: {e}&quot;)
            QMessageBox.critical(
                self, &quot;Save Error&quot;, f&quot;Could not save Write Focus settings:\n{e}&quot;
            )

    def save_show_flow_settings(self):
        &quot;&quot;&quot;Guarda las credenciales de Show in Flow en su archivo .ini.&quot;&quot;&quot;
        config_file_path = sif_get_config_path()
        if not config_file_path:
            print(&quot;Error: No se pudo obtener la ruta para guardar Show in Flow.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Show in Flow.&quot;,
            )
            return

        new_url = self.site_input.text().strip()
        new_login = self.username_input.text().strip()
        new_password = self.password_input.text()  # No hacer strip a la password

        if not new_url or not new_login or not new_password:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;Show in Flow URL, Login, and Password cannot be empty.&quot;,
            )
            # No revertimos aqui, dejamos que el usuario corrija
            return

        # Llamar a la nueva funcion de guardado que maneja la codificacion
        try:
            success = sif_save_credentials_to_config(new_url, new_login, new_password)
            if success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(self, &quot;Success&quot;, &quot;Show in Flow settings saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Show in Flow settings. Check console for details.&quot;,
                )
        except Exception as e:
            print(f&quot;Error al llamar a save_credentials_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Show in Flow settings:\n{e}&quot;,
            )

    def save_color_space_settings(self):  # Nuevo metodo
        &quot;&quot;&quot;Guarda la lista de Color Space Favorites en su archivo .ini.&quot;&quot;&quot;
        # Re-obtener la ruta por si acaso, pero no forzar creacion/copia aqui
        ini_path = getattr(
            self,
            &quot;colorspace_ini_path&quot;,
            get_colorspace_ini_path(create_if_missing=False),
        )

        if not ini_path:
            print(&quot;Error: No se pudo obtener la ruta para guardar Color Space Favs.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Color Space Favorites.&quot;,
            )
            return

        # Obtener texto del QTextEdit
        text = self.color_space_edit.toPlainText()
        # Dividir en lineas, quitar espacios y filtrar vacias/solo espacios
        favorites_list = [line.strip() for line in text.split(&quot;\n&quot;) if line.strip()]

        # Usar la funcion importada para guardar
        try:
            success = save_colorspaces_to_ini(ini_path, favorites_list)
            if success:
                print(&quot;Configuracion de Color Space Favorites guardada.&quot;)
                QMessageBox.information(self, &quot;Success&quot;, &quot;Color Space Favorites saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso en la funcion save_colorspaces_to_ini
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Color Space Favorites. Check console for details.&quot;,
                )

        except Exception as e:
            # Captura por si save_colorspaces_to_ini lanza una excepcion inesperada
            print(f&quot;Error inesperado al llamar a save_colorspaces_to_ini: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Color Space Favorites:\n{e}&quot;,
            )

    def save_render_mail_settings(self):
        &quot;&quot;&quot;Guarda los datos de mail de Render Complete en su archivo .ini.&quot;&quot;&quot;
        config_file_path = rc_get_config_path()
        if not config_file_path:
            print(
                &quot;Error: No se pudo obtener la ruta para guardar Render Complete Mail.&quot;
            )
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Render Complete Mail.&quot;,
            )
            return
        from_email = self.render_mail_from_input.text().strip()
        from_password = self.render_mail_pass_input.text()
        to_email = self.render_mail_to_input.text().strip()
        if not from_email or not from_password or not to_email:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;All mail fields must be filled (From, Password, To).&quot;,
            )
            # No revertimos, dejamos que el usuario corrija
            return
        try:
            # La funcion rc_save_mail_settings_to_config ahora maneja la codificacion interna
            success = rc_save_mail_settings_to_config(
                from_email, from_password, to_email
            )
            if success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(
                    self, &quot;Success&quot;, &quot;Render Complete Mail settings saved.&quot;
                )
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Render Complete Mail settings. Check console for details.&quot;,
                )
        except Exception as e:
            print(f&quot;Error al llamar a save_mail_settings_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Render Complete Mail settings:\n{e}&quot;,
            )

    def browse_wav_file(self):
        &quot;&quot;&quot;Abre un diálogo para seleccionar un archivo .wav y lo pone en el QLineEdit.&quot;&quot;&quot;
        file_path, _ = QFileDialog.getOpenFileName(
            self, &quot;Select WAV file&quot;, &quot;&quot;, &quot;WAV Files (*.wav)&quot;
        )
        if file_path:
            self.wav_path_input.setText(file_path)


# --- Main Execution ---
if __name__ == &quot;__main__&quot;:
    # Necesario para ejecucion standalone fuera de Nuke
    app = QApplication.instance() or QApplication(sys.argv)

    settings_window = SettingsWindow()
    settings_window.show()

    # Mantener el bucle para ejecucion standalone
    if not QApplication.instance():  # Solo si no estamos en Nuke
        sys.exit(app.exec_())
    # Si estamos en Nuke, no llamamos a sys.exit()
&quot;&quot;&quot;
_____________________________________________________________________________________________________

  LGA_ToolPack_settings v0.4 | Lega
  Configuracion de la herramienta LGA_ToolPack
_____________________________________________________________________________________________________
&quot;&quot;&quot;

import sys
import os
import configparser
import typing  # Importar typing
from typing import Optional, Tuple

from PySide2.QtWidgets import (
    QApplication,
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QGroupBox,
    QLabel,
    QLineEdit,
    QFormLayout,
    QPushButton,
    QTextEdit,  # Importar QTextEdit
    QMessageBox,  # Importar QMessageBox
    QCheckBox,
    QFileDialog,
)
from PySide2.QtCore import Qt

# Importar funciones y constantes desde LGA_Write_Focus
# Asumiendo que ambos scripts estan en el mismo directorio o en el sys.path
try:
    from LGA_Write_Focus import (
        get_config_path as wf_get_config_path,  # Renombrar para claridad
        ensure_config_exists as wf_ensure_config_exists,
        get_node_name_from_config as wf_get_node_name_from_config,
        DEFAULT_NODE_NAME as WF_DEFAULT_NODE_NAME,  # Renombrar constante
        CONFIG_SECTION as WF_CONFIG_SECTION,  # Renombrar constante
        CONFIG_NODE_NAME_KEY as WF_CONFIG_NODE_NAME_KEY,  # Renombrar constante
    )
except ImportError as e_wf:
    print(f&quot;Error al importar LGA_Write_Focus.py: {e_wf}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def wf_ensure_config_exists():
        pass

    def wf_get_node_name_from_config() -&gt; str:
        return &quot;Write_Pub&quot;

    def wf_get_config_path() -&gt; typing.Optional[str]:
        return None

    WF_DEFAULT_NODE_NAME = &quot;Write_Pub&quot;
    WF_CONFIG_SECTION = &quot;Settings&quot;
    WF_CONFIG_NODE_NAME_KEY = &quot;node_name&quot;

# --- Importaciones de LGA_showInlFlow ---
try:
    from LGA_showInlFlow import (
        get_config_path as sif_get_config_path,
        ensure_config_exists as sif_ensure_config_exists,
        get_credentials_from_config as sif_get_credentials_from_config,
        save_credentials_to_config as sif_save_credentials_to_config,
    )
except ImportError as e_sif:
    print(f&quot;Error al importar LGA_showInlFlow.py: {e_sif}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def sif_ensure_config_exists():
        pass

    def sif_get_credentials_from_config() -&gt; (
        typing.Tuple[typing.Optional[str], typing.Optional[str], typing.Optional[str]]
    ):
        return None, None, None

    def sif_get_config_path() -&gt; typing.Optional[str]:
        return None

    # Funcion save dummy
    def sif_save_credentials_to_config(url, login, password) -&gt; bool:
        print(
            &quot;Error: LGA_showInlFlow.py no encontrado, no se pueden guardar credenciales.&quot;
        )
        return False


# --- Importaciones de LGA_RnW_ColorSpace_Favs --- Nuevo
try:
    from LGA_RnW_ColorSpace_Favs import (
        get_colorspace_ini_path,
        read_colorspaces_from_ini,
        save_colorspaces_to_ini,
        COLORSPACE_SECTION,  # Importar tambien la constante de seccion
    )
except ImportError as e_csf:
    print(
        f&quot;Error al importar LGA_RnW_ColorSpace_Favs.py: {e_csf}. Funcionalidad limitada.&quot;
    )

    # Definir funciones dummy
    def get_colorspace_ini_path(create_if_missing: bool = True) -&gt; typing.Optional[str]:
        return None

    def read_colorspaces_from_ini(ini_path: typing.Optional[str]) -&gt; typing.List[str]:
        return []

    def save_colorspaces_to_ini(
        ini_path: typing.Optional[str], colorspaces_list: typing.List[str]
    ) -&gt; bool:
        return False

    COLORSPACE_SECTION = &quot;ColorSpaces&quot;

# --- Importaciones de LGA_Render_Complete --- NUEVO
try:
    from LGA_Render_Complete import (
        get_config_path as rc_get_config_path,
        ensure_config_exists as rc_ensure_config_exists,
        get_mail_settings_from_config as rc_get_mail_settings_from_config,
        save_mail_settings_to_config as rc_save_mail_settings_to_config,
        CONFIG_FROM_KEY as RC_CONFIG_FROM_KEY,
        CONFIG_PASS_KEY as RC_CONFIG_PASS_KEY,
        CONFIG_TO_KEY as RC_CONFIG_TO_KEY,
    )
except ImportError as e_rc:
    print(f&quot;Error al importar LGA_Render_Complete.py: {e_rc}. Funcionalidad limitada.&quot;)

    def rc_ensure_config_exists() -&gt; None:
        pass

    def rc_get_mail_settings_from_config() -&gt; (
        Tuple[Optional[str], Optional[str], Optional[str]]
    ):
        return None, None, None

    def rc_save_mail_settings_to_config(from_email, from_password, to_email) -&gt; bool:
        return False

    def rc_get_config_path() -&gt; Optional[str]:
        return None

    RC_CONFIG_FROM_KEY = &quot;from_email&quot;
    RC_CONFIG_PASS_KEY = &quot;from_password&quot;
    RC_CONFIG_TO_KEY = &quot;to_email&quot;


class SettingsWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(&quot;LGA ToolPack Settings&quot;)
        self.setMinimumWidth(450)  # Un poco mas ancho para el QTextEdit
        self.initUI()

    def initUI(self):
        main_layout = QVBoxLayout(self)

        # --- Write Presets Section (Placeholder) ---
        write_presets_group = QGroupBox(&quot;Write Presets&quot;)
        write_presets_layout = QVBoxLayout()
        write_presets_layout.addWidget(
            QLabel(&quot;(Placeholder for Write Presets functionality)&quot;)
        )
        self.save_write_presets_button = QPushButton(&quot;Save&quot;)
        # self.save_write_presets_button.clicked.connect(self.save_write_presets) # Placeholder
        write_presets_layout.addWidget(self.save_write_presets_button, 0, Qt.AlignRight)
        write_presets_group.setLayout(write_presets_layout)
        main_layout.addWidget(write_presets_group)

        # --- Write Focus Section ---
        write_focus_group = QGroupBox(&quot;Write Focus&quot;)
        write_focus_layout_container = QVBoxLayout()
        write_focus_form_layout = QFormLayout()
        self.write_focus_input = QLineEdit()
        try:
            wf_ensure_config_exists()  # Usar funcion importada
            current_node_name = wf_get_node_name_from_config()  # Usar funcion importada
            self.write_focus_input.setText(current_node_name or WF_DEFAULT_NODE_NAME)
        except Exception as e:
            print(f&quot;Error al cargar config de Write Focus: {e}&quot;)
            self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)

        write_focus_form_layout.addRow(
            &quot;Name of the Write Node to Focus:&quot;, self.write_focus_input
        )
        write_focus_layout_container.addLayout(write_focus_form_layout)
        self.save_write_focus_button = QPushButton(&quot;Save&quot;)
        self.save_write_focus_button.clicked.connect(self.save_write_focus_settings)
        write_focus_layout_container.addWidget(
            self.save_write_focus_button, 0, Qt.AlignRight
        )
        write_focus_group.setLayout(write_focus_layout_container)
        main_layout.addWidget(write_focus_group)

        # --- Show in Flow Section ---
        show_flow_group = QGroupBox(&quot;Show in Flow&quot;)
        show_flow_layout_container = QVBoxLayout()
        show_flow_form_layout = QFormLayout()
        self.username_input = QLineEdit()
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.Password)
        self.site_input = QLineEdit()
        # Placeholders para los campos de ShotGrid
        self.site_input.setPlaceholderText(&quot;e.g., https://studio.shotgrid.autodesk.com&quot;)
        self.username_input.setPlaceholderText(&quot;e.g., artist@studio.com&quot;)
        self.password_input.setPlaceholderText(&quot;&quot;)
        show_flow_form_layout.addRow(
            &quot;ShotGrid URL:&quot;,
            self.site_input,
        )
        show_flow_form_layout.addRow(&quot;ShotGrid Login:&quot;, self.username_input)
        show_flow_form_layout.addRow(&quot;ShotGrid Password:&quot;, self.password_input)

        try:
            sif_ensure_config_exists()  # Usar funcion importada
            sif_url, sif_login, sif_password = (
                sif_get_credentials_from_config()
            )  # Usar funcion importada
            self.site_input.setText(sif_url or &quot;&quot;)
            self.username_input.setText(sif_login or &quot;&quot;)
            self.password_input.setText(sif_password or &quot;&quot;)
        except Exception as e:
            print(f&quot;Error al cargar credenciales de Show in Flow: {e}&quot;)

        show_flow_layout_container.addLayout(show_flow_form_layout)
        self.save_show_flow_button = QPushButton(&quot;Save&quot;)
        self.save_show_flow_button.clicked.connect(self.save_show_flow_settings)
        show_flow_layout_container.addWidget(
            self.save_show_flow_button, 0, Qt.AlignRight
        )
        show_flow_group.setLayout(show_flow_layout_container)
        main_layout.addWidget(show_flow_group)

        # --- Color Space Favs Section --- Modificado
        color_space_group = QGroupBox(&quot;Color Space Favorites&quot;)  # Titulo mas descriptivo
        color_space_layout = QVBoxLayout()
        color_space_layout.addWidget(
            QLabel(
                &quot;Enter favorite OCIO color spaces (one per line):&quot;
            )  # Label explicativo
        )
        # Crear el QTextEdit
        self.color_space_edit = QTextEdit()
        self.color_space_edit.setPlaceholderText(
            &quot;e.g.,\nOutput - sRGB\nUtility - Raw\nACES - ACEScg&quot;
        )
        self.color_space_edit.setMinimumHeight(80)  # Altura minima
        color_space_layout.addWidget(self.color_space_edit)

        # --- Cargar favoritos existentes --- Nuevo
        try:
            self.colorspace_ini_path = get_colorspace_ini_path(create_if_missing=True)
            if self.colorspace_ini_path:
                fav_list = read_colorspaces_from_ini(self.colorspace_ini_path)
                self.color_space_edit.setText(&quot;\n&quot;.join(fav_list))
            else:
                print(&quot;Advertencia: No se pudo obtener la ruta del INI de ColorSpaces.&quot;)
                # Podriamos deshabilitar el campo/boton si no hay ruta
                # self.color_space_edit.setEnabled(False)
        except Exception as e:
            print(f&quot;Error al cargar Color Space Favs: {e}&quot;)
            QMessageBox.warning(
                self, &quot;Error&quot;, f&quot;Could not load Color Space Favorites:\n{e}&quot;
            )
        # ---------------------------------

        self.save_color_space_button = QPushButton(&quot;Save&quot;)
        self.save_color_space_button.clicked.connect(
            self.save_color_space_settings
        )  # Conectar al nuevo metodo
        color_space_layout.addWidget(self.save_color_space_button, 0, Qt.AlignRight)
        color_space_group.setLayout(color_space_layout)
        main_layout.addWidget(color_space_group)

        # --- Render Complete Mail Settings Section --- NUEVO
        render_mail_group = QGroupBox(&quot;Render Complete Mail Settings&quot;)
        render_mail_layout_container = QVBoxLayout()
        render_mail_form_layout = QFormLayout()
        self.render_mail_from_input = QLineEdit()
        self.render_mail_pass_input = QLineEdit()
        self.render_mail_pass_input.setEchoMode(QLineEdit.Password)
        self.render_mail_to_input = QLineEdit()
        # Placeholders para los campos de mail
        self.render_mail_from_input.setPlaceholderText(&quot;e.g., tuMail@outlook.com&quot;)
        self.render_mail_pass_input.setPlaceholderText(&quot;&quot;)
        self.render_mail_to_input.setPlaceholderText(&quot;e.g., tuMail@gmail.com&quot;)
        # Cargar valores actuales
        try:
            rc_ensure_config_exists()
            from_email, from_password, to_email = rc_get_mail_settings_from_config()
            self.render_mail_from_input.setText(from_email or &quot;&quot;)
            self.render_mail_pass_input.setText(from_password or &quot;&quot;)
            self.render_mail_to_input.setText(to_email or &quot;&quot;)
        except Exception as e:
            print(f&quot;Error al cargar config de Render Complete Mail: {e}&quot;)
        render_mail_form_layout.addRow(&quot;From (Outlook):&quot;, self.render_mail_from_input)
        render_mail_form_layout.addRow(&quot;Password:&quot;, self.render_mail_pass_input)
        render_mail_form_layout.addRow(&quot;To (Recipient):&quot;, self.render_mail_to_input)
        render_mail_layout_container.addLayout(render_mail_form_layout)
        # --- NUEVOS SETTINGS ---
        self.cb_enable_mail = QCheckBox(&quot;Enable mail sending&quot;)
        self.cb_enable_render_time = QCheckBox(&quot;Enable render time calculation&quot;)
        self.cb_enable_sound = QCheckBox(&quot;Enable sound notification&quot;)
        render_mail_layout_container.addWidget(self.cb_enable_mail)
        render_mail_layout_container.addWidget(self.cb_enable_render_time)
        render_mail_layout_container.addWidget(self.cb_enable_sound)
        # Selector de archivo .wav
        wav_layout = QHBoxLayout()
        self.wav_path_input = QLineEdit()
        self.wav_path_input.setPlaceholderText(&quot;Select .wav file...&quot;)
        self.wav_browse_btn = QPushButton(&quot;Browse&quot;)
        self.wav_browse_btn.clicked.connect(self.browse_wav_file)
        wav_layout.addWidget(self.wav_path_input)
        wav_layout.addWidget(self.wav_browse_btn)
        render_mail_layout_container.addLayout(wav_layout)
        # ---

        self.save_render_mail_button = QPushButton(&quot;Save&quot;)
        self.save_render_mail_button.clicked.connect(self.save_render_mail_settings)
        render_mail_layout_container.addWidget(
            self.save_render_mail_button, 0, Qt.AlignRight
        )
        render_mail_group.setLayout(render_mail_layout_container)
        main_layout.addWidget(render_mail_group)
        # ---
        main_layout.addStretch()

    def save_write_focus_settings(self):
        &quot;&quot;&quot;Guarda el nombre del nodo de Write Focus en su archivo .ini.&quot;&quot;&quot;
        config_file_path = wf_get_config_path()
        if not config_file_path:
            print(&quot;Error: No se pudo obtener la ruta para guardar Write Focus.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Write Focus.&quot;,
            )
            return

        new_node_name = self.write_focus_input.text().strip()
        if not new_node_name:
            QMessageBox.warning(
                self, &quot;Input Error&quot;, &quot;Write Focus node name cannot be empty.&quot;
            )
            # Revertir al valor anterior o al por defecto
            try:
                current_node_name = wf_get_node_name_from_config()
                self.write_focus_input.setText(
                    current_node_name or WF_DEFAULT_NODE_NAME
                )
            except Exception:
                self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)
            return

        config = configparser.ConfigParser()
        try:
            # Leer existente para preservar otras secciones/claves
            if os.path.exists(config_file_path):
                config.read(config_file_path)

            if not config.has_section(WF_CONFIG_SECTION):
                config.add_section(WF_CONFIG_SECTION)

            config.set(WF_CONFIG_SECTION, WF_CONFIG_NODE_NAME_KEY, new_node_name)

            with open(config_file_path, &quot;w&quot;) as configfile:
                config.write(configfile)

            print(f&quot;Configuracion de Write Focus guardada: {new_node_name}&quot;)
            QMessageBox.information(self, &quot;Success&quot;, &quot;Write Focus settings saved.&quot;)

        except Exception as e:
            print(f&quot;Error al guardar la configuracion de Write Focus: {e}&quot;)
            QMessageBox.critical(
                self, &quot;Save Error&quot;, f&quot;Could not save Write Focus settings:\n{e}&quot;
            )

    def save_show_flow_settings(self):
        &quot;&quot;&quot;Guarda las credenciales de Show in Flow en su archivo .ini.&quot;&quot;&quot;
        config_file_path = sif_get_config_path()
        if not config_file_path:
            print(&quot;Error: No se pudo obtener la ruta para guardar Show in Flow.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Show in Flow.&quot;,
            )
            return

        new_url = self.site_input.text().strip()
        new_login = self.username_input.text().strip()
        new_password = self.password_input.text()  # No hacer strip a la password

        if not new_url or not new_login or not new_password:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;Show in Flow URL, Login, and Password cannot be empty.&quot;,
            )
            # No revertimos aqui, dejamos que el usuario corrija
            return

        # Llamar a la nueva funcion de guardado que maneja la codificacion
        try:
            success = sif_save_credentials_to_config(new_url, new_login, new_password)
            if success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(self, &quot;Success&quot;, &quot;Show in Flow settings saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Show in Flow settings. Check console for details.&quot;,
                )
        except Exception as e:
            print(f&quot;Error al llamar a save_credentials_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Show in Flow settings:\n{e}&quot;,
            )

    def save_color_space_settings(self):  # Nuevo metodo
        &quot;&quot;&quot;Guarda la lista de Color Space Favorites en su archivo .ini.&quot;&quot;&quot;
        # Re-obtener la ruta por si acaso, pero no forzar creacion/copia aqui
        ini_path = getattr(
            self,
            &quot;colorspace_ini_path&quot;,
            get_colorspace_ini_path(create_if_missing=False),
        )

        if not ini_path:
            print(&quot;Error: No se pudo obtener la ruta para guardar Color Space Favs.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Color Space Favorites.&quot;,
            )
            return

        # Obtener texto del QTextEdit
        text = self.color_space_edit.toPlainText()
        # Dividir en lineas, quitar espacios y filtrar vacias/solo espacios
        favorites_list = [line.strip() for line in text.split(&quot;\n&quot;) if line.strip()]

        # Usar la funcion importada para guardar
        try:
            success = save_colorspaces_to_ini(ini_path, favorites_list)
            if success:
                print(&quot;Configuracion de Color Space Favorites guardada.&quot;)
                QMessageBox.information(self, &quot;Success&quot;, &quot;Color Space Favorites saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso en la funcion save_colorspaces_to_ini
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Color Space Favorites. Check console for details.&quot;,
                )

        except Exception as e:
            # Captura por si save_colorspaces_to_ini lanza una excepcion inesperada
            print(f&quot;Error inesperado al llamar a save_colorspaces_to_ini: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Color Space Favorites:\n{e}&quot;,
            )

    def save_render_mail_settings(self):
        &quot;&quot;&quot;Guarda los datos de mail de Render Complete en su archivo .ini.&quot;&quot;&quot;
        config_file_path = rc_get_config_path()
        if not config_file_path:
            print(
                &quot;Error: No se pudo obtener la ruta para guardar Render Complete Mail.&quot;
            )
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Render Complete Mail.&quot;,
            )
            return
        from_email = self.render_mail_from_input.text().strip()
        from_password = self.render_mail_pass_input.text()
        to_email = self.render_mail_to_input.text().strip()
        if not from_email or not from_password or not to_email:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;All mail fields must be filled (From, Password, To).&quot;,
            )
            # No revertimos, dejamos que el usuario corrija
            return
        try:
            # La funcion rc_save_mail_settings_to_config ahora maneja la codificacion interna
            success = rc_save_mail_settings_to_config(
                from_email, from_password, to_email
            )
            if success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(
                    self, &quot;Success&quot;, &quot;Render Complete Mail settings saved.&quot;
                )
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Render Complete Mail settings. Check console for details.&quot;,
                )
        except Exception as e:
            print(f&quot;Error al llamar a save_mail_settings_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Render Complete Mail settings:\n{e}&quot;,
            )

    def browse_wav_file(self):
        &quot;&quot;&quot;Abre un diálogo para seleccionar un archivo .wav y lo pone en el QLineEdit.&quot;&quot;&quot;
        file_path, _ = QFileDialog.getOpenFileName(
            self, &quot;Select WAV file&quot;, &quot;&quot;, &quot;WAV Files (*.wav)&quot;
        )
        if file_path:
            self.wav_path_input.setText(file_path)


# --- Main Execution ---
if __name__ == &quot;__main__&quot;:
    # Necesario para ejecucion standalone fuera de Nuke
    app = QApplication.instance() or QApplication(sys.argv)

    settings_window = SettingsWindow()
    settings_window.show()

    # Mantener el bucle para ejecucion standalone
    if not QApplication.instance():  # Solo si no estamos en Nuke
        sys.exit(app.exec_())
    # Si estamos en Nuke, no llamamos a sys.exit()
&quot;&quot;&quot;
_____________________________________________________________________________________________________

  LGA_ToolPack_settings v0.4 | Lega
  Configuracion de la herramienta LGA_ToolPack
_____________________________________________________________________________________________________
&quot;&quot;&quot;

import sys
import os
import configparser
import typing  # Importar typing
from typing import Optional, Tuple

from PySide2.QtWidgets import (
    QApplication,
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QGroupBox,
    QLabel,
    QLineEdit,
    QFormLayout,
    QPushButton,
    QTextEdit,  # Importar QTextEdit
    QMessageBox,  # Importar QMessageBox
    QCheckBox,
    QFileDialog,
)
from PySide2.QtCore import Qt

# Importar funciones y constantes desde LGA_Write_Focus
# Asumiendo que ambos scripts estan en el mismo directorio o en el sys.path
try:
    from LGA_Write_Focus import (
        get_config_path as wf_get_config_path,  # Renombrar para claridad
        ensure_config_exists as wf_ensure_config_exists,
        get_node_name_from_config as wf_get_node_name_from_config,
        DEFAULT_NODE_NAME as WF_DEFAULT_NODE_NAME,  # Renombrar constante
        CONFIG_SECTION as WF_CONFIG_SECTION,  # Renombrar constante
        CONFIG_NODE_NAME_KEY as WF_CONFIG_NODE_NAME_KEY,  # Renombrar constante
    )
except ImportError as e_wf:
    print(f&quot;Error al importar LGA_Write_Focus.py: {e_wf}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def wf_ensure_config_exists():
        pass

    def wf_get_node_name_from_config() -&gt; str:
        return &quot;Write_Pub&quot;

    def wf_get_config_path() -&gt; typing.Optional[str]:
        return None

    WF_DEFAULT_NODE_NAME = &quot;Write_Pub&quot;
    WF_CONFIG_SECTION = &quot;Settings&quot;
    WF_CONFIG_NODE_NAME_KEY = &quot;node_name&quot;

# --- Importaciones de LGA_showInlFlow ---
try:
    from LGA_showInlFlow import (
        get_config_path as sif_get_config_path,
        ensure_config_exists as sif_ensure_config_exists,
        get_credentials_from_config as sif_get_credentials_from_config,
        save_credentials_to_config as sif_save_credentials_to_config,
    )
except ImportError as e_sif:
    print(f&quot;Error al importar LGA_showInlFlow.py: {e_sif}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def sif_ensure_config_exists():
        pass

    def sif_get_credentials_from_config() -&gt; (
        typing.Tuple[typing.Optional[str], typing.Optional[str], typing.Optional[str]]
    ):
        return None, None, None

    def sif_get_config_path() -&gt; typing.Optional[str]:
        return None

    # Funcion save dummy
    def sif_save_credentials_to_config(url, login, password) -&gt; bool:
        print(
            &quot;Error: LGA_showInlFlow.py no encontrado, no se pueden guardar credenciales.&quot;
        )
        return False


# --- Importaciones de LGA_RnW_ColorSpace_Favs --- Nuevo
try:
    from LGA_RnW_ColorSpace_Favs import (
        get_colorspace_ini_path,
        read_colorspaces_from_ini,
        save_colorspaces_to_ini,
        COLORSPACE_SECTION,  # Importar tambien la constante de seccion
    )
except ImportError as e_csf:
    print(
        f&quot;Error al importar LGA_RnW_ColorSpace_Favs.py: {e_csf}. Funcionalidad limitada.&quot;
    )

    # Definir funciones dummy
    def get_colorspace_ini_path(create_if_missing: bool = True) -&gt; typing.Optional[str]:
        return None

    def read_colorspaces_from_ini(ini_path: typing.Optional[str]) -&gt; typing.List[str]:
        return []

    def save_colorspaces_to_ini(
        ini_path: typing.Optional[str], colorspaces_list: typing.List[str]
    ) -&gt; bool:
        return False

    COLORSPACE_SECTION = &quot;ColorSpaces&quot;

# --- Importaciones de LGA_Render_Complete --- NUEVO
try:
    from LGA_Render_Complete import (
        get_config_path as rc_get_config_path,
        ensure_config_exists as rc_ensure_config_exists,
        get_mail_settings_from_config as rc_get_mail_settings_from_config,
        save_mail_settings_to_config as rc_save_mail_settings_to_config,
        CONFIG_FROM_KEY as RC_CONFIG_FROM_KEY,
        CONFIG_PASS_KEY as RC_CONFIG_PASS_KEY,
        CONFIG_TO_KEY as RC_CONFIG_TO_KEY,
    )
except ImportError as e_rc:
    print(f&quot;Error al importar LGA_Render_Complete.py: {e_rc}. Funcionalidad limitada.&quot;)

    def rc_ensure_config_exists() -&gt; None:
        pass

    def rc_get_mail_settings_from_config() -&gt; (
        Tuple[Optional[str], Optional[str], Optional[str]]
    ):
        return None, None, None

    def rc_save_mail_settings_to_config(from_email, from_password, to_email) -&gt; bool:
        return False

    def rc_get_config_path() -&gt; Optional[str]:
        return None

    RC_CONFIG_FROM_KEY = &quot;from_email&quot;
    RC_CONFIG_PASS_KEY = &quot;from_password&quot;
    RC_CONFIG_TO_KEY = &quot;to_email&quot;


class SettingsWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(&quot;LGA ToolPack Settings&quot;)
        self.setMinimumWidth(450)  # Un poco mas ancho para el QTextEdit
        self.initUI()

    def initUI(self):
        main_layout = QVBoxLayout(self)

        # --- Write Presets Section (Placeholder) ---
        write_presets_group = QGroupBox(&quot;Write Presets&quot;)
        write_presets_layout = QVBoxLayout()
        write_presets_layout.addWidget(
            QLabel(&quot;(Placeholder for Write Presets functionality)&quot;)
        )
        self.save_write_presets_button = QPushButton(&quot;Save&quot;)
        # self.save_write_presets_button.clicked.connect(self.save_write_presets) # Placeholder
        write_presets_layout.addWidget(self.save_write_presets_button, 0, Qt.AlignRight)
        write_presets_group.setLayout(write_presets_layout)
        main_layout.addWidget(write_presets_group)

        # --- Write Focus Section ---
        write_focus_group = QGroupBox(&quot;Write Focus&quot;)
        write_focus_layout_container = QVBoxLayout()
        write_focus_form_layout = QFormLayout()
        self.write_focus_input = QLineEdit()
        try:
            wf_ensure_config_exists()  # Usar funcion importada
            current_node_name = wf_get_node_name_from_config()  # Usar funcion importada
            self.write_focus_input.setText(current_node_name or WF_DEFAULT_NODE_NAME)
        except Exception as e:
            print(f&quot;Error al cargar config de Write Focus: {e}&quot;)
            self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)

        write_focus_form_layout.addRow(
            &quot;Name of the Write Node to Focus:&quot;, self.write_focus_input
        )
        write_focus_layout_container.addLayout(write_focus_form_layout)
        self.save_write_focus_button = QPushButton(&quot;Save&quot;)
        self.save_write_focus_button.clicked.connect(self.save_write_focus_settings)
        write_focus_layout_container.addWidget(
            self.save_write_focus_button, 0, Qt.AlignRight
        )
        write_focus_group.setLayout(write_focus_layout_container)
        main_layout.addWidget(write_focus_group)

        # --- Show in Flow Section ---
        show_flow_group = QGroupBox(&quot;Show in Flow&quot;)
        show_flow_layout_container = QVBoxLayout()
        show_flow_form_layout = QFormLayout()
        self.username_input = QLineEdit()
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.Password)
        self.site_input = QLineEdit()
        # Placeholders para los campos de ShotGrid
        self.site_input.setPlaceholderText(&quot;e.g., https://studio.shotgrid.autodesk.com&quot;)
        self.username_input.setPlaceholderText(&quot;e.g., artist@studio.com&quot;)
        self.password_input.setPlaceholderText(&quot;&quot;)
        show_flow_form_layout.addRow(
            &quot;ShotGrid URL:&quot;,
            self.site_input,
        )
        show_flow_form_layout.addRow(&quot;ShotGrid Login:&quot;, self.username_input)
        show_flow_form_layout.addRow(&quot;ShotGrid Password:&quot;, self.password_input)

        try:
            sif_ensure_config_exists()  # Usar funcion importada
            sif_url, sif_login, sif_password = (
                sif_get_credentials_from_config()
            )  # Usar funcion importada
            self.site_input.setText(sif_url or &quot;&quot;)
            self.username_input.setText(sif_login or &quot;&quot;)
            self.password_input.setText(sif_password or &quot;&quot;)
        except Exception as e:
            print(f&quot;Error al cargar credenciales de Show in Flow: {e}&quot;)

        show_flow_layout_container.addLayout(show_flow_form_layout)
        self.save_show_flow_button = QPushButton(&quot;Save&quot;)
        self.save_show_flow_button.clicked.connect(self.save_show_flow_settings)
        show_flow_layout_container.addWidget(
            self.save_show_flow_button, 0, Qt.AlignRight
        )
        show_flow_group.setLayout(show_flow_layout_container)
        main_layout.addWidget(show_flow_group)

        # --- Color Space Favs Section --- Modificado
        color_space_group = QGroupBox(&quot;Color Space Favorites&quot;)  # Titulo mas descriptivo
        color_space_layout = QVBoxLayout()
        color_space_layout.addWidget(
            QLabel(
                &quot;Enter favorite OCIO color spaces (one per line):&quot;
            )  # Label explicativo
        )
        # Crear el QTextEdit
        self.color_space_edit = QTextEdit()
        self.color_space_edit.setPlaceholderText(
            &quot;e.g.,\nOutput - sRGB\nUtility - Raw\nACES - ACEScg&quot;
        )
        self.color_space_edit.setMinimumHeight(80)  # Altura minima
        color_space_layout.addWidget(self.color_space_edit)

        # --- Cargar favoritos existentes --- Nuevo
        try:
            self.colorspace_ini_path = get_colorspace_ini_path(create_if_missing=True)
            if self.colorspace_ini_path:
                fav_list = read_colorspaces_from_ini(self.colorspace_ini_path)
                self.color_space_edit.setText(&quot;\n&quot;.join(fav_list))
            else:
                print(&quot;Advertencia: No se pudo obtener la ruta del INI de ColorSpaces.&quot;)
                # Podriamos deshabilitar el campo/boton si no hay ruta
                # self.color_space_edit.setEnabled(False)
        except Exception as e:
            print(f&quot;Error al cargar Color Space Favs: {e}&quot;)
            QMessageBox.warning(
                self, &quot;Error&quot;, f&quot;Could not load Color Space Favorites:\n{e}&quot;
            )
        # ---------------------------------

        self.save_color_space_button = QPushButton(&quot;Save&quot;)
        self.save_color_space_button.clicked.connect(
            self.save_color_space_settings
        )  # Conectar al nuevo metodo
        color_space_layout.addWidget(self.save_color_space_button, 0, Qt.AlignRight)
        color_space_group.setLayout(color_space_layout)
        main_layout.addWidget(color_space_group)

        # --- Render Complete Mail Settings Section --- NUEVO
        render_mail_group = QGroupBox(&quot;Render Complete Mail Settings&quot;)
        render_mail_layout_container = QVBoxLayout()
        render_mail_form_layout = QFormLayout()
        self.render_mail_from_input = QLineEdit()
        self.render_mail_pass_input = QLineEdit()
        self.render_mail_pass_input.setEchoMode(QLineEdit.Password)
        self.render_mail_to_input = QLineEdit()
        # Placeholders para los campos de mail
        self.render_mail_from_input.setPlaceholderText(&quot;e.g., tuMail@outlook.com&quot;)
        self.render_mail_pass_input.setPlaceholderText(&quot;&quot;)
        self.render_mail_to_input.setPlaceholderText(&quot;e.g., tuMail@gmail.com&quot;)
        # Cargar valores actuales
        try:
            rc_ensure_config_exists()
            from_email, from_password, to_email = rc_get_mail_settings_from_config()
            self.render_mail_from_input.setText(from_email or &quot;&quot;)
            self.render_mail_pass_input.setText(from_password or &quot;&quot;)
            self.render_mail_to_input.setText(to_email or &quot;&quot;)
        except Exception as e:
            print(f&quot;Error al cargar config de Render Complete Mail: {e}&quot;)
        render_mail_form_layout.addRow(&quot;From (Outlook):&quot;, self.render_mail_from_input)
        render_mail_form_layout.addRow(&quot;Password:&quot;, self.render_mail_pass_input)
        render_mail_form_layout.addRow(&quot;To (Recipient):&quot;, self.render_mail_to_input)
        render_mail_layout_container.addLayout(render_mail_form_layout)
        # --- NUEVOS SETTINGS ---
        self.cb_enable_mail = QCheckBox(&quot;Enable mail sending&quot;)
        self.cb_enable_render_time = QCheckBox(&quot;Enable render time calculation&quot;)
        self.cb_enable_sound = QCheckBox(&quot;Enable sound notification&quot;)
        render_mail_layout_container.addWidget(self.cb_enable_mail)
        render_mail_layout_container.addWidget(self.cb_enable_render_time)
        render_mail_layout_container.addWidget(self.cb_enable_sound)
        # Selector de archivo .wav
        wav_layout = QHBoxLayout()
        self.wav_path_input = QLineEdit()
        self.wav_path_input.setPlaceholderText(&quot;Select .wav file...&quot;)
        self.wav_browse_btn = QPushButton(&quot;Browse&quot;)
        self.wav_browse_btn.clicked.connect(self.browse_wav_file)
        wav_layout.addWidget(self.wav_path_input)
        wav_layout.addWidget(self.wav_browse_btn)
        render_mail_layout_container.addLayout(wav_layout)
        # ---

        self.save_render_mail_button = QPushButton(&quot;Save&quot;)
        self.save_render_mail_button.clicked.connect(self.save_render_mail_settings)
        render_mail_layout_container.addWidget(
            self.save_render_mail_button, 0, Qt.AlignRight
        )
        render_mail_group.setLayout(render_mail_layout_container)
        main_layout.addWidget(render_mail_group)
        # ---
        main_layout.addStretch()

    def save_write_focus_settings(self):
        &quot;&quot;&quot;Guarda el nombre del nodo de Write Focus en su archivo .ini.&quot;&quot;&quot;
        config_file_path = wf_get_config_path()
        if not config_file_path:
            print(&quot;Error: No se pudo obtener la ruta para guardar Write Focus.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Write Focus.&quot;,
            )
            return

        new_node_name = self.write_focus_input.text().strip()
        if not new_node_name:
            QMessageBox.warning(
                self, &quot;Input Error&quot;, &quot;Write Focus node name cannot be empty.&quot;
            )
            # Revertir al valor anterior o al por defecto
            try:
                current_node_name = wf_get_node_name_from_config()
                self.write_focus_input.setText(
                    current_node_name or WF_DEFAULT_NODE_NAME
                )
            except Exception:
                self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)
            return

        config = configparser.ConfigParser()
        try:
            # Leer existente para preservar otras secciones/claves
            if os.path.exists(config_file_path):
                config.read(config_file_path)

            if not config.has_section(WF_CONFIG_SECTION):
                config.add_section(WF_CONFIG_SECTION)

            config.set(WF_CONFIG_SECTION, WF_CONFIG_NODE_NAME_KEY, new_node_name)

            with open(config_file_path, &quot;w&quot;) as configfile:
                config.write(configfile)

            print(f&quot;Configuracion de Write Focus guardada: {new_node_name}&quot;)
            QMessageBox.information(self, &quot;Success&quot;, &quot;Write Focus settings saved.&quot;)

        except Exception as e:
            print(f&quot;Error al guardar la configuracion de Write Focus: {e}&quot;)
            QMessageBox.critical(
                self, &quot;Save Error&quot;, f&quot;Could not save Write Focus settings:\n{e}&quot;
            )

    def save_show_flow_settings(self):
        &quot;&quot;&quot;Guarda las credenciales de Show in Flow en su archivo .ini.&quot;&quot;&quot;
        config_file_path = sif_get_config_path()
        if not config_file_path:
            print(&quot;Error: No se pudo obtener la ruta para guardar Show in Flow.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Show in Flow.&quot;,
            )
            return

        new_url = self.site_input.text().strip()
        new_login = self.username_input.text().strip()
        new_password = self.password_input.text()  # No hacer strip a la password

        if not new_url or not new_login or not new_password:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;Show in Flow URL, Login, and Password cannot be empty.&quot;,
            )
            # No revertimos aqui, dejamos que el usuario corrija
            return

        # Llamar a la nueva funcion de guardado que maneja la codificacion
        try:
            success = sif_save_credentials_to_config(new_url, new_login, new_password)
            if success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(self, &quot;Success&quot;, &quot;Show in Flow settings saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Show in Flow settings. Check console for details.&quot;,
                )
        except Exception as e:
            print(f&quot;Error al llamar a save_credentials_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Show in Flow settings:\n{e}&quot;,
            )

    def save_color_space_settings(self):  # Nuevo metodo
        &quot;&quot;&quot;Guarda la lista de Color Space Favorites en su archivo .ini.&quot;&quot;&quot;
        # Re-obtener la ruta por si acaso, pero no forzar creacion/copia aqui
        ini_path = getattr(
            self,
            &quot;colorspace_ini_path&quot;,
            get_colorspace_ini_path(create_if_missing=False),
        )

        if not ini_path:
            print(&quot;Error: No se pudo obtener la ruta para guardar Color Space Favs.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Color Space Favorites.&quot;,
            )
            return

        # Obtener texto del QTextEdit
        text = self.color_space_edit.toPlainText()
        # Dividir en lineas, quitar espacios y filtrar vacias/solo espacios
        favorites_list = [line.strip() for line in text.split(&quot;\n&quot;) if line.strip()]

        # Usar la funcion importada para guardar
        try:
            success = save_colorspaces_to_ini(ini_path, favorites_list)
            if success:
                print(&quot;Configuracion de Color Space Favorites guardada.&quot;)
                QMessageBox.information(self, &quot;Success&quot;, &quot;Color Space Favorites saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso en la funcion save_colorspaces_to_ini
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Color Space Favorites. Check console for details.&quot;,
                )

        except Exception as e:
            # Captura por si save_colorspaces_to_ini lanza una excepcion inesperada
            print(f&quot;Error inesperado al llamar a save_colorspaces_to_ini: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Color Space Favorites:\n{e}&quot;,
            )

    def save_render_mail_settings(self):
        &quot;&quot;&quot;Guarda los datos de mail de Render Complete en su archivo .ini.&quot;&quot;&quot;
        config_file_path = rc_get_config_path()
        if not config_file_path:
            print(
                &quot;Error: No se pudo obtener la ruta para guardar Render Complete Mail.&quot;
            )
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Render Complete Mail.&quot;,
            )
            return
        from_email = self.render_mail_from_input.text().strip()
        from_password = self.render_mail_pass_input.text()
        to_email = self.render_mail_to_input.text().strip()
        if not from_email or not from_password or not to_email:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;All mail fields must be filled (From, Password, To).&quot;,
            )
            # No revertimos, dejamos que el usuario corrija
            return
        try:
            # La funcion rc_save_mail_settings_to_config ahora maneja la codificacion interna
            success = rc_save_mail_settings_to_config(
                from_email, from_password, to_email
            )
            if success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(
                    self, &quot;Success&quot;, &quot;Render Complete Mail settings saved.&quot;
                )
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Render Complete Mail settings. Check console for details.&quot;,
                )
        except Exception as e:
            print(f&quot;Error al llamar a save_mail_settings_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Render Complete Mail settings:\n{e}&quot;,
            )

    def browse_wav_file(self):
        &quot;&quot;&quot;Abre un diálogo para seleccionar un archivo .wav y lo pone en el QLineEdit.&quot;&quot;&quot;
        file_path, _ = QFileDialog.getOpenFileName(
            self, &quot;Select WAV file&quot;, &quot;&quot;, &quot;WAV Files (*.wav)&quot;
        )
        if file_path:
            self.wav_path_input.setText(file_path)


# --- Main Execution ---
if __name__ == &quot;__main__&quot;:
    # Necesario para ejecucion standalone fuera de Nuke
    app = QApplication.instance() or QApplication(sys.argv)

    settings_window = SettingsWindow()
    settings_window.show()

    # Mantener el bucle para ejecucion standalone
    if not QApplication.instance():  # Solo si no estamos en Nuke
        sys.exit(app.exec_())
    # Si estamos en Nuke, no llamamos a sys.exit()
&quot;&quot;&quot;
_____________________________________________________________________________________________________

  LGA_ToolPack_settings v0.4 | Lega
  Configuracion de la herramienta LGA_ToolPack
_____________________________________________________________________________________________________
&quot;&quot;&quot;

import sys
import os
import configparser
import typing  # Importar typing
from typing import Optional, Tuple

from PySide2.QtWidgets import (
    QApplication,
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QGroupBox,
    QLabel,
    QLineEdit,
    QFormLayout,
    QPushButton,
    QTextEdit,  # Importar QTextEdit
    QMessageBox,  # Importar QMessageBox
    QCheckBox,
    QFileDialog,
)
from PySide2.QtCore import Qt

# Importar funciones y constantes desde LGA_Write_Focus
# Asumiendo que ambos scripts estan en el mismo directorio o en el sys.path
try:
    from LGA_Write_Focus import (
        get_config_path as wf_get_config_path,  # Renombrar para claridad
        ensure_config_exists as wf_ensure_config_exists,
        get_node_name_from_config as wf_get_node_name_from_config,
        DEFAULT_NODE_NAME as WF_DEFAULT_NODE_NAME,  # Renombrar constante
        CONFIG_SECTION as WF_CONFIG_SECTION,  # Renombrar constante
        CONFIG_NODE_NAME_KEY as WF_CONFIG_NODE_NAME_KEY,  # Renombrar constante
    )
except ImportError as e_wf:
    print(f&quot;Error al importar LGA_Write_Focus.py: {e_wf}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def wf_ensure_config_exists():
        pass

    def wf_get_node_name_from_config() -&gt; str:
        return &quot;Write_Pub&quot;

    def wf_get_config_path() -&gt; typing.Optional[str]:
        return None

    WF_DEFAULT_NODE_NAME = &quot;Write_Pub&quot;
    WF_CONFIG_SECTION = &quot;Settings&quot;
    WF_CONFIG_NODE_NAME_KEY = &quot;node_name&quot;

# --- Importaciones de LGA_showInlFlow ---
try:
    from LGA_showInlFlow import (
        get_config_path as sif_get_config_path,
        ensure_config_exists as sif_ensure_config_exists,
        get_credentials_from_config as sif_get_credentials_from_config,
        save_credentials_to_config as sif_save_credentials_to_config,
    )
except ImportError as e_sif:
    print(f&quot;Error al importar LGA_showInlFlow.py: {e_sif}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def sif_ensure_config_exists():
        pass

    def sif_get_credentials_from_config() -&gt; (
        typing.Tuple[typing.Optional[str], typing.Optional[str], typing.Optional[str]]
    ):
        return None, None, None

    def sif_get_config_path() -&gt; typing.Optional[str]:
        return None

    # Funcion save dummy
    def sif_save_credentials_to_config(url, login, password) -&gt; bool:
        print(
            &quot;Error: LGA_showInlFlow.py no encontrado, no se pueden guardar credenciales.&quot;
        )
        return False


# --- Importaciones de LGA_RnW_ColorSpace_Favs --- Nuevo
try:
    from LGA_RnW_ColorSpace_Favs import (
        get_colorspace_ini_path,
        read_colorspaces_from_ini,
        save_colorspaces_to_ini,
        COLORSPACE_SECTION,  # Importar tambien la constante de seccion
    )
except ImportError as e_csf:
    print(
        f&quot;Error al importar LGA_RnW_ColorSpace_Favs.py: {e_csf}. Funcionalidad limitada.&quot;
    )

    # Definir funciones dummy
    def get_colorspace_ini_path(create_if_missing: bool = True) -&gt; typing.Optional[str]:
        return None

    def read_colorspaces_from_ini(ini_path: typing.Optional[str]) -&gt; typing.List[str]:
        return []

    def save_colorspaces_to_ini(
        ini_path: typing.Optional[str], colorspaces_list: typing.List[str]
    ) -&gt; bool:
        return False

    COLORSPACE_SECTION = &quot;ColorSpaces&quot;

# --- Importaciones de LGA_Render_Complete --- NUEVO
try:
    from LGA_Render_Complete import (
        get_config_path as rc_get_config_path,
        ensure_config_exists as rc_ensure_config_exists,
        get_mail_settings_from_config as rc_get_mail_settings_from_config,
        save_mail_settings_to_config as rc_save_mail_settings_to_config,
        CONFIG_FROM_KEY as RC_CONFIG_FROM_KEY,
        CONFIG_PASS_KEY as RC_CONFIG_PASS_KEY,
        CONFIG_TO_KEY as RC_CONFIG_TO_KEY,
    )
except ImportError as e_rc:
    print(f&quot;Error al importar LGA_Render_Complete.py: {e_rc}. Funcionalidad limitada.&quot;)

    def rc_ensure_config_exists() -&gt; None:
        pass

    def rc_get_mail_settings_from_config() -&gt; (
        Tuple[Optional[str], Optional[str], Optional[str]]
    ):
        return None, None, None

    def rc_save_mail_settings_to_config(from_email, from_password, to_email) -&gt; bool:
        return False

    def rc_get_config_path() -&gt; Optional[str]:
        return None

    RC_CONFIG_FROM_KEY = &quot;from_email&quot;
    RC_CONFIG_PASS_KEY = &quot;from_password&quot;
    RC_CONFIG_TO_KEY = &quot;to_email&quot;


class SettingsWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(&quot;LGA ToolPack Settings&quot;)
        self.setMinimumWidth(450)  # Un poco mas ancho para el QTextEdit
        self.initUI()

    def initUI(self):
        main_layout = QVBoxLayout(self)

        # --- Write Presets Section (Placeholder) ---
        write_presets_group = QGroupBox(&quot;Write Presets&quot;)
        write_presets_layout = QVBoxLayout()
        write_presets_layout.addWidget(
            QLabel(&quot;(Placeholder for Write Presets functionality)&quot;)
        )
        self.save_write_presets_button = QPushButton(&quot;Save&quot;)
        # self.save_write_presets_button.clicked.connect(self.save_write_presets) # Placeholder
        write_presets_layout.addWidget(self.save_write_presets_button, 0, Qt.AlignRight)
        write_presets_group.setLayout(write_presets_layout)
        main_layout.addWidget(write_presets_group)

        # --- Write Focus Section ---
        write_focus_group = QGroupBox(&quot;Write Focus&quot;)
        write_focus_layout_container = QVBoxLayout()
        write_focus_form_layout = QFormLayout()
        self.write_focus_input = QLineEdit()
        try:
            wf_ensure_config_exists()  # Usar funcion importada
            current_node_name = wf_get_node_name_from_config()  # Usar funcion importada
            self.write_focus_input.setText(current_node_name or WF_DEFAULT_NODE_NAME)
        except Exception as e:
            print(f&quot;Error al cargar config de Write Focus: {e}&quot;)
            self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)

        write_focus_form_layout.addRow(
            &quot;Name of the Write Node to Focus:&quot;, self.write_focus_input
        )
        write_focus_layout_container.addLayout(write_focus_form_layout)
        self.save_write_focus_button = QPushButton(&quot;Save&quot;)
        self.save_write_focus_button.clicked.connect(self.save_write_focus_settings)
        write_focus_layout_container.addWidget(
            self.save_write_focus_button, 0, Qt.AlignRight
        )
        write_focus_group.setLayout(write_focus_layout_container)
        main_layout.addWidget(write_focus_group)

        # --- Show in Flow Section ---
        show_flow_group = QGroupBox(&quot;Show in Flow&quot;)
        show_flow_layout_container = QVBoxLayout()
        show_flow_form_layout = QFormLayout()
        self.username_input = QLineEdit()
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.Password)
        self.site_input = QLineEdit()
        # Placeholders para los campos de ShotGrid
        self.site_input.setPlaceholderText(&quot;e.g., https://studio.shotgrid.autodesk.com&quot;)
        self.username_input.setPlaceholderText(&quot;e.g., artist@studio.com&quot;)
        self.password_input.setPlaceholderText(&quot;&quot;)
        show_flow_form_layout.addRow(
            &quot;ShotGrid URL:&quot;,
            self.site_input,
        )
        show_flow_form_layout.addRow(&quot;ShotGrid Login:&quot;, self.username_input)
        show_flow_form_layout.addRow(&quot;ShotGrid Password:&quot;, self.password_input)

        try:
            sif_ensure_config_exists()  # Usar funcion importada
            sif_url, sif_login, sif_password = (
                sif_get_credentials_from_config()
            )  # Usar funcion importada
            self.site_input.setText(sif_url or &quot;&quot;)
            self.username_input.setText(sif_login or &quot;&quot;)
            self.password_input.setText(sif_password or &quot;&quot;)
        except Exception as e:
            print(f&quot;Error al cargar credenciales de Show in Flow: {e}&quot;)

        show_flow_layout_container.addLayout(show_flow_form_layout)
        self.save_show_flow_button = QPushButton(&quot;Save&quot;)
        self.save_show_flow_button.clicked.connect(self.save_show_flow_settings)
        show_flow_layout_container.addWidget(
            self.save_show_flow_button, 0, Qt.AlignRight
        )
        show_flow_group.setLayout(show_flow_layout_container)
        main_layout.addWidget(show_flow_group)

        # --- Color Space Favs Section --- Modificado
        color_space_group = QGroupBox(&quot;Color Space Favorites&quot;)  # Titulo mas descriptivo
        color_space_layout = QVBoxLayout()
        color_space_layout.addWidget(
            QLabel(
                &quot;Enter favorite OCIO color spaces (one per line):&quot;
            )  # Label explicativo
        )
        # Crear el QTextEdit
        self.color_space_edit = QTextEdit()
        self.color_space_edit.setPlaceholderText(
            &quot;e.g.,\nOutput - sRGB\nUtility - Raw\nACES - ACEScg&quot;
        )
        self.color_space_edit.setMinimumHeight(80)  # Altura minima
        color_space_layout.addWidget(self.color_space_edit)

        # --- Cargar favoritos existentes --- Nuevo
        try:
            self.colorspace_ini_path = get_colorspace_ini_path(create_if_missing=True)
            if self.colorspace_ini_path:
                fav_list = read_colorspaces_from_ini(self.colorspace_ini_path)
                self.color_space_edit.setText(&quot;\n&quot;.join(fav_list))
            else:
                print(&quot;Advertencia: No se pudo obtener la ruta del INI de ColorSpaces.&quot;)
                # Podriamos deshabilitar el campo/boton si no hay ruta
                # self.color_space_edit.setEnabled(False)
        except Exception as e:
            print(f&quot;Error al cargar Color Space Favs: {e}&quot;)
            QMessageBox.warning(
                self, &quot;Error&quot;, f&quot;Could not load Color Space Favorites:\n{e}&quot;
            )
        # ---------------------------------

        self.save_color_space_button = QPushButton(&quot;Save&quot;)
        self.save_color_space_button.clicked.connect(
            self.save_color_space_settings
        )  # Conectar al nuevo metodo
        color_space_layout.addWidget(self.save_color_space_button, 0, Qt.AlignRight)
        color_space_group.setLayout(color_space_layout)
        main_layout.addWidget(color_space_group)

        # --- Render Complete Mail Settings Section --- NUEVO
        render_mail_group = QGroupBox(&quot;Render Complete Mail Settings&quot;)
        render_mail_layout_container = QVBoxLayout()
        render_mail_form_layout = QFormLayout()
        self.render_mail_from_input = QLineEdit()
        self.render_mail_pass_input = QLineEdit()
        self.render_mail_pass_input.setEchoMode(QLineEdit.Password)
        self.render_mail_to_input = QLineEdit()
        # Placeholders para los campos de mail
        self.render_mail_from_input.setPlaceholderText(&quot;e.g., tuMail@outlook.com&quot;)
        self.render_mail_pass_input.setPlaceholderText(&quot;&quot;)
        self.render_mail_to_input.setPlaceholderText(&quot;e.g., tuMail@gmail.com&quot;)
        # Cargar valores actuales
        try:
            rc_ensure_config_exists()
            from_email, from_password, to_email = rc_get_mail_settings_from_config()
            self.render_mail_from_input.setText(from_email or &quot;&quot;)
            self.render_mail_pass_input.setText(from_password or &quot;&quot;)
            self.render_mail_to_input.setText(to_email or &quot;&quot;)
        except Exception as e:
            print(f&quot;Error al cargar config de Render Complete Mail: {e}&quot;)
        render_mail_form_layout.addRow(&quot;From (Outlook):&quot;, self.render_mail_from_input)
        render_mail_form_layout.addRow(&quot;Password:&quot;, self.render_mail_pass_input)
        render_mail_form_layout.addRow(&quot;To (Recipient):&quot;, self.render_mail_to_input)
        render_mail_layout_container.addLayout(render_mail_form_layout)
        # --- NUEVOS SETTINGS ---
        self.cb_enable_mail = QCheckBox(&quot;Enable mail sending&quot;)
        self.cb_enable_render_time = QCheckBox(&quot;Enable render time calculation&quot;)
        self.cb_enable_sound = QCheckBox(&quot;Enable sound notification&quot;)
        render_mail_layout_container.addWidget(self.cb_enable_mail)
        render_mail_layout_container.addWidget(self.cb_enable_render_time)
        render_mail_layout_container.addWidget(self.cb_enable_sound)
        # Selector de archivo .wav
        wav_layout = QHBoxLayout()
        self.wav_path_input = QLineEdit()
        self.wav_path_input.setPlaceholderText(&quot;Select .wav file...&quot;)
        self.wav_browse_btn = QPushButton(&quot;Browse&quot;)
        self.wav_browse_btn.clicked.connect(self.browse_wav_file)
        wav_layout.addWidget(self.wav_path_input)
        wav_layout.addWidget(self.wav_browse_btn)
        render_mail_layout_container.addLayout(wav_layout)
        # ---

        self.save_render_mail_button = QPushButton(&quot;Save&quot;)
        self.save_render_mail_button.clicked.connect(self.save_render_mail_settings)
        render_mail_layout_container.addWidget(
            self.save_render_mail_button, 0, Qt.AlignRight
        )
        render_mail_group.setLayout(render_mail_layout_container)
        main_layout.addWidget(render_mail_group)
        # ---
        main_layout.addStretch()

    def save_write_focus_settings(self):
        &quot;&quot;&quot;Guarda el nombre del nodo de Write Focus en su archivo .ini.&quot;&quot;&quot;
        config_file_path = wf_get_config_path()
        if not config_file_path:
            print(&quot;Error: No se pudo obtener la ruta para guardar Write Focus.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Write Focus.&quot;,
            )
            return

        new_node_name = self.write_focus_input.text().strip()
        if not new_node_name:
            QMessageBox.warning(
                self, &quot;Input Error&quot;, &quot;Write Focus node name cannot be empty.&quot;
            )
            # Revertir al valor anterior o al por defecto
            try:
                current_node_name = wf_get_node_name_from_config()
                self.write_focus_input.setText(
                    current_node_name or WF_DEFAULT_NODE_NAME
                )
            except Exception:
                self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)
            return

        config = configparser.ConfigParser()
        try:
            # Leer existente para preservar otras secciones/claves
            if os.path.exists(config_file_path):
                config.read(config_file_path)

            if not config.has_section(WF_CONFIG_SECTION):
                config.add_section(WF_CONFIG_SECTION)

            config.set(WF_CONFIG_SECTION, WF_CONFIG_NODE_NAME_KEY, new_node_name)

            with open(config_file_path, &quot;w&quot;) as configfile:
                config.write(configfile)

            print(f&quot;Configuracion de Write Focus guardada: {new_node_name}&quot;)
            QMessageBox.information(self, &quot;Success&quot;, &quot;Write Focus settings saved.&quot;)

        except Exception as e:
            print(f&quot;Error al guardar la configuracion de Write Focus: {e}&quot;)
            QMessageBox.critical(
                self, &quot;Save Error&quot;, f&quot;Could not save Write Focus settings:\n{e}&quot;
            )

    def save_show_flow_settings(self):
        &quot;&quot;&quot;Guarda las credenciales de Show in Flow en su archivo .ini.&quot;&quot;&quot;
        config_file_path = sif_get_config_path()
        if not config_file_path:
            print(&quot;Error: No se pudo obtener la ruta para guardar Show in Flow.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Show in Flow.&quot;,
            )
            return

        new_url = self.site_input.text().strip()
        new_login = self.username_input.text().strip()
        new_password = self.password_input.text()  # No hacer strip a la password

        if not new_url or not new_login or not new_password:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;Show in Flow URL, Login, and Password cannot be empty.&quot;,
            )
            # No revertimos aqui, dejamos que el usuario corrija
            return

        # Llamar a la nueva funcion de guardado que maneja la codificacion
        try:
            success = sif_save_credentials_to_config(new_url, new_login, new_password)
            if success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(self, &quot;Success&quot;, &quot;Show in Flow settings saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Show in Flow settings. Check console for details.&quot;,
                )
        except Exception as e:
            print(f&quot;Error al llamar a save_credentials_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Show in Flow settings:\n{e}&quot;,
            )

    def save_color_space_settings(self):  # Nuevo metodo
        &quot;&quot;&quot;Guarda la lista de Color Space Favorites en su archivo .ini.&quot;&quot;&quot;
        # Re-obtener la ruta por si acaso, pero no forzar creacion/copia aqui
        ini_path = getattr(
            self,
            &quot;colorspace_ini_path&quot;,
            get_colorspace_ini_path(create_if_missing=False),
        )

        if not ini_path:
            print(&quot;Error: No se pudo obtener la ruta para guardar Color Space Favs.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Color Space Favorites.&quot;,
            )
            return

        # Obtener texto del QTextEdit
        text = self.color_space_edit.toPlainText()
        # Dividir en lineas, quitar espacios y filtrar vacias/solo espacios
        favorites_list = [line.strip() for line in text.split(&quot;\n&quot;) if line.strip()]

        # Usar la funcion importada para guardar
        try:
            success = save_colorspaces_to_ini(ini_path, favorites_list)
            if success:
                print(&quot;Configuracion de Color Space Favorites guardada.&quot;)
                QMessageBox.information(self, &quot;Success&quot;, &quot;Color Space Favorites saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso en la funcion save_colorspaces_to_ini
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Color Space Favorites. Check console for details.&quot;,
                )

        except Exception as e:
            # Captura por si save_colorspaces_to_ini lanza una excepcion inesperada
            print(f&quot;Error inesperado al llamar a save_colorspaces_to_ini: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Color Space Favorites:\n{e}&quot;,
            )

    def save_render_mail_settings(self):
        &quot;&quot;&quot;Guarda los datos de mail de Render Complete en su archivo .ini.&quot;&quot;&quot;
        config_file_path = rc_get_config_path()
        if not config_file_path:
            print(
                &quot;Error: No se pudo obtener la ruta para guardar Render Complete Mail.&quot;
            )
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Render Complete Mail.&quot;,
            )
            return
        from_email = self.render_mail_from_input.text().strip()
        from_password = self.render_mail_pass_input.text()
        to_email = self.render_mail_to_input.text().strip()
        if not from_email or not from_password or not to_email:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;All mail fields must be filled (From, Password, To).&quot;,
            )
            # No revertimos, dejamos que el usuario corrija
            return
        try:
            # La funcion rc_save_mail_settings_to_config ahora maneja la codificacion interna
            success = rc_save_mail_settings_to_config(
                from_email, from_password, to_email
            )
            if success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(
                    self, &quot;Success&quot;, &quot;Render Complete Mail settings saved.&quot;
                )
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Render Complete Mail settings. Check console for details.&quot;,
                )
        except Exception as e:
            print(f&quot;Error al llamar a save_mail_settings_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Render Complete Mail settings:\n{e}&quot;,
            )

    def browse_wav_file(self):
        &quot;&quot;&quot;Abre un diálogo para seleccionar un archivo .wav y lo pone en el QLineEdit.&quot;&quot;&quot;
        file_path, _ = QFileDialog.getOpenFileName(
            self, &quot;Select WAV file&quot;, &quot;&quot;, &quot;WAV Files (*.wav)&quot;
        )
        if file_path:
            self.wav_path_input.setText(file_path)


# --- Main Execution ---
if __name__ == &quot;__main__&quot;:
    # Necesario para ejecucion standalone fuera de Nuke
    app = QApplication.instance() or QApplication(sys.argv)

    settings_window = SettingsWindow()
    settings_window.show()

    # Mantener el bucle para ejecucion standalone
    if not QApplication.instance():  # Solo si no estamos en Nuke
        sys.exit(app.exec_())
    # Si estamos en Nuke, no llamamos a sys.exit()
&quot;&quot;&quot;
_____________________________________________________________________________________________________

  LGA_ToolPack_settings v0.4 | Lega
  Configuracion de la herramienta LGA_ToolPack
_____________________________________________________________________________________________________
&quot;&quot;&quot;

import sys
import os
import configparser
import typing  # Importar typing
from typing import Optional, Tuple

from PySide2.QtWidgets import (
    QApplication,
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QGroupBox,
    QLabel,
    QLineEdit,
    QFormLayout,
    QPushButton,
    QTextEdit,  # Importar QTextEdit
    QMessageBox,  # Importar QMessageBox
    QCheckBox,
    QFileDialog,
)
from PySide2.QtCore import Qt

# Importar funciones y constantes desde LGA_Write_Focus
# Asumiendo que ambos scripts estan en el mismo directorio o en el sys.path
try:
    from LGA_Write_Focus import (
        get_config_path as wf_get_config_path,  # Renombrar para claridad
        ensure_config_exists as wf_ensure_config_exists,
        get_node_name_from_config as wf_get_node_name_from_config,
        DEFAULT_NODE_NAME as WF_DEFAULT_NODE_NAME,  # Renombrar constante
        CONFIG_SECTION as WF_CONFIG_SECTION,  # Renombrar constante
        CONFIG_NODE_NAME_KEY as WF_CONFIG_NODE_NAME_KEY,  # Renombrar constante
    )
except ImportError as e_wf:
    print(f&quot;Error al importar LGA_Write_Focus.py: {e_wf}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def wf_ensure_config_exists():
        pass

    def wf_get_node_name_from_config() -&gt; str:
        return &quot;Write_Pub&quot;

    def wf_get_config_path() -&gt; typing.Optional[str]:
        return None

    WF_DEFAULT_NODE_NAME = &quot;Write_Pub&quot;
    WF_CONFIG_SECTION = &quot;Settings&quot;
    WF_CONFIG_NODE_NAME_KEY = &quot;node_name&quot;

# --- Importaciones de LGA_showInlFlow ---
try:
    from LGA_showInlFlow import (
        get_config_path as sif_get_config_path,
        ensure_config_exists as sif_ensure_config_exists,
        get_credentials_from_config as sif_get_credentials_from_config,
        save_credentials_to_config as sif_save_credentials_to_config,
    )
except ImportError as e_sif:
    print(f&quot;Error al importar LGA_showInlFlow.py: {e_sif}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def sif_ensure_config_exists():
        pass

    def sif_get_credentials_from_config() -&gt; (
        typing.Tuple[typing.Optional[str], typing.Optional[str], typing.Optional[str]]
    ):
        return None, None, None

    def sif_get_config_path() -&gt; typing.Optional[str]:
        return None

    # Funcion save dummy
    def sif_save_credentials_to_config(url, login, password) -&gt; bool:
        print(
            &quot;Error: LGA_showInlFlow.py no encontrado, no se pueden guardar credenciales.&quot;
        )
        return False


# --- Importaciones de LGA_RnW_ColorSpace_Favs --- Nuevo
try:
    from LGA_RnW_ColorSpace_Favs import (
        get_colorspace_ini_path,
        read_colorspaces_from_ini,
        save_colorspaces_to_ini,
        COLORSPACE_SECTION,  # Importar tambien la constante de seccion
    )
except ImportError as e_csf:
    print(
        f&quot;Error al importar LGA_RnW_ColorSpace_Favs.py: {e_csf}. Funcionalidad limitada.&quot;
    )

    # Definir funciones dummy
    def get_colorspace_ini_path(create_if_missing: bool = True) -&gt; typing.Optional[str]:
        return None

    def read_colorspaces_from_ini(ini_path: typing.Optional[str]) -&gt; typing.List[str]:
        return []

    def save_colorspaces_to_ini(
        ini_path: typing.Optional[str], colorspaces_list: typing.List[str]
    ) -&gt; bool:
        return False

    COLORSPACE_SECTION = &quot;ColorSpaces&quot;

# --- Importaciones de LGA_Render_Complete --- NUEVO
try:
    from LGA_Render_Complete import (
        get_config_path as rc_get_config_path,
        ensure_config_exists as rc_ensure_config_exists,
        get_mail_settings_from_config as rc_get_mail_settings_from_config,
        save_mail_settings_to_config as rc_save_mail_settings_to_config,
        CONFIG_FROM_KEY as RC_CONFIG_FROM_KEY,
        CONFIG_PASS_KEY as RC_CONFIG_PASS_KEY,
        CONFIG_TO_KEY as RC_CONFIG_TO_KEY,
    )
except ImportError as e_rc:
    print(f&quot;Error al importar LGA_Render_Complete.py: {e_rc}. Funcionalidad limitada.&quot;)

    def rc_ensure_config_exists() -&gt; None:
        pass

    def rc_get_mail_settings_from_config() -&gt; (
        Tuple[Optional[str], Optional[str], Optional[str]]
    ):
        return None, None, None

    def rc_save_mail_settings_to_config(from_email, from_password, to_email) -&gt; bool:
        return False

    def rc_get_config_path() -&gt; Optional[str]:
        return None

    RC_CONFIG_FROM_KEY = &quot;from_email&quot;
    RC_CONFIG_PASS_KEY = &quot;from_password&quot;
    RC_CONFIG_TO_KEY = &quot;to_email&quot;


class SettingsWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(&quot;LGA ToolPack Settings&quot;)
        self.setMinimumWidth(450)  # Un poco mas ancho para el QTextEdit
        self.initUI()

    def initUI(self):
        main_layout = QVBoxLayout(self)

        # --- Write Presets Section (Placeholder) ---
        write_presets_group = QGroupBox(&quot;Write Presets&quot;)
        write_presets_layout = QVBoxLayout()
        write_presets_layout.addWidget(
            QLabel(&quot;(Placeholder for Write Presets functionality)&quot;)
        )
        self.save_write_presets_button = QPushButton(&quot;Save&quot;)
        # self.save_write_presets_button.clicked.connect(self.save_write_presets) # Placeholder
        write_presets_layout.addWidget(self.save_write_presets_button, 0, Qt.AlignRight)
        write_presets_group.setLayout(write_presets_layout)
        main_layout.addWidget(write_presets_group)

        # --- Write Focus Section ---
        write_focus_group = QGroupBox(&quot;Write Focus&quot;)
        write_focus_layout_container = QVBoxLayout()
        write_focus_form_layout = QFormLayout()
        self.write_focus_input = QLineEdit()
        try:
            wf_ensure_config_exists()  # Usar funcion importada
            current_node_name = wf_get_node_name_from_config()  # Usar funcion importada
            self.write_focus_input.setText(current_node_name or WF_DEFAULT_NODE_NAME)
        except Exception as e:
            print(f&quot;Error al cargar config de Write Focus: {e}&quot;)
            self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)

        write_focus_form_layout.addRow(
            &quot;Name of the Write Node to Focus:&quot;, self.write_focus_input
        )
        write_focus_layout_container.addLayout(write_focus_form_layout)
        self.save_write_focus_button = QPushButton(&quot;Save&quot;)
        self.save_write_focus_button.clicked.connect(self.save_write_focus_settings)
        write_focus_layout_container.addWidget(
            self.save_write_focus_button, 0, Qt.AlignRight
        )
        write_focus_group.setLayout(write_focus_layout_container)
        main_layout.addWidget(write_focus_group)

        # --- Show in Flow Section ---
        show_flow_group = QGroupBox(&quot;Show in Flow&quot;)
        show_flow_layout_container = QVBoxLayout()
        show_flow_form_layout = QFormLayout()
        self.username_input = QLineEdit()
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.Password)
        self.site_input = QLineEdit()
        # Placeholders para los campos de ShotGrid
        self.site_input.setPlaceholderText(&quot;e.g., https://studio.shotgrid.autodesk.com&quot;)
        self.username_input.setPlaceholderText(&quot;e.g., artist@studio.com&quot;)
        self.password_input.setPlaceholderText(&quot;&quot;)
        show_flow_form_layout.addRow(
            &quot;ShotGrid URL:&quot;,
            self.site_input,
        )
        show_flow_form_layout.addRow(&quot;ShotGrid Login:&quot;, self.username_input)
        show_flow_form_layout.addRow(&quot;ShotGrid Password:&quot;, self.password_input)

        try:
            sif_ensure_config_exists()  # Usar funcion importada
            sif_url, sif_login, sif_password = (
                sif_get_credentials_from_config()
            )  # Usar funcion importada
            self.site_input.setText(sif_url or &quot;&quot;)
            self.username_input.setText(sif_login or &quot;&quot;)
            self.password_input.setText(sif_password or &quot;&quot;)
        except Exception as e:
            print(f&quot;Error al cargar credenciales de Show in Flow: {e}&quot;)

        show_flow_layout_container.addLayout(show_flow_form_layout)
        self.save_show_flow_button = QPushButton(&quot;Save&quot;)
        self.save_show_flow_button.clicked.connect(self.save_show_flow_settings)
        show_flow_layout_container.addWidget(
            self.save_show_flow_button, 0, Qt.AlignRight
        )
        show_flow_group.setLayout(show_flow_layout_container)
        main_layout.addWidget(show_flow_group)

        # --- Color Space Favs Section --- Modificado
        color_space_group = QGroupBox(&quot;Color Space Favorites&quot;)  # Titulo mas descriptivo
        color_space_layout = QVBoxLayout()
        color_space_layout.addWidget(
            QLabel(
                &quot;Enter favorite OCIO color spaces (one per line):&quot;
            )  # Label explicativo
        )
        # Crear el QTextEdit
        self.color_space_edit = QTextEdit()
        self.color_space_edit.setPlaceholderText(
            &quot;e.g.,\nOutput - sRGB\nUtility - Raw\nACES - ACEScg&quot;
        )
        self.color_space_edit.setMinimumHeight(80)  # Altura minima
        color_space_layout.addWidget(self.color_space_edit)

        # --- Cargar favoritos existentes --- Nuevo
        try:
            self.colorspace_ini_path = get_colorspace_ini_path(create_if_missing=True)
            if self.colorspace_ini_path:
                fav_list = read_colorspaces_from_ini(self.colorspace_ini_path)
                self.color_space_edit.setText(&quot;\n&quot;.join(fav_list))
            else:
                print(&quot;Advertencia: No se pudo obtener la ruta del INI de ColorSpaces.&quot;)
                # Podriamos deshabilitar el campo/boton si no hay ruta
                # self.color_space_edit.setEnabled(False)
        except Exception as e:
            print(f&quot;Error al cargar Color Space Favs: {e}&quot;)
            QMessageBox.warning(
                self, &quot;Error&quot;, f&quot;Could not load Color Space Favorites:\n{e}&quot;
            )
        # ---------------------------------

        self.save_color_space_button = QPushButton(&quot;Save&quot;)
        self.save_color_space_button.clicked.connect(
            self.save_color_space_settings
        )  # Conectar al nuevo metodo
        color_space_layout.addWidget(self.save_color_space_button, 0, Qt.AlignRight)
        color_space_group.setLayout(color_space_layout)
        main_layout.addWidget(color_space_group)

        # --- Render Complete Mail Settings Section --- NUEVO
        render_mail_group = QGroupBox(&quot;Render Complete Mail Settings&quot;)
        render_mail_layout_container = QVBoxLayout()
        render_mail_form_layout = QFormLayout()
        self.render_mail_from_input = QLineEdit()
        self.render_mail_pass_input = QLineEdit()
        self.render_mail_pass_input.setEchoMode(QLineEdit.Password)
        self.render_mail_to_input = QLineEdit()
        # Placeholders para los campos de mail
        self.render_mail_from_input.setPlaceholderText(&quot;e.g., tuMail@outlook.com&quot;)
        self.render_mail_pass_input.setPlaceholderText(&quot;&quot;)
        self.render_mail_to_input.setPlaceholderText(&quot;e.g., tuMail@gmail.com&quot;)
        # Cargar valores actuales
        try:
            rc_ensure_config_exists()
            from_email, from_password, to_email = rc_get_mail_settings_from_config()
            self.render_mail_from_input.setText(from_email or &quot;&quot;)
            self.render_mail_pass_input.setText(from_password or &quot;&quot;)
            self.render_mail_to_input.setText(to_email or &quot;&quot;)
        except Exception as e:
            print(f&quot;Error al cargar config de Render Complete Mail: {e}&quot;)
        render_mail_form_layout.addRow(&quot;From (Outlook):&quot;, self.render_mail_from_input)
        render_mail_form_layout.addRow(&quot;Password:&quot;, self.render_mail_pass_input)
        render_mail_form_layout.addRow(&quot;To (Recipient):&quot;, self.render_mail_to_input)
        render_mail_layout_container.addLayout(render_mail_form_layout)
        # --- NUEVOS SETTINGS ---
        self.cb_enable_mail = QCheckBox(&quot;Enable mail sending&quot;)
        self.cb_enable_render_time = QCheckBox(&quot;Enable render time calculation&quot;)
        self.cb_enable_sound = QCheckBox(&quot;Enable sound notification&quot;)
        render_mail_layout_container.addWidget(self.cb_enable_mail)
        render_mail_layout_container.addWidget(self.cb_enable_render_time)
        render_mail_layout_container.addWidget(self.cb_enable_sound)
        # Selector de archivo .wav
        wav_layout = QHBoxLayout()
        self.wav_path_input = QLineEdit()
        self.wav_path_input.setPlaceholderText(&quot;Select .wav file...&quot;)
        self.wav_browse_btn = QPushButton(&quot;Browse&quot;)
        self.wav_browse_btn.clicked.connect(self.browse_wav_file)
        wav_layout.addWidget(self.wav_path_input)
        wav_layout.addWidget(self.wav_browse_btn)
        render_mail_layout_container.addLayout(wav_layout)
        # ---

        self.save_render_mail_button = QPushButton(&quot;Save&quot;)
        self.save_render_mail_button.clicked.connect(self.save_render_mail_settings)
        render_mail_layout_container.addWidget(
            self.save_render_mail_button, 0, Qt.AlignRight
        )
        render_mail_group.setLayout(render_mail_layout_container)
        main_layout.addWidget(render_mail_group)
        # ---
        main_layout.addStretch()

    def save_write_focus_settings(self):
        &quot;&quot;&quot;Guarda el nombre del nodo de Write Focus en su archivo .ini.&quot;&quot;&quot;
        config_file_path = wf_get_config_path()
        if not config_file_path:
            print(&quot;Error: No se pudo obtener la ruta para guardar Write Focus.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Write Focus.&quot;,
            )
            return

        new_node_name = self.write_focus_input.text().strip()
        if not new_node_name:
            QMessageBox.warning(
                self, &quot;Input Error&quot;, &quot;Write Focus node name cannot be empty.&quot;
            )
            # Revertir al valor anterior o al por defecto
            try:
                current_node_name = wf_get_node_name_from_config()
                self.write_focus_input.setText(
                    current_node_name or WF_DEFAULT_NODE_NAME
                )
            except Exception:
                self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)
            return

        config = configparser.ConfigParser()
        try:
            # Leer existente para preservar otras secciones/claves
            if os.path.exists(config_file_path):
                config.read(config_file_path)

            if not config.has_section(WF_CONFIG_SECTION):
                config.add_section(WF_CONFIG_SECTION)

            config.set(WF_CONFIG_SECTION, WF_CONFIG_NODE_NAME_KEY, new_node_name)

            with open(config_file_path, &quot;w&quot;) as configfile:
                config.write(configfile)

            print(f&quot;Configuracion de Write Focus guardada: {new_node_name}&quot;)
            QMessageBox.information(self, &quot;Success&quot;, &quot;Write Focus settings saved.&quot;)

        except Exception as e:
            print(f&quot;Error al guardar la configuracion de Write Focus: {e}&quot;)
            QMessageBox.critical(
                self, &quot;Save Error&quot;, f&quot;Could not save Write Focus settings:\n{e}&quot;
            )

    def save_show_flow_settings(self):
        &quot;&quot;&quot;Guarda las credenciales de Show in Flow en su archivo .ini.&quot;&quot;&quot;
        config_file_path = sif_get_config_path()
        if not config_file_path:
            print(&quot;Error: No se pudo obtener la ruta para guardar Show in Flow.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Show in Flow.&quot;,
            )
            return

        new_url = self.site_input.text().strip()
        new_login = self.username_input.text().strip()
        new_password = self.password_input.text()  # No hacer strip a la password

        if not new_url or not new_login or not new_password:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;Show in Flow URL, Login, and Password cannot be empty.&quot;,
            )
            # No revertimos aqui, dejamos que el usuario corrija
            return

        # Llamar a la nueva funcion de guardado que maneja la codificacion
        try:
            success = sif_save_credentials_to_config(new_url, new_login, new_password)
            if success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(self, &quot;Success&quot;, &quot;Show in Flow settings saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Show in Flow settings. Check console for details.&quot;,
                )
        except Exception as e:
            print(f&quot;Error al llamar a save_credentials_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Show in Flow settings:\n{e}&quot;,
            )

    def save_color_space_settings(self):  # Nuevo metodo
        &quot;&quot;&quot;Guarda la lista de Color Space Favorites en su archivo .ini.&quot;&quot;&quot;
        # Re-obtener la ruta por si acaso, pero no forzar creacion/copia aqui
        ini_path = getattr(
            self,
            &quot;colorspace_ini_path&quot;,
            get_colorspace_ini_path(create_if_missing=False),
        )

        if not ini_path:
            print(&quot;Error: No se pudo obtener la ruta para guardar Color Space Favs.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Color Space Favorites.&quot;,
            )
            return

        # Obtener texto del QTextEdit
        text = self.color_space_edit.toPlainText()
        # Dividir en lineas, quitar espacios y filtrar vacias/solo espacios
        favorites_list = [line.strip() for line in text.split(&quot;\n&quot;) if line.strip()]

        # Usar la funcion importada para guardar
        try:
            success = save_colorspaces_to_ini(ini_path, favorites_list)
            if success:
                print(&quot;Configuracion de Color Space Favorites guardada.&quot;)
                QMessageBox.information(self, &quot;Success&quot;, &quot;Color Space Favorites saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso en la funcion save_colorspaces_to_ini
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Color Space Favorites. Check console for details.&quot;,
                )

        except Exception as e:
            # Captura por si save_colorspaces_to_ini lanza una excepcion inesperada
            print(f&quot;Error inesperado al llamar a save_colorspaces_to_ini: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Color Space Favorites:\n{e}&quot;,
            )

    def save_render_mail_settings(self):
        &quot;&quot;&quot;Guarda los datos de mail de Render Complete en su archivo .ini.&quot;&quot;&quot;
        config_file_path = rc_get_config_path()
        if not config_file_path:
            print(
                &quot;Error: No se pudo obtener la ruta para guardar Render Complete Mail.&quot;
            )
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Render Complete Mail.&quot;,
            )
            return
        from_email = self.render_mail_from_input.text().strip()
        from_password = self.render_mail_pass_input.text()
        to_email = self.render_mail_to_input.text().strip()
        if not from_email or not from_password or not to_email:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;All mail fields must be filled (From, Password, To).&quot;,
            )
            # No revertimos, dejamos que el usuario corrija
            return
        try:
            # La funcion rc_save_mail_settings_to_config ahora maneja la codificacion interna
            success = rc_save_mail_settings_to_config(
                from_email, from_password, to_email
            )
            if success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(
                    self, &quot;Success&quot;, &quot;Render Complete Mail settings saved.&quot;
                )
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Render Complete Mail settings. Check console for details.&quot;,
                )
        except Exception as e:
            print(f&quot;Error al llamar a save_mail_settings_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Render Complete Mail settings:\n{e}&quot;,
            )

    def browse_wav_file(self):
        &quot;&quot;&quot;Abre un diálogo para seleccionar un archivo .wav y lo pone en el QLineEdit.&quot;&quot;&quot;
        file_path, _ = QFileDialog.getOpenFileName(
            self, &quot;Select WAV file&quot;, &quot;&quot;, &quot;WAV Files (*.wav)&quot;
        )
        if file_path:
            self.wav_path_input.setText(file_path)


# --- Main Execution ---
if __name__ == &quot;__main__&quot;:
    # Necesario para ejecucion standalone fuera de Nuke
    app = QApplication.instance() or QApplication(sys.argv)

    settings_window = SettingsWindow()
    settings_window.show()

    # Mantener el bucle para ejecucion standalone
    if not QApplication.instance():  # Solo si no estamos en Nuke
        sys.exit(app.exec_())
    # Si estamos en Nuke, no llamamos a sys.exit()
&quot;&quot;&quot;
_____________________________________________________________________________________________________

  LGA_ToolPack_settings v0.42 | Lega
  Configuracion de la herramienta LGA_ToolPack
_____________________________________________________________________________________________________
&quot;&quot;&quot;

import sys
import os
import configparser
import typing  # Importar typing
from typing import Optional, Tuple

from PySide2.QtWidgets import (
    QApplication,
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QGroupBox,
    QLabel,
    QLineEdit,
    QFormLayout,
    QPushButton,
    QTextEdit,  # Importar QTextEdit
    QMessageBox,  # Importar QMessageBox
    QCheckBox,
    QFileDialog,
)
from PySide2.QtCore import Qt

# Variable global para controlar el debug
DEBUG = False


# Funcion debug_print
def debug_print(*message):
    if DEBUG:
        print(*message)


# Importar funciones y constantes desde LGA_Write_Focus
# Asumiendo que ambos scripts estan en el mismo directorio o en el sys.path
try:
    from LGA_Write_Focus import (
        get_config_path as wf_get_config_path,  # Renombrar para claridad
        ensure_config_exists as wf_ensure_config_exists,
        get_node_name_from_config as wf_get_node_name_from_config,
        DEFAULT_NODE_NAME as WF_DEFAULT_NODE_NAME,  # Renombrar constante
        CONFIG_SECTION as WF_CONFIG_SECTION,  # Renombrar constante
        CONFIG_NODE_NAME_KEY as WF_CONFIG_NODE_NAME_KEY,  # Renombrar constante
    )
except ImportError as e_wf:
    print(f&quot;Error al importar LGA_Write_Focus.py: {e_wf}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def wf_ensure_config_exists():
        pass

    def wf_get_node_name_from_config() -&gt; str:
        return &quot;Write_Pub&quot;

    def wf_get_config_path() -&gt; typing.Optional[str]:
        return None

    WF_DEFAULT_NODE_NAME = &quot;Write_Pub&quot;
    WF_CONFIG_SECTION = &quot;Settings&quot;
    WF_CONFIG_NODE_NAME_KEY = &quot;node_name&quot;

# --- Importaciones de LGA_showInlFlow ---
try:
    from LGA_showInlFlow import (
        get_config_path as sif_get_config_path,
        ensure_config_exists as sif_ensure_config_exists,
        get_credentials_from_config as sif_get_credentials_from_config,
        save_credentials_to_config as sif_save_credentials_to_config,
    )
except ImportError as e_sif:
    print(f&quot;Error al importar LGA_showInlFlow.py: {e_sif}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def sif_ensure_config_exists():
        pass

    def sif_get_credentials_from_config() -&gt; (
        typing.Tuple[typing.Optional[str], typing.Optional[str], typing.Optional[str]]
    ):
        return None, None, None

    def sif_get_config_path() -&gt; typing.Optional[str]:
        return None

    # Funcion save dummy
    def sif_save_credentials_to_config(url, login, password) -&gt; bool:
        debug_print(
            &quot;Error: LGA_showInlFlow.py no encontrado, no se pueden guardar credenciales.&quot;
        )
        return False


# --- Importaciones de LGA_RnW_ColorSpace_Favs --- Nuevo
try:
    from LGA_RnW_ColorSpace_Favs import (
        get_colorspace_ini_path,
        read_colorspaces_from_ini,
        save_colorspaces_to_ini,
        COLORSPACE_SECTION,  # Importar tambien la constante de seccion
    )
except ImportError as e_csf:
    print(
        f&quot;Error al importar LGA_RnW_ColorSpace_Favs.py: {e_csf}. Funcionalidad limitada.&quot;
    )

    # Definir funciones dummy
    def get_colorspace_ini_path(create_if_missing: bool = True) -&gt; typing.Optional[str]:
        return None

    def read_colorspaces_from_ini(ini_path: typing.Optional[str]) -&gt; typing.List[str]:
        return []

    def save_colorspaces_to_ini(
        ini_path: typing.Optional[str], colorspaces_list: typing.List[str]
    ) -&gt; bool:
        return False

    COLORSPACE_SECTION = &quot;ColorSpaces&quot;

# --- Importaciones de LGA_Render_Complete --- NUEVO
try:
    from LGA_Render_Complete import (
        get_config_path as rc_get_config_path,
        ensure_config_exists as rc_ensure_config_exists,
        get_mail_settings_from_config as rc_get_mail_settings_from_config,
        save_mail_settings_to_config as rc_save_mail_settings_to_config,
        CONFIG_FROM_KEY as RC_CONFIG_FROM_KEY,
        CONFIG_PASS_KEY as RC_CONFIG_PASS_KEY,
        CONFIG_TO_KEY as RC_CONFIG_TO_KEY,
        get_wav_path_from_config,
        save_wav_path_to_config,
        get_sound_enabled_from_config,
        save_sound_enabled_to_config,
    )
except ImportError as e_rc:
    print(f&quot;Error al importar LGA_Render_Complete.py: {e_rc}. Funcionalidad limitada.&quot;)

    def rc_ensure_config_exists() -&gt; None:
        pass

    def rc_get_mail_settings_from_config() -&gt; (
        Tuple[Optional[str], Optional[str], Optional[str]]
    ):
        return None, None, None

    def rc_save_mail_settings_to_config(from_email, from_password, to_email) -&gt; bool:
        debug_print(
            &quot;Error: LGA_Render_Complete.py no encontrado, no se pueden guardar settings de mail.&quot;
        )
        return False

    def rc_get_config_path() -&gt; Optional[str]:
        return None

    RC_CONFIG_FROM_KEY = &quot;from_email&quot;
    RC_CONFIG_PASS_KEY = &quot;from_password&quot;
    RC_CONFIG_TO_KEY = &quot;to_email&quot;


class SettingsWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(&quot;LGA ToolPack Settings&quot;)
        self.setMinimumWidth(450)  # Un poco mas ancho para el QTextEdit
        self.initUI()

    def initUI(self):
        main_layout = QVBoxLayout(self)

        # --- Write Presets Section (Placeholder) ---
        write_presets_group = QGroupBox(&quot;Write Presets&quot;)
        write_presets_layout = QVBoxLayout()
        write_presets_layout.addWidget(
            QLabel(&quot;(Placeholder for Write Presets functionality)&quot;)
        )
        self.save_write_presets_button = QPushButton(&quot;Save&quot;)
        # self.save_write_presets_button.clicked.connect(self.save_write_presets) # Placeholder
        write_presets_layout.addWidget(self.save_write_presets_button, 0, Qt.AlignRight)
        write_presets_group.setLayout(write_presets_layout)
        main_layout.addWidget(write_presets_group)

        # --- Write Focus Section ---
        write_focus_group = QGroupBox(&quot;Write Focus&quot;)
        write_focus_layout_container = QVBoxLayout()
        write_focus_form_layout = QFormLayout()
        self.write_focus_input = QLineEdit()
        try:
            wf_ensure_config_exists()  # Usar funcion importada
            current_node_name = wf_get_node_name_from_config()  # Usar funcion importada
            self.write_focus_input.setText(current_node_name or WF_DEFAULT_NODE_NAME)
        except Exception as e:
            debug_print(f&quot;Error al cargar config de Write Focus: {e}&quot;)
            self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)

        write_focus_form_layout.addRow(
            &quot;Name of the Write Node to Focus:&quot;, self.write_focus_input
        )
        write_focus_layout_container.addLayout(write_focus_form_layout)
        self.save_write_focus_button = QPushButton(&quot;Save&quot;)
        self.save_write_focus_button.clicked.connect(self.save_write_focus_settings)
        write_focus_layout_container.addWidget(
            self.save_write_focus_button, 0, Qt.AlignRight
        )
        write_focus_group.setLayout(write_focus_layout_container)
        main_layout.addWidget(write_focus_group)

        # --- Show in Flow Section ---
        show_flow_group = QGroupBox(&quot;Show in Flow&quot;)
        show_flow_layout_container = QVBoxLayout()
        show_flow_form_layout = QFormLayout()
        self.username_input = QLineEdit()
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.Password)
        self.site_input = QLineEdit()
        # Placeholders para los campos de ShotGrid
        self.site_input.setPlaceholderText(&quot;e.g., https://studio.shotgrid.autodesk.com&quot;)
        self.username_input.setPlaceholderText(&quot;e.g., artist@studio.com&quot;)
        self.password_input.setPlaceholderText(&quot;&quot;)
        show_flow_form_layout.addRow(
            &quot;ShotGrid URL:&quot;,
            self.site_input,
        )
        show_flow_form_layout.addRow(&quot;ShotGrid Login:&quot;, self.username_input)
        show_flow_form_layout.addRow(&quot;ShotGrid Password:&quot;, self.password_input)

        try:
            sif_ensure_config_exists()  # Usar funcion importada
            sif_url, sif_login, sif_password = (
                sif_get_credentials_from_config()
            )  # Usar funcion importada
            self.site_input.setText(sif_url or &quot;&quot;)
            self.username_input.setText(sif_login or &quot;&quot;)
            self.password_input.setText(sif_password or &quot;&quot;)
        except Exception as e:
            debug_print(f&quot;Error al cargar credenciales de Show in Flow: {e}&quot;)

        show_flow_layout_container.addLayout(show_flow_form_layout)
        self.save_show_flow_button = QPushButton(&quot;Save&quot;)
        self.save_show_flow_button.clicked.connect(self.save_show_flow_settings)
        show_flow_layout_container.addWidget(
            self.save_show_flow_button, 0, Qt.AlignRight
        )
        show_flow_group.setLayout(show_flow_layout_container)
        main_layout.addWidget(show_flow_group)

        # --- Color Space Favs Section --- Modificado
        color_space_group = QGroupBox(&quot;Color Space Favorites&quot;)  # Titulo mas descriptivo
        color_space_layout = QVBoxLayout()
        color_space_layout.addWidget(
            QLabel(
                &quot;Enter favorite OCIO color spaces (one per line):&quot;
            )  # Label explicativo
        )
        # Crear el QTextEdit
        self.color_space_edit = QTextEdit()
        self.color_space_edit.setPlaceholderText(
            &quot;e.g.,\nOutput - sRGB\nUtility - Raw\nACES - ACEScg&quot;
        )
        self.color_space_edit.setMinimumHeight(80)  # Altura minima
        color_space_layout.addWidget(self.color_space_edit)

        # --- Cargar favoritos existentes --- Nuevo
        try:
            self.colorspace_ini_path = get_colorspace_ini_path(create_if_missing=True)
            if self.colorspace_ini_path:
                fav_list = read_colorspaces_from_ini(self.colorspace_ini_path)
                self.color_space_edit.setText(&quot;\n&quot;.join(fav_list))
            else:
                debug_print(
                    &quot;Advertencia: No se pudo obtener la ruta del INI de ColorSpaces.&quot;
                )
                # Podriamos deshabilitar el campo/boton si no hay ruta
                # self.color_space_edit.setEnabled(False)
        except Exception as e:
            debug_print(f&quot;Error al cargar Color Space Favs: {e}&quot;)
            QMessageBox.warning(
                self, &quot;Error&quot;, f&quot;Could not load Color Space Favorites:\n{e}&quot;
            )
        # ---------------------------------

        self.save_color_space_button = QPushButton(&quot;Save&quot;)
        self.save_color_space_button.clicked.connect(
            self.save_color_space_settings
        )  # Conectar al nuevo metodo
        color_space_layout.addWidget(self.save_color_space_button, 0, Qt.AlignRight)
        color_space_group.setLayout(color_space_layout)
        main_layout.addWidget(color_space_group)

        # --- Render Complete Mail Settings Section --- NUEVO
        render_mail_group = QGroupBox(&quot;Render Complete Mail Settings&quot;)
        render_mail_layout_container = QVBoxLayout()
        render_mail_form_layout = QFormLayout()
        self.render_mail_from_input = QLineEdit()
        self.render_mail_pass_input = QLineEdit()
        self.render_mail_pass_input.setEchoMode(QLineEdit.Password)
        self.render_mail_to_input = QLineEdit()
        # Placeholders para los campos de mail
        self.render_mail_from_input.setPlaceholderText(&quot;e.g., tuMail@outlook.com&quot;)
        self.render_mail_pass_input.setPlaceholderText(&quot;&quot;)
        self.render_mail_to_input.setPlaceholderText(&quot;e.g., tuMail@gmail.com&quot;)
        # Cargar valores actuales
        try:
            rc_ensure_config_exists()
            from_email, from_password, to_email = rc_get_mail_settings_from_config()
            self.render_mail_from_input.setText(from_email or &quot;&quot;)
            self.render_mail_pass_input.setText(from_password or &quot;&quot;)
            self.render_mail_to_input.setText(to_email or &quot;&quot;)
        except Exception as e:
            debug_print(f&quot;Error al cargar config de Render Complete Mail: {e}&quot;)
        render_mail_form_layout.addRow(&quot;From (Outlook):&quot;, self.render_mail_from_input)
        render_mail_form_layout.addRow(&quot;Password:&quot;, self.render_mail_pass_input)
        render_mail_form_layout.addRow(&quot;To (Recipient):&quot;, self.render_mail_to_input)
        render_mail_layout_container.addLayout(render_mail_form_layout)
        # --- NUEVOS SETTINGS ---
        self.cb_enable_mail = QCheckBox(&quot;Enable mail sending&quot;)
        self.cb_enable_render_time = QCheckBox(&quot;Enable render time calculation&quot;)
        self.cb_enable_sound = QCheckBox(&quot;Enable sound notification&quot;)
        # Inicializar el checkbox segun el setting guardado (ON por defecto)
        try:
            self.cb_enable_sound.setChecked(get_sound_enabled_from_config())
        except Exception as e:
            debug_print(f&quot;Error al leer setting de sonido: {e}&quot;)
            self.cb_enable_sound.setChecked(True)
        render_mail_layout_container.addWidget(self.cb_enable_mail)
        render_mail_layout_container.addWidget(self.cb_enable_render_time)
        render_mail_layout_container.addWidget(self.cb_enable_sound)
        # Selector de archivo .wav
        wav_layout = QHBoxLayout()
        self.wav_path_input = QLineEdit()
        self.wav_path_input.setPlaceholderText(&quot;Select .wav file...&quot;)
        # Inicializar con el valor guardado o el default
        try:
            wav_path = get_wav_path_from_config()
            self.wav_path_input.setText(wav_path)
        except Exception as e:
            debug_print(f&quot;Error al cargar ruta wav: {e}&quot;)
            self.wav_path_input.setText(&quot;&quot;)
        self.wav_browse_btn = QPushButton(&quot;Browse&quot;)
        self.wav_browse_btn.clicked.connect(self.browse_wav_file)
        wav_layout.addWidget(self.wav_path_input)
        wav_layout.addWidget(self.wav_browse_btn)
        render_mail_layout_container.addLayout(wav_layout)
        # ---

        self.save_render_mail_button = QPushButton(&quot;Save&quot;)
        self.save_render_mail_button.clicked.connect(self.save_render_mail_settings)
        render_mail_layout_container.addWidget(
            self.save_render_mail_button, 0, Qt.AlignRight
        )
        render_mail_group.setLayout(render_mail_layout_container)
        main_layout.addWidget(render_mail_group)
        # ---
        main_layout.addStretch()

    def save_write_focus_settings(self):
        &quot;&quot;&quot;Guarda el nombre del nodo de Write Focus en su archivo .ini.&quot;&quot;&quot;
        config_file_path = wf_get_config_path()
        if not config_file_path:
            debug_print(&quot;Error: No se pudo obtener la ruta para guardar Write Focus.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Write Focus.&quot;,
            )
            return

        new_node_name = self.write_focus_input.text().strip()
        if not new_node_name:
            QMessageBox.warning(
                self, &quot;Input Error&quot;, &quot;Write Focus node name cannot be empty.&quot;
            )
            # Revertir al valor anterior o al por defecto
            try:
                current_node_name = wf_get_node_name_from_config()
                self.write_focus_input.setText(
                    current_node_name or WF_DEFAULT_NODE_NAME
                )
            except Exception:
                self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)
            return

        config = configparser.ConfigParser()
        try:
            # Leer existente para preservar otras secciones/claves
            if os.path.exists(config_file_path):
                config.read(config_file_path)

            if not config.has_section(WF_CONFIG_SECTION):
                config.add_section(WF_CONFIG_SECTION)

            config.set(WF_CONFIG_SECTION, WF_CONFIG_NODE_NAME_KEY, new_node_name)

            with open(config_file_path, &quot;w&quot;) as configfile:
                config.write(configfile)

            debug_print(f&quot;Configuracion de Write Focus guardada: {new_node_name}&quot;)
            QMessageBox.information(self, &quot;Success&quot;, &quot;Write Focus settings saved.&quot;)

        except Exception as e:
            debug_print(f&quot;Error al guardar la configuracion de Write Focus: {e}&quot;)
            QMessageBox.critical(
                self, &quot;Save Error&quot;, f&quot;Could not save Write Focus settings:\n{e}&quot;
            )

    def save_show_flow_settings(self):
        &quot;&quot;&quot;Guarda las credenciales de Show in Flow en su archivo .ini.&quot;&quot;&quot;
        config_file_path = sif_get_config_path()
        if not config_file_path:
            debug_print(&quot;Error: No se pudo obtener la ruta para guardar Show in Flow.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Show in Flow.&quot;,
            )
            return

        new_url = self.site_input.text().strip()
        new_login = self.username_input.text().strip()
        new_password = self.password_input.text()  # No hacer strip a la password

        if not new_url or not new_login or not new_password:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;Show in Flow URL, Login, and Password cannot be empty.&quot;,
            )
            # No revertimos aqui, dejamos que el usuario corrija
            return

        # Llamar a la nueva funcion de guardado que maneja la codificacion
        try:
            success = sif_save_credentials_to_config(new_url, new_login, new_password)
            if success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(self, &quot;Success&quot;, &quot;Show in Flow settings saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Show in Flow settings. Check console for details.&quot;,
                )
        except Exception as e:
            debug_print(f&quot;Error al llamar a save_credentials_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Show in Flow settings:\n{e}&quot;,
            )

    def save_color_space_settings(self):  # Nuevo metodo
        &quot;&quot;&quot;Guarda la lista de Color Space Favorites en su archivo .ini.&quot;&quot;&quot;
        # Re-obtener la ruta por si acaso, pero no forzar creacion/copia aqui
        ini_path = getattr(
            self,
            &quot;colorspace_ini_path&quot;,
            get_colorspace_ini_path(create_if_missing=False),
        )

        if not ini_path:
            debug_print(
                &quot;Error: No se pudo obtener la ruta para guardar Color Space Favs.&quot;
            )
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Color Space Favorites.&quot;,
            )
            return

        # Obtener texto del QTextEdit
        text = self.color_space_edit.toPlainText()
        # Dividir en lineas, quitar espacios y filtrar vacias/solo espacios
        favorites_list = [line.strip() for line in text.split(&quot;\n&quot;) if line.strip()]

        # Usar la funcion importada para guardar
        try:
            success = save_colorspaces_to_ini(ini_path, favorites_list)
            if success:
                debug_print(&quot;Configuracion de Color Space Favorites guardada.&quot;)
                QMessageBox.information(self, &quot;Success&quot;, &quot;Color Space Favorites saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso en la funcion save_colorspaces_to_ini
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Color Space Favorites. Check console for details.&quot;,
                )

        except Exception as e:
            # Captura por si save_colorspaces_to_ini lanza una excepcion inesperada
            debug_print(f&quot;Error inesperado al llamar a save_colorspaces_to_ini: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Color Space Favorites:\n{e}&quot;,
            )

    def save_render_mail_settings(self):
        &quot;&quot;&quot;Guarda los datos de mail de Render Complete en su archivo .ini.&quot;&quot;&quot;
        config_file_path = rc_get_config_path()
        if not config_file_path:
            debug_print(
                &quot;Error: No se pudo obtener la ruta para guardar Render Complete Mail.&quot;
            )
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Render Complete Mail.&quot;,
            )
            return
        from_email = self.render_mail_from_input.text().strip()
        from_password = self.render_mail_pass_input.text()
        to_email = self.render_mail_to_input.text().strip()
        wav_path = self.wav_path_input.text().strip()
        sound_enabled = self.cb_enable_sound.isChecked()
        if not from_email or not from_password or not to_email:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;All mail fields must be filled (From, Password, To).&quot;,
            )
            # No revertimos, dejamos que el usuario corrija
            return
        try:
            # La funcion rc_save_mail_settings_to_config ahora maneja la codificacion interna
            success = rc_save_mail_settings_to_config(
                from_email, from_password, to_email
            )
            # Guardar el path del wav
            wav_success = save_wav_path_to_config(wav_path)
            # Guardar el setting de sonido
            sound_success = save_sound_enabled_to_config(sound_enabled)
            if success and wav_success and sound_success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(
                    self, &quot;Success&quot;, &quot;Render Complete Mail settings saved.&quot;
                )
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Render Complete Mail settings. Check console for details.&quot;,
                )
        except Exception as e:
            debug_print(f&quot;Error al llamar a save_mail_settings_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Render Complete Mail settings:\n{e}&quot;,
            )

    def browse_wav_file(self):
        &quot;&quot;&quot;Abre un diálogo para seleccionar un archivo .wav y lo pone en el QLineEdit.&quot;&quot;&quot;
        file_path, _ = QFileDialog.getOpenFileName(
            self, &quot;Select WAV file&quot;, &quot;&quot;, &quot;WAV Files (*.wav)&quot;
        )
        if file_path:
            self.wav_path_input.setText(file_path)
            # Guardar inmediatamente el nuevo path seleccionado
            save_wav_path_to_config(file_path)


# --- Main Execution ---
if __name__ == &quot;__main__&quot;:
    # Necesario para ejecucion standalone fuera de Nuke
    app = QApplication.instance() or QApplication(sys.argv)

    settings_window = SettingsWindow()
    settings_window.show()

    # Mantener el bucle para ejecucion standalone
    if not QApplication.instance():  # Solo si no estamos en Nuke
        sys.exit(app.exec_())
    # Si estamos en Nuke, no llamamos a sys.exit()
&quot;&quot;&quot;
_____________________________________________________________________________________________________

  LGA_ToolPack_settings v0.42 | Lega
  Configuracion de la herramienta LGA_ToolPack
_____________________________________________________________________________________________________
&quot;&quot;&quot;

import sys
import os
import configparser
import typing  # Importar typing
from typing import Optional, Tuple

from PySide2.QtWidgets import (
    QApplication,
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QGroupBox,
    QLabel,
    QLineEdit,
    QFormLayout,
    QPushButton,
    QTextEdit,  # Importar QTextEdit
    QMessageBox,  # Importar QMessageBox
    QCheckBox,
    QFileDialog,
)
from PySide2.QtCore import Qt

# Variable global para controlar el debug
DEBUG = False


# Funcion debug_print
def debug_print(*message):
    if DEBUG:
        print(*message)


# Importar funciones y constantes desde LGA_Write_Focus
# Asumiendo que ambos scripts estan en el mismo directorio o en el sys.path
try:
    from LGA_Write_Focus import (
        get_config_path as wf_get_config_path,  # Renombrar para claridad
        ensure_config_exists as wf_ensure_config_exists,
        get_node_name_from_config as wf_get_node_name_from_config,
        DEFAULT_NODE_NAME as WF_DEFAULT_NODE_NAME,  # Renombrar constante
        CONFIG_SECTION as WF_CONFIG_SECTION,  # Renombrar constante
        CONFIG_NODE_NAME_KEY as WF_CONFIG_NODE_NAME_KEY,  # Renombrar constante
    )
except ImportError as e_wf:
    print(f&quot;Error al importar LGA_Write_Focus.py: {e_wf}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def wf_ensure_config_exists():
        pass

    def wf_get_node_name_from_config() -&gt; str:
        return &quot;Write_Pub&quot;

    def wf_get_config_path() -&gt; typing.Optional[str]:
        return None

    WF_DEFAULT_NODE_NAME = &quot;Write_Pub&quot;
    WF_CONFIG_SECTION = &quot;Settings&quot;
    WF_CONFIG_NODE_NAME_KEY = &quot;node_name&quot;

# --- Importaciones de LGA_showInlFlow ---
try:
    from LGA_showInlFlow import (
        get_config_path as sif_get_config_path,
        ensure_config_exists as sif_ensure_config_exists,
        get_credentials_from_config as sif_get_credentials_from_config,
        save_credentials_to_config as sif_save_credentials_to_config,
    )
except ImportError as e_sif:
    print(f&quot;Error al importar LGA_showInlFlow.py: {e_sif}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def sif_ensure_config_exists():
        pass

    def sif_get_credentials_from_config() -&gt; (
        typing.Tuple[typing.Optional[str], typing.Optional[str], typing.Optional[str]]
    ):
        return None, None, None

    def sif_get_config_path() -&gt; typing.Optional[str]:
        return None

    # Funcion save dummy
    def sif_save_credentials_to_config(url, login, password) -&gt; bool:
        debug_print(
            &quot;Error: LGA_showInlFlow.py no encontrado, no se pueden guardar credenciales.&quot;
        )
        return False


# --- Importaciones de LGA_RnW_ColorSpace_Favs --- Nuevo
try:
    from LGA_RnW_ColorSpace_Favs import (
        get_colorspace_ini_path,
        read_colorspaces_from_ini,
        save_colorspaces_to_ini,
        COLORSPACE_SECTION,  # Importar tambien la constante de seccion
    )
except ImportError as e_csf:
    print(
        f&quot;Error al importar LGA_RnW_ColorSpace_Favs.py: {e_csf}. Funcionalidad limitada.&quot;
    )

    # Definir funciones dummy
    def get_colorspace_ini_path(create_if_missing: bool = True) -&gt; typing.Optional[str]:
        return None

    def read_colorspaces_from_ini(ini_path: typing.Optional[str]) -&gt; typing.List[str]:
        return []

    def save_colorspaces_to_ini(
        ini_path: typing.Optional[str], colorspaces_list: typing.List[str]
    ) -&gt; bool:
        return False

    COLORSPACE_SECTION = &quot;ColorSpaces&quot;

# --- Importaciones de LGA_Render_Complete --- NUEVO
try:
    from LGA_Render_Complete import (
        get_config_path as rc_get_config_path,
        ensure_config_exists as rc_ensure_config_exists,
        get_mail_settings_from_config as rc_get_mail_settings_from_config,
        save_mail_settings_to_config as rc_save_mail_settings_to_config,
        CONFIG_FROM_KEY as RC_CONFIG_FROM_KEY,
        CONFIG_PASS_KEY as RC_CONFIG_PASS_KEY,
        CONFIG_TO_KEY as RC_CONFIG_TO_KEY,
        get_wav_path_from_config,
        save_wav_path_to_config,
        get_sound_enabled_from_config,
        save_sound_enabled_to_config,
    )
except ImportError as e_rc:
    print(f&quot;Error al importar LGA_Render_Complete.py: {e_rc}. Funcionalidad limitada.&quot;)

    def rc_ensure_config_exists() -&gt; None:
        pass

    def rc_get_mail_settings_from_config() -&gt; (
        Tuple[Optional[str], Optional[str], Optional[str]]
    ):
        return None, None, None

    def rc_save_mail_settings_to_config(from_email, from_password, to_email) -&gt; bool:
        debug_print(
            &quot;Error: LGA_Render_Complete.py no encontrado, no se pueden guardar settings de mail.&quot;
        )
        return False

    def rc_get_config_path() -&gt; Optional[str]:
        return None

    RC_CONFIG_FROM_KEY = &quot;from_email&quot;
    RC_CONFIG_PASS_KEY = &quot;from_password&quot;
    RC_CONFIG_TO_KEY = &quot;to_email&quot;


class SettingsWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(&quot;LGA ToolPack Settings&quot;)
        self.setMinimumWidth(450)  # Un poco mas ancho para el QTextEdit
        self.initUI()

    def initUI(self):
        main_layout = QVBoxLayout(self)

        # --- Write Presets Section (Placeholder) ---
        write_presets_group = QGroupBox(&quot;Write Presets&quot;)
        write_presets_layout = QVBoxLayout()
        write_presets_layout.addWidget(
            QLabel(&quot;(Placeholder for Write Presets functionality)&quot;)
        )
        self.save_write_presets_button = QPushButton(&quot;Save&quot;)
        # self.save_write_presets_button.clicked.connect(self.save_write_presets) # Placeholder
        write_presets_layout.addWidget(self.save_write_presets_button, 0, Qt.AlignRight)
        write_presets_group.setLayout(write_presets_layout)
        main_layout.addWidget(write_presets_group)

        # --- Write Focus Section ---
        write_focus_group = QGroupBox(&quot;Write Focus&quot;)
        write_focus_layout_container = QVBoxLayout()
        write_focus_form_layout = QFormLayout()
        self.write_focus_input = QLineEdit()
        try:
            wf_ensure_config_exists()  # Usar funcion importada
            current_node_name = wf_get_node_name_from_config()  # Usar funcion importada
            self.write_focus_input.setText(current_node_name or WF_DEFAULT_NODE_NAME)
        except Exception as e:
            debug_print(f&quot;Error al cargar config de Write Focus: {e}&quot;)
            self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)

        write_focus_form_layout.addRow(
            &quot;Name of the Write Node to Focus:&quot;, self.write_focus_input
        )
        write_focus_layout_container.addLayout(write_focus_form_layout)
        self.save_write_focus_button = QPushButton(&quot;Save&quot;)
        self.save_write_focus_button.clicked.connect(self.save_write_focus_settings)
        write_focus_layout_container.addWidget(
            self.save_write_focus_button, 0, Qt.AlignRight
        )
        write_focus_group.setLayout(write_focus_layout_container)
        main_layout.addWidget(write_focus_group)

        # --- Show in Flow Section ---
        show_flow_group = QGroupBox(&quot;Show in Flow&quot;)
        show_flow_layout_container = QVBoxLayout()
        show_flow_form_layout = QFormLayout()
        self.username_input = QLineEdit()
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.Password)
        self.site_input = QLineEdit()
        # Placeholders para los campos de ShotGrid
        self.site_input.setPlaceholderText(&quot;e.g., https://studio.shotgrid.autodesk.com&quot;)
        self.username_input.setPlaceholderText(&quot;e.g., artist@studio.com&quot;)
        self.password_input.setPlaceholderText(&quot;&quot;)
        show_flow_form_layout.addRow(
            &quot;ShotGrid URL:&quot;,
            self.site_input,
        )
        show_flow_form_layout.addRow(&quot;ShotGrid Login:&quot;, self.username_input)
        show_flow_form_layout.addRow(&quot;ShotGrid Password:&quot;, self.password_input)

        try:
            sif_ensure_config_exists()  # Usar funcion importada
            sif_url, sif_login, sif_password = (
                sif_get_credentials_from_config()
            )  # Usar funcion importada
            self.site_input.setText(sif_url or &quot;&quot;)
            self.username_input.setText(sif_login or &quot;&quot;)
            self.password_input.setText(sif_password or &quot;&quot;)
        except Exception as e:
            debug_print(f&quot;Error al cargar credenciales de Show in Flow: {e}&quot;)

        show_flow_layout_container.addLayout(show_flow_form_layout)
        self.save_show_flow_button = QPushButton(&quot;Save&quot;)
        self.save_show_flow_button.clicked.connect(self.save_show_flow_settings)
        show_flow_layout_container.addWidget(
            self.save_show_flow_button, 0, Qt.AlignRight
        )
        show_flow_group.setLayout(show_flow_layout_container)
        main_layout.addWidget(show_flow_group)

        # --- Color Space Favs Section --- Modificado
        color_space_group = QGroupBox(&quot;Color Space Favorites&quot;)  # Titulo mas descriptivo
        color_space_layout = QVBoxLayout()
        color_space_layout.addWidget(
            QLabel(
                &quot;Enter favorite OCIO color spaces (one per line):&quot;
            )  # Label explicativo
        )
        # Crear el QTextEdit
        self.color_space_edit = QTextEdit()
        self.color_space_edit.setPlaceholderText(
            &quot;e.g.,\nOutput - sRGB\nUtility - Raw\nACES - ACEScg&quot;
        )
        self.color_space_edit.setMinimumHeight(80)  # Altura minima
        color_space_layout.addWidget(self.color_space_edit)

        # --- Cargar favoritos existentes --- Nuevo
        try:
            self.colorspace_ini_path = get_colorspace_ini_path(create_if_missing=True)
            if self.colorspace_ini_path:
                fav_list = read_colorspaces_from_ini(self.colorspace_ini_path)
                self.color_space_edit.setText(&quot;\n&quot;.join(fav_list))
            else:
                debug_print(
                    &quot;Advertencia: No se pudo obtener la ruta del INI de ColorSpaces.&quot;
                )
                # Podriamos deshabilitar el campo/boton si no hay ruta
                # self.color_space_edit.setEnabled(False)
        except Exception as e:
            debug_print(f&quot;Error al cargar Color Space Favs: {e}&quot;)
            QMessageBox.warning(
                self, &quot;Error&quot;, f&quot;Could not load Color Space Favorites:\n{e}&quot;
            )
        # ---------------------------------

        self.save_color_space_button = QPushButton(&quot;Save&quot;)
        self.save_color_space_button.clicked.connect(
            self.save_color_space_settings
        )  # Conectar al nuevo metodo
        color_space_layout.addWidget(self.save_color_space_button, 0, Qt.AlignRight)
        color_space_group.setLayout(color_space_layout)
        main_layout.addWidget(color_space_group)

        # --- Render Complete Mail Settings Section --- NUEVO
        render_mail_group = QGroupBox(&quot;Render Complete Mail Settings&quot;)
        render_mail_layout_container = QVBoxLayout()
        render_mail_form_layout = QFormLayout()
        self.render_mail_from_input = QLineEdit()
        self.render_mail_pass_input = QLineEdit()
        self.render_mail_pass_input.setEchoMode(QLineEdit.Password)
        self.render_mail_to_input = QLineEdit()
        # Placeholders para los campos de mail
        self.render_mail_from_input.setPlaceholderText(&quot;e.g., tuMail@outlook.com&quot;)
        self.render_mail_pass_input.setPlaceholderText(&quot;&quot;)
        self.render_mail_to_input.setPlaceholderText(&quot;e.g., tuMail@gmail.com&quot;)
        # Cargar valores actuales
        try:
            rc_ensure_config_exists()
            from_email, from_password, to_email = rc_get_mail_settings_from_config()
            self.render_mail_from_input.setText(from_email or &quot;&quot;)
            self.render_mail_pass_input.setText(from_password or &quot;&quot;)
            self.render_mail_to_input.setText(to_email or &quot;&quot;)
        except Exception as e:
            debug_print(f&quot;Error al cargar config de Render Complete Mail: {e}&quot;)
        render_mail_form_layout.addRow(&quot;From (Outlook):&quot;, self.render_mail_from_input)
        render_mail_form_layout.addRow(&quot;Password:&quot;, self.render_mail_pass_input)
        render_mail_form_layout.addRow(&quot;To (Recipient):&quot;, self.render_mail_to_input)
        render_mail_layout_container.addLayout(render_mail_form_layout)
        # --- NUEVOS SETTINGS ---
        self.cb_enable_mail = QCheckBox(&quot;Enable mail sending&quot;)
        self.cb_enable_render_time = QCheckBox(&quot;Enable render time calculation&quot;)
        self.cb_enable_sound = QCheckBox(&quot;Enable sound notification&quot;)
        # Inicializar el checkbox segun el setting guardado (ON por defecto)
        try:
            self.cb_enable_sound.setChecked(get_sound_enabled_from_config())
        except Exception as e:
            debug_print(f&quot;Error al leer setting de sonido: {e}&quot;)
            self.cb_enable_sound.setChecked(True)
        render_mail_layout_container.addWidget(self.cb_enable_mail)
        render_mail_layout_container.addWidget(self.cb_enable_render_time)
        render_mail_layout_container.addWidget(self.cb_enable_sound)
        # Selector de archivo .wav
        wav_layout = QHBoxLayout()
        self.wav_path_input = QLineEdit()
        self.wav_path_input.setPlaceholderText(&quot;Select .wav file...&quot;)
        # Inicializar con el valor guardado o el default
        try:
            wav_path = get_wav_path_from_config()
            self.wav_path_input.setText(wav_path)
        except Exception as e:
            debug_print(f&quot;Error al cargar ruta wav: {e}&quot;)
            self.wav_path_input.setText(&quot;&quot;)
        self.wav_browse_btn = QPushButton(&quot;Browse&quot;)
        self.wav_browse_btn.clicked.connect(self.browse_wav_file)
        wav_layout.addWidget(self.wav_path_input)
        wav_layout.addWidget(self.wav_browse_btn)
        render_mail_layout_container.addLayout(wav_layout)
        # ---

        self.save_render_mail_button = QPushButton(&quot;Save&quot;)
        self.save_render_mail_button.clicked.connect(self.save_render_mail_settings)
        render_mail_layout_container.addWidget(
            self.save_render_mail_button, 0, Qt.AlignRight
        )
        render_mail_group.setLayout(render_mail_layout_container)
        main_layout.addWidget(render_mail_group)
        # ---
        main_layout.addStretch()

    def save_write_focus_settings(self):
        &quot;&quot;&quot;Guarda el nombre del nodo de Write Focus en su archivo .ini.&quot;&quot;&quot;
        config_file_path = wf_get_config_path()
        if not config_file_path:
            debug_print(&quot;Error: No se pudo obtener la ruta para guardar Write Focus.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Write Focus.&quot;,
            )
            return

        new_node_name = self.write_focus_input.text().strip()
        if not new_node_name:
            QMessageBox.warning(
                self, &quot;Input Error&quot;, &quot;Write Focus node name cannot be empty.&quot;
            )
            # Revertir al valor anterior o al por defecto
            try:
                current_node_name = wf_get_node_name_from_config()
                self.write_focus_input.setText(
                    current_node_name or WF_DEFAULT_NODE_NAME
                )
            except Exception:
                self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)
            return

        config = configparser.ConfigParser()
        try:
            # Leer existente para preservar otras secciones/claves
            if os.path.exists(config_file_path):
                config.read(config_file_path)

            if not config.has_section(WF_CONFIG_SECTION):
                config.add_section(WF_CONFIG_SECTION)

            config.set(WF_CONFIG_SECTION, WF_CONFIG_NODE_NAME_KEY, new_node_name)

            with open(config_file_path, &quot;w&quot;) as configfile:
                config.write(configfile)

            debug_print(f&quot;Configuracion de Write Focus guardada: {new_node_name}&quot;)
            QMessageBox.information(self, &quot;Success&quot;, &quot;Write Focus settings saved.&quot;)

        except Exception as e:
            debug_print(f&quot;Error al guardar la configuracion de Write Focus: {e}&quot;)
            QMessageBox.critical(
                self, &quot;Save Error&quot;, f&quot;Could not save Write Focus settings:\n{e}&quot;
            )

    def save_show_flow_settings(self):
        &quot;&quot;&quot;Guarda las credenciales de Show in Flow en su archivo .ini.&quot;&quot;&quot;
        config_file_path = sif_get_config_path()
        if not config_file_path:
            debug_print(&quot;Error: No se pudo obtener la ruta para guardar Show in Flow.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Show in Flow.&quot;,
            )
            return

        new_url = self.site_input.text().strip()
        new_login = self.username_input.text().strip()
        new_password = self.password_input.text()  # No hacer strip a la password

        if not new_url or not new_login or not new_password:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;Show in Flow URL, Login, and Password cannot be empty.&quot;,
            )
            # No revertimos aqui, dejamos que el usuario corrija
            return

        # Llamar a la nueva funcion de guardado que maneja la codificacion
        try:
            success = sif_save_credentials_to_config(new_url, new_login, new_password)
            if success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(self, &quot;Success&quot;, &quot;Show in Flow settings saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Show in Flow settings. Check console for details.&quot;,
                )
        except Exception as e:
            debug_print(f&quot;Error al llamar a save_credentials_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Show in Flow settings:\n{e}&quot;,
            )

    def save_color_space_settings(self):  # Nuevo metodo
        &quot;&quot;&quot;Guarda la lista de Color Space Favorites en su archivo .ini.&quot;&quot;&quot;
        # Re-obtener la ruta por si acaso, pero no forzar creacion/copia aqui
        ini_path = getattr(
            self,
            &quot;colorspace_ini_path&quot;,
            get_colorspace_ini_path(create_if_missing=False),
        )

        if not ini_path:
            debug_print(
                &quot;Error: No se pudo obtener la ruta para guardar Color Space Favs.&quot;
            )
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Color Space Favorites.&quot;,
            )
            return

        # Obtener texto del QTextEdit
        text = self.color_space_edit.toPlainText()
        # Dividir en lineas, quitar espacios y filtrar vacias/solo espacios
        favorites_list = [line.strip() for line in text.split(&quot;\n&quot;) if line.strip()]

        # Usar la funcion importada para guardar
        try:
            success = save_colorspaces_to_ini(ini_path, favorites_list)
            if success:
                debug_print(&quot;Configuracion de Color Space Favorites guardada.&quot;)
                QMessageBox.information(self, &quot;Success&quot;, &quot;Color Space Favorites saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso en la funcion save_colorspaces_to_ini
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Color Space Favorites. Check console for details.&quot;,
                )

        except Exception as e:
            # Captura por si save_colorspaces_to_ini lanza una excepcion inesperada
            debug_print(f&quot;Error inesperado al llamar a save_colorspaces_to_ini: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Color Space Favorites:\n{e}&quot;,
            )

    def save_render_mail_settings(self):
        &quot;&quot;&quot;Guarda los datos de mail de Render Complete en su archivo .ini.&quot;&quot;&quot;
        config_file_path = rc_get_config_path()
        if not config_file_path:
            debug_print(
                &quot;Error: No se pudo obtener la ruta para guardar Render Complete Mail.&quot;
            )
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Render Complete Mail.&quot;,
            )
            return
        from_email = self.render_mail_from_input.text().strip()
        from_password = self.render_mail_pass_input.text()
        to_email = self.render_mail_to_input.text().strip()
        wav_path = self.wav_path_input.text().strip()
        sound_enabled = self.cb_enable_sound.isChecked()
        if not from_email or not from_password or not to_email:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;All mail fields must be filled (From, Password, To).&quot;,
            )
            # No revertimos, dejamos que el usuario corrija
            return
        try:
            # La funcion rc_save_mail_settings_to_config ahora maneja la codificacion interna
            success = rc_save_mail_settings_to_config(
                from_email, from_password, to_email
            )
            # Guardar el path del wav
            wav_success = save_wav_path_to_config(wav_path)
            # Guardar el setting de sonido
            sound_success = save_sound_enabled_to_config(sound_enabled)
            if success and wav_success and sound_success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(
                    self, &quot;Success&quot;, &quot;Render Complete Mail settings saved.&quot;
                )
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Render Complete Mail settings. Check console for details.&quot;,
                )
        except Exception as e:
            debug_print(f&quot;Error al llamar a save_mail_settings_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Render Complete Mail settings:\n{e}&quot;,
            )

    def browse_wav_file(self):
        &quot;&quot;&quot;Abre un diálogo para seleccionar un archivo .wav y lo pone en el QLineEdit.&quot;&quot;&quot;
        file_path, _ = QFileDialog.getOpenFileName(
            self, &quot;Select WAV file&quot;, &quot;&quot;, &quot;WAV Files (*.wav)&quot;
        )
        if file_path:
            self.wav_path_input.setText(file_path)
            # Guardar inmediatamente el nuevo path seleccionado
            save_wav_path_to_config(file_path)


# --- Main Execution ---
if __name__ == &quot;__main__&quot;:
    # Necesario para ejecucion standalone fuera de Nuke
    app = QApplication.instance() or QApplication(sys.argv)

    settings_window = SettingsWindow()
    settings_window.show()

    # Mantener el bucle para ejecucion standalone
    if not QApplication.instance():  # Solo si no estamos en Nuke
        sys.exit(app.exec_())
    # Si estamos en Nuke, no llamamos a sys.exit()
&quot;&quot;&quot;
_____________________________________________________________________________________________________

  LGA_ToolPack_settings v0.42 | Lega
  Configuracion de la herramienta LGA_ToolPack
_____________________________________________________________________________________________________
&quot;&quot;&quot;

import sys
import os
import configparser
import typing  # Importar typing
from typing import Optional, Tuple

from PySide2.QtWidgets import (
    QApplication,
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QGroupBox,
    QLabel,
    QLineEdit,
    QFormLayout,
    QPushButton,
    QTextEdit,  # Importar QTextEdit
    QMessageBox,  # Importar QMessageBox
    QCheckBox,
    QFileDialog,
)
from PySide2.QtCore import Qt

# Variable global para controlar el debug
DEBUG = False


# Funcion debug_print
def debug_print(*message):
    if DEBUG:
        print(*message)


# Importar funciones y constantes desde LGA_Write_Focus
# Asumiendo que ambos scripts estan en el mismo directorio o en el sys.path
try:
    from LGA_Write_Focus import (
        get_config_path as wf_get_config_path,  # Renombrar para claridad
        ensure_config_exists as wf_ensure_config_exists,
        get_node_name_from_config as wf_get_node_name_from_config,
        DEFAULT_NODE_NAME as WF_DEFAULT_NODE_NAME,  # Renombrar constante
        CONFIG_SECTION as WF_CONFIG_SECTION,  # Renombrar constante
        CONFIG_NODE_NAME_KEY as WF_CONFIG_NODE_NAME_KEY,  # Renombrar constante
    )
except ImportError as e_wf:
    print(f&quot;Error al importar LGA_Write_Focus.py: {e_wf}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def wf_ensure_config_exists():
        pass

    def wf_get_node_name_from_config() -&gt; str:
        return &quot;Write_Pub&quot;

    def wf_get_config_path() -&gt; typing.Optional[str]:
        return None

    WF_DEFAULT_NODE_NAME = &quot;Write_Pub&quot;
    WF_CONFIG_SECTION = &quot;Settings&quot;
    WF_CONFIG_NODE_NAME_KEY = &quot;node_name&quot;

# --- Importaciones de LGA_showInlFlow ---
try:
    from LGA_showInlFlow import (
        get_config_path as sif_get_config_path,
        ensure_config_exists as sif_ensure_config_exists,
        get_credentials_from_config as sif_get_credentials_from_config,
        save_credentials_to_config as sif_save_credentials_to_config,
    )
except ImportError as e_sif:
    print(f&quot;Error al importar LGA_showInlFlow.py: {e_sif}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def sif_ensure_config_exists():
        pass

    def sif_get_credentials_from_config() -&gt; (
        typing.Tuple[typing.Optional[str], typing.Optional[str], typing.Optional[str]]
    ):
        return None, None, None

    def sif_get_config_path() -&gt; typing.Optional[str]:
        return None

    # Funcion save dummy
    def sif_save_credentials_to_config(url, login, password) -&gt; bool:
        debug_print(
            &quot;Error: LGA_showInlFlow.py no encontrado, no se pueden guardar credenciales.&quot;
        )
        return False


# --- Importaciones de LGA_RnW_ColorSpace_Favs --- Nuevo
try:
    from LGA_RnW_ColorSpace_Favs import (
        get_colorspace_ini_path,
        read_colorspaces_from_ini,
        save_colorspaces_to_ini,
        COLORSPACE_SECTION,  # Importar tambien la constante de seccion
    )
except ImportError as e_csf:
    print(
        f&quot;Error al importar LGA_RnW_ColorSpace_Favs.py: {e_csf}. Funcionalidad limitada.&quot;
    )

    # Definir funciones dummy
    def get_colorspace_ini_path(create_if_missing: bool = True) -&gt; typing.Optional[str]:
        return None

    def read_colorspaces_from_ini(ini_path: typing.Optional[str]) -&gt; typing.List[str]:
        return []

    def save_colorspaces_to_ini(
        ini_path: typing.Optional[str], colorspaces_list: typing.List[str]
    ) -&gt; bool:
        return False

    COLORSPACE_SECTION = &quot;ColorSpaces&quot;

# --- Importaciones de LGA_Render_Complete --- NUEVO
try:
    from LGA_Render_Complete import (
        get_config_path as rc_get_config_path,
        ensure_config_exists as rc_ensure_config_exists,
        get_mail_settings_from_config as rc_get_mail_settings_from_config,
        save_mail_settings_to_config as rc_save_mail_settings_to_config,
        CONFIG_FROM_KEY as RC_CONFIG_FROM_KEY,
        CONFIG_PASS_KEY as RC_CONFIG_PASS_KEY,
        CONFIG_TO_KEY as RC_CONFIG_TO_KEY,
        get_wav_path_from_config,
        save_wav_path_to_config,
        get_sound_enabled_from_config,
        save_sound_enabled_to_config,
        get_render_time_enabled_from_config,
        save_render_time_enabled_to_config,
    )
except ImportError as e_rc:
    print(f&quot;Error al importar LGA_Render_Complete.py: {e_rc}. Funcionalidad limitada.&quot;)

    def rc_ensure_config_exists() -&gt; None:
        pass

    def rc_get_mail_settings_from_config() -&gt; (
        Tuple[Optional[str], Optional[str], Optional[str]]
    ):
        return None, None, None

    def rc_save_mail_settings_to_config(from_email, from_password, to_email) -&gt; bool:
        debug_print(
            &quot;Error: LGA_Render_Complete.py no encontrado, no se pueden guardar settings de mail.&quot;
        )
        return False

    def rc_get_config_path() -&gt; Optional[str]:
        return None

    RC_CONFIG_FROM_KEY = &quot;from_email&quot;
    RC_CONFIG_PASS_KEY = &quot;from_password&quot;
    RC_CONFIG_TO_KEY = &quot;to_email&quot;


class SettingsWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(&quot;LGA ToolPack Settings&quot;)
        self.setMinimumWidth(450)  # Un poco mas ancho para el QTextEdit
        self.initUI()

    def initUI(self):
        main_layout = QVBoxLayout(self)

        # --- Write Presets Section (Placeholder) ---
        write_presets_group = QGroupBox(&quot;Write Presets&quot;)
        write_presets_layout = QVBoxLayout()
        write_presets_layout.addWidget(
            QLabel(&quot;(Placeholder for Write Presets functionality)&quot;)
        )
        self.save_write_presets_button = QPushButton(&quot;Save&quot;)
        # self.save_write_presets_button.clicked.connect(self.save_write_presets) # Placeholder
        write_presets_layout.addWidget(self.save_write_presets_button, 0, Qt.AlignRight)
        write_presets_group.setLayout(write_presets_layout)
        main_layout.addWidget(write_presets_group)

        # --- Write Focus Section ---
        write_focus_group = QGroupBox(&quot;Write Focus&quot;)
        write_focus_layout_container = QVBoxLayout()
        write_focus_form_layout = QFormLayout()
        self.write_focus_input = QLineEdit()
        try:
            wf_ensure_config_exists()  # Usar funcion importada
            current_node_name = wf_get_node_name_from_config()  # Usar funcion importada
            self.write_focus_input.setText(current_node_name or WF_DEFAULT_NODE_NAME)
        except Exception as e:
            debug_print(f&quot;Error al cargar config de Write Focus: {e}&quot;)
            self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)

        write_focus_form_layout.addRow(
            &quot;Name of the Write Node to Focus:&quot;, self.write_focus_input
        )
        write_focus_layout_container.addLayout(write_focus_form_layout)
        self.save_write_focus_button = QPushButton(&quot;Save&quot;)
        self.save_write_focus_button.clicked.connect(self.save_write_focus_settings)
        write_focus_layout_container.addWidget(
            self.save_write_focus_button, 0, Qt.AlignRight
        )
        write_focus_group.setLayout(write_focus_layout_container)
        main_layout.addWidget(write_focus_group)

        # --- Show in Flow Section ---
        show_flow_group = QGroupBox(&quot;Show in Flow&quot;)
        show_flow_layout_container = QVBoxLayout()
        show_flow_form_layout = QFormLayout()
        self.username_input = QLineEdit()
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.Password)
        self.site_input = QLineEdit()
        # Placeholders para los campos de ShotGrid
        self.site_input.setPlaceholderText(&quot;e.g., https://studio.shotgrid.autodesk.com&quot;)
        self.username_input.setPlaceholderText(&quot;e.g., artist@studio.com&quot;)
        self.password_input.setPlaceholderText(&quot;&quot;)
        show_flow_form_layout.addRow(
            &quot;ShotGrid URL:&quot;,
            self.site_input,
        )
        show_flow_form_layout.addRow(&quot;ShotGrid Login:&quot;, self.username_input)
        show_flow_form_layout.addRow(&quot;ShotGrid Password:&quot;, self.password_input)

        try:
            sif_ensure_config_exists()  # Usar funcion importada
            sif_url, sif_login, sif_password = (
                sif_get_credentials_from_config()
            )  # Usar funcion importada
            self.site_input.setText(sif_url or &quot;&quot;)
            self.username_input.setText(sif_login or &quot;&quot;)
            self.password_input.setText(sif_password or &quot;&quot;)
        except Exception as e:
            debug_print(f&quot;Error al cargar credenciales de Show in Flow: {e}&quot;)

        show_flow_layout_container.addLayout(show_flow_form_layout)
        self.save_show_flow_button = QPushButton(&quot;Save&quot;)
        self.save_show_flow_button.clicked.connect(self.save_show_flow_settings)
        show_flow_layout_container.addWidget(
            self.save_show_flow_button, 0, Qt.AlignRight
        )
        show_flow_group.setLayout(show_flow_layout_container)
        main_layout.addWidget(show_flow_group)

        # --- Color Space Favs Section --- Modificado
        color_space_group = QGroupBox(&quot;Color Space Favorites&quot;)  # Titulo mas descriptivo
        color_space_layout = QVBoxLayout()
        color_space_layout.addWidget(
            QLabel(
                &quot;Enter favorite OCIO color spaces (one per line):&quot;
            )  # Label explicativo
        )
        # Crear el QTextEdit
        self.color_space_edit = QTextEdit()
        self.color_space_edit.setPlaceholderText(
            &quot;e.g.,\nOutput - sRGB\nUtility - Raw\nACES - ACEScg&quot;
        )
        self.color_space_edit.setMinimumHeight(80)  # Altura minima
        color_space_layout.addWidget(self.color_space_edit)

        # --- Cargar favoritos existentes --- Nuevo
        try:
            self.colorspace_ini_path = get_colorspace_ini_path(create_if_missing=True)
            if self.colorspace_ini_path:
                fav_list = read_colorspaces_from_ini(self.colorspace_ini_path)
                self.color_space_edit.setText(&quot;\n&quot;.join(fav_list))
            else:
                debug_print(
                    &quot;Advertencia: No se pudo obtener la ruta del INI de ColorSpaces.&quot;
                )
                # Podriamos deshabilitar el campo/boton si no hay ruta
                # self.color_space_edit.setEnabled(False)
        except Exception as e:
            debug_print(f&quot;Error al cargar Color Space Favs: {e}&quot;)
            QMessageBox.warning(
                self, &quot;Error&quot;, f&quot;Could not load Color Space Favorites:\n{e}&quot;
            )
        # ---------------------------------

        self.save_color_space_button = QPushButton(&quot;Save&quot;)
        self.save_color_space_button.clicked.connect(
            self.save_color_space_settings
        )  # Conectar al nuevo metodo
        color_space_layout.addWidget(self.save_color_space_button, 0, Qt.AlignRight)
        color_space_group.setLayout(color_space_layout)
        main_layout.addWidget(color_space_group)

        # --- Render Complete Mail Settings Section --- NUEVO
        render_mail_group = QGroupBox(&quot;Render Complete Mail Settings&quot;)
        render_mail_layout_container = QVBoxLayout()
        render_mail_form_layout = QFormLayout()
        self.render_mail_from_input = QLineEdit()
        self.render_mail_pass_input = QLineEdit()
        self.render_mail_pass_input.setEchoMode(QLineEdit.Password)
        self.render_mail_to_input = QLineEdit()
        # Placeholders para los campos de mail
        self.render_mail_from_input.setPlaceholderText(&quot;e.g., tuMail@outlook.com&quot;)
        self.render_mail_pass_input.setPlaceholderText(&quot;&quot;)
        self.render_mail_to_input.setPlaceholderText(&quot;e.g., tuMail@gmail.com&quot;)
        # Cargar valores actuales
        try:
            rc_ensure_config_exists()
            from_email, from_password, to_email = rc_get_mail_settings_from_config()
            self.render_mail_from_input.setText(from_email or &quot;&quot;)
            self.render_mail_pass_input.setText(from_password or &quot;&quot;)
            self.render_mail_to_input.setText(to_email or &quot;&quot;)
        except Exception as e:
            debug_print(f&quot;Error al cargar config de Render Complete Mail: {e}&quot;)
        render_mail_form_layout.addRow(&quot;From (Outlook):&quot;, self.render_mail_from_input)
        render_mail_form_layout.addRow(&quot;Password:&quot;, self.render_mail_pass_input)
        render_mail_form_layout.addRow(&quot;To (Recipient):&quot;, self.render_mail_to_input)
        render_mail_layout_container.addLayout(render_mail_form_layout)
        # --- NUEVOS SETTINGS ---
        self.cb_enable_mail = QCheckBox(&quot;Enable mail sending&quot;)
        self.cb_enable_render_time = QCheckBox(&quot;Enable render time calculation&quot;)
        self.cb_enable_sound = QCheckBox(&quot;Enable sound notification&quot;)
        # Inicializar el checkbox segun el setting guardado (ON por defecto)
        try:
            self.cb_enable_render_time.setChecked(get_render_time_enabled_from_config())
        except Exception as e:
            debug_print(f&quot;Error al leer setting de render time: {e}&quot;)
            self.cb_enable_render_time.setChecked(True)
        # Inicializar el checkbox segun el setting guardado (ON por defecto)
        try:
            self.cb_enable_sound.setChecked(get_sound_enabled_from_config())
        except Exception as e:
            debug_print(f&quot;Error al leer setting de sonido: {e}&quot;)
            self.cb_enable_sound.setChecked(True)
        render_mail_layout_container.addWidget(self.cb_enable_mail)
        render_mail_layout_container.addWidget(self.cb_enable_render_time)
        render_mail_layout_container.addWidget(self.cb_enable_sound)
        # Selector de archivo .wav
        wav_layout = QHBoxLayout()
        self.wav_path_input = QLineEdit()
        self.wav_path_input.setPlaceholderText(&quot;Select .wav file...&quot;)
        # Inicializar con el valor guardado o el default
        try:
            wav_path = get_wav_path_from_config()
            self.wav_path_input.setText(wav_path)
        except Exception as e:
            debug_print(f&quot;Error al cargar ruta wav: {e}&quot;)
            self.wav_path_input.setText(&quot;&quot;)
        self.wav_browse_btn = QPushButton(&quot;Browse&quot;)
        self.wav_browse_btn.clicked.connect(self.browse_wav_file)
        wav_layout.addWidget(self.wav_path_input)
        wav_layout.addWidget(self.wav_browse_btn)
        render_mail_layout_container.addLayout(wav_layout)
        # ---

        self.save_render_mail_button = QPushButton(&quot;Save&quot;)
        self.save_render_mail_button.clicked.connect(self.save_render_mail_settings)
        render_mail_layout_container.addWidget(
            self.save_render_mail_button, 0, Qt.AlignRight
        )
        render_mail_group.setLayout(render_mail_layout_container)
        main_layout.addWidget(render_mail_group)
        # ---
        main_layout.addStretch()

    def save_write_focus_settings(self):
        &quot;&quot;&quot;Guarda el nombre del nodo de Write Focus en su archivo .ini.&quot;&quot;&quot;
        config_file_path = wf_get_config_path()
        if not config_file_path:
            debug_print(&quot;Error: No se pudo obtener la ruta para guardar Write Focus.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Write Focus.&quot;,
            )
            return

        new_node_name = self.write_focus_input.text().strip()
        if not new_node_name:
            QMessageBox.warning(
                self, &quot;Input Error&quot;, &quot;Write Focus node name cannot be empty.&quot;
            )
            # Revertir al valor anterior o al por defecto
            try:
                current_node_name = wf_get_node_name_from_config()
                self.write_focus_input.setText(
                    current_node_name or WF_DEFAULT_NODE_NAME
                )
            except Exception:
                self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)
            return

        config = configparser.ConfigParser()
        try:
            # Leer existente para preservar otras secciones/claves
            if os.path.exists(config_file_path):
                config.read(config_file_path)

            if not config.has_section(WF_CONFIG_SECTION):
                config.add_section(WF_CONFIG_SECTION)

            config.set(WF_CONFIG_SECTION, WF_CONFIG_NODE_NAME_KEY, new_node_name)

            with open(config_file_path, &quot;w&quot;) as configfile:
                config.write(configfile)

            debug_print(f&quot;Configuracion de Write Focus guardada: {new_node_name}&quot;)
            QMessageBox.information(self, &quot;Success&quot;, &quot;Write Focus settings saved.&quot;)

        except Exception as e:
            debug_print(f&quot;Error al guardar la configuracion de Write Focus: {e}&quot;)
            QMessageBox.critical(
                self, &quot;Save Error&quot;, f&quot;Could not save Write Focus settings:\n{e}&quot;
            )

    def save_show_flow_settings(self):
        &quot;&quot;&quot;Guarda las credenciales de Show in Flow en su archivo .ini.&quot;&quot;&quot;
        config_file_path = sif_get_config_path()
        if not config_file_path:
            debug_print(&quot;Error: No se pudo obtener la ruta para guardar Show in Flow.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Show in Flow.&quot;,
            )
            return

        new_url = self.site_input.text().strip()
        new_login = self.username_input.text().strip()
        new_password = self.password_input.text()  # No hacer strip a la password

        if not new_url or not new_login or not new_password:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;Show in Flow URL, Login, and Password cannot be empty.&quot;,
            )
            # No revertimos aqui, dejamos que el usuario corrija
            return

        # Llamar a la nueva funcion de guardado que maneja la codificacion
        try:
            success = sif_save_credentials_to_config(new_url, new_login, new_password)
            if success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(self, &quot;Success&quot;, &quot;Show in Flow settings saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Show in Flow settings. Check console for details.&quot;,
                )
        except Exception as e:
            debug_print(f&quot;Error al llamar a save_credentials_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Show in Flow settings:\n{e}&quot;,
            )

    def save_color_space_settings(self):  # Nuevo metodo
        &quot;&quot;&quot;Guarda la lista de Color Space Favorites en su archivo .ini.&quot;&quot;&quot;
        # Re-obtener la ruta por si acaso, pero no forzar creacion/copia aqui
        ini_path = getattr(
            self,
            &quot;colorspace_ini_path&quot;,
            get_colorspace_ini_path(create_if_missing=False),
        )

        if not ini_path:
            debug_print(
                &quot;Error: No se pudo obtener la ruta para guardar Color Space Favs.&quot;
            )
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Color Space Favorites.&quot;,
            )
            return

        # Obtener texto del QTextEdit
        text = self.color_space_edit.toPlainText()
        # Dividir en lineas, quitar espacios y filtrar vacias/solo espacios
        favorites_list = [line.strip() for line in text.split(&quot;\n&quot;) if line.strip()]

        # Usar la funcion importada para guardar
        try:
            success = save_colorspaces_to_ini(ini_path, favorites_list)
            if success:
                debug_print(&quot;Configuracion de Color Space Favorites guardada.&quot;)
                QMessageBox.information(self, &quot;Success&quot;, &quot;Color Space Favorites saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso en la funcion save_colorspaces_to_ini
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Color Space Favorites. Check console for details.&quot;,
                )

        except Exception as e:
            # Captura por si save_colorspaces_to_ini lanza una excepcion inesperada
            debug_print(f&quot;Error inesperado al llamar a save_colorspaces_to_ini: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Color Space Favorites:\n{e}&quot;,
            )

    def save_render_mail_settings(self):
        &quot;&quot;&quot;Guarda los datos de mail de Render Complete en su archivo .ini.&quot;&quot;&quot;
        config_file_path = rc_get_config_path()
        if not config_file_path:
            debug_print(
                &quot;Error: No se pudo obtener la ruta para guardar Render Complete Mail.&quot;
            )
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Render Complete Mail.&quot;,
            )
            return
        from_email = self.render_mail_from_input.text().strip()
        from_password = self.render_mail_pass_input.text()
        to_email = self.render_mail_to_input.text().strip()
        wav_path = self.wav_path_input.text().strip()
        sound_enabled = self.cb_enable_sound.isChecked()
        render_time_enabled = self.cb_enable_render_time.isChecked()
        if not from_email or not from_password or not to_email:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;All mail fields must be filled (From, Password, To).&quot;,
            )
            # No revertimos, dejamos que el usuario corrija
            return
        try:
            # La funcion rc_save_mail_settings_to_config ahora maneja la codificacion interna
            success = rc_save_mail_settings_to_config(
                from_email, from_password, to_email
            )
            # Guardar el path del wav
            wav_success = save_wav_path_to_config(wav_path)
            # Guardar el setting de sonido
            sound_success = save_sound_enabled_to_config(sound_enabled)
            # Guardar el setting de render time
            render_time_success = save_render_time_enabled_to_config(
                render_time_enabled
            )
            if success and wav_success and sound_success and render_time_success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(
                    self, &quot;Success&quot;, &quot;Render Complete Mail settings saved.&quot;
                )
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Render Complete Mail settings. Check console for details.&quot;,
                )
        except Exception as e:
            debug_print(f&quot;Error al llamar a save_mail_settings_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Render Complete Mail settings:\n{e}&quot;,
            )

    def browse_wav_file(self):
        &quot;&quot;&quot;Abre un diálogo para seleccionar un archivo .wav y lo pone en el QLineEdit.&quot;&quot;&quot;
        file_path, _ = QFileDialog.getOpenFileName(
            self, &quot;Select WAV file&quot;, &quot;&quot;, &quot;WAV Files (*.wav)&quot;
        )
        if file_path:
            self.wav_path_input.setText(file_path)
            # Guardar inmediatamente el nuevo path seleccionado
            save_wav_path_to_config(file_path)


# --- Main Execution ---
if __name__ == &quot;__main__&quot;:
    # Necesario para ejecucion standalone fuera de Nuke
    app = QApplication.instance() or QApplication(sys.argv)

    settings_window = SettingsWindow()
    settings_window.show()

    # Mantener el bucle para ejecucion standalone
    if not QApplication.instance():  # Solo si no estamos en Nuke
        sys.exit(app.exec_())
    # Si estamos en Nuke, no llamamos a sys.exit()
&quot;&quot;&quot;
_____________________________________________________________________________________________________

  LGA_ToolPack_settings v0.42 | Lega
  Configuracion de la herramienta LGA_ToolPack
_____________________________________________________________________________________________________
&quot;&quot;&quot;

import sys
import os
import configparser
import typing  # Importar typing
from typing import Optional, Tuple

from PySide2.QtWidgets import (
    QApplication,
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QGroupBox,
    QLabel,
    QLineEdit,
    QFormLayout,
    QPushButton,
    QTextEdit,  # Importar QTextEdit
    QMessageBox,  # Importar QMessageBox
    QCheckBox,
    QFileDialog,
    QDesktopWidget,
)
from PySide2.QtCore import Qt

# Variable global para controlar el debug
DEBUG = False


# Funcion debug_print
def debug_print(*message):
    if DEBUG:
        print(*message)


# Importar funciones y constantes desde LGA_Write_Focus
# Asumiendo que ambos scripts estan en el mismo directorio o en el sys.path
try:
    from LGA_Write_Focus import (
        get_config_path as wf_get_config_path,  # Renombrar para claridad
        ensure_config_exists as wf_ensure_config_exists,
        get_node_name_from_config as wf_get_node_name_from_config,
        DEFAULT_NODE_NAME as WF_DEFAULT_NODE_NAME,  # Renombrar constante
        CONFIG_SECTION as WF_CONFIG_SECTION,  # Renombrar constante
        CONFIG_NODE_NAME_KEY as WF_CONFIG_NODE_NAME_KEY,  # Renombrar constante
    )
except ImportError as e_wf:
    print(f&quot;Error al importar LGA_Write_Focus.py: {e_wf}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def wf_ensure_config_exists():
        pass

    def wf_get_node_name_from_config() -&gt; str:
        return &quot;Write_Pub&quot;

    def wf_get_config_path() -&gt; typing.Optional[str]:
        return None

    WF_DEFAULT_NODE_NAME = &quot;Write_Pub&quot;
    WF_CONFIG_SECTION = &quot;Settings&quot;
    WF_CONFIG_NODE_NAME_KEY = &quot;node_name&quot;

# --- Importaciones de LGA_showInlFlow ---
try:
    from LGA_showInlFlow import (
        get_config_path as sif_get_config_path,
        ensure_config_exists as sif_ensure_config_exists,
        get_credentials_from_config as sif_get_credentials_from_config,
        save_credentials_to_config as sif_save_credentials_to_config,
    )
except ImportError as e_sif:
    print(f&quot;Error al importar LGA_showInlFlow.py: {e_sif}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def sif_ensure_config_exists():
        pass

    def sif_get_credentials_from_config() -&gt; (
        typing.Tuple[typing.Optional[str], typing.Optional[str], typing.Optional[str]]
    ):
        return None, None, None

    def sif_get_config_path() -&gt; typing.Optional[str]:
        return None

    # Funcion save dummy
    def sif_save_credentials_to_config(url, login, password) -&gt; bool:
        debug_print(
            &quot;Error: LGA_showInlFlow.py no encontrado, no se pueden guardar credenciales.&quot;
        )
        return False


# --- Importaciones de LGA_RnW_ColorSpace_Favs --- Nuevo
try:
    from LGA_RnW_ColorSpace_Favs import (
        get_colorspace_ini_path,
        read_colorspaces_from_ini,
        save_colorspaces_to_ini,
        COLORSPACE_SECTION,  # Importar tambien la constante de seccion
    )
except ImportError as e_csf:
    print(
        f&quot;Error al importar LGA_RnW_ColorSpace_Favs.py: {e_csf}. Funcionalidad limitada.&quot;
    )

    # Definir funciones dummy
    def get_colorspace_ini_path(create_if_missing: bool = True) -&gt; typing.Optional[str]:
        return None

    def read_colorspaces_from_ini(ini_path: typing.Optional[str]) -&gt; typing.List[str]:
        return []

    def save_colorspaces_to_ini(
        ini_path: typing.Optional[str], colorspaces_list: typing.List[str]
    ) -&gt; bool:
        return False

    COLORSPACE_SECTION = &quot;ColorSpaces&quot;

# --- Importaciones de LGA_Render_Complete --- NUEVO
try:
    from LGA_Render_Complete import (
        get_config_path as rc_get_config_path,
        ensure_config_exists as rc_ensure_config_exists,
        get_mail_settings_from_config as rc_get_mail_settings_from_config,
        save_mail_settings_to_config as rc_save_mail_settings_to_config,
        CONFIG_FROM_KEY as RC_CONFIG_FROM_KEY,
        CONFIG_PASS_KEY as RC_CONFIG_PASS_KEY,
        CONFIG_TO_KEY as RC_CONFIG_TO_KEY,
        get_wav_path_from_config,
        save_wav_path_to_config,
        get_sound_enabled_from_config,
        save_sound_enabled_to_config,
        get_render_time_enabled_from_config,
        save_render_time_enabled_to_config,
    )
except ImportError as e_rc:
    print(f&quot;Error al importar LGA_Render_Complete.py: {e_rc}. Funcionalidad limitada.&quot;)

    def rc_ensure_config_exists() -&gt; None:
        pass

    def rc_get_mail_settings_from_config() -&gt; (
        Tuple[Optional[str], Optional[str], Optional[str]]
    ):
        return None, None, None

    def rc_save_mail_settings_to_config(from_email, from_password, to_email) -&gt; bool:
        debug_print(
            &quot;Error: LGA_Render_Complete.py no encontrado, no se pueden guardar settings de mail.&quot;
        )
        return False

    def rc_get_config_path() -&gt; Optional[str]:
        return None

    RC_CONFIG_FROM_KEY = &quot;from_email&quot;
    RC_CONFIG_PASS_KEY = &quot;from_password&quot;
    RC_CONFIG_TO_KEY = &quot;to_email&quot;


class SettingsWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(&quot;LGA ToolPack Settings&quot;)
        self.setMinimumWidth(570)  # Más ancho para la ventana
        self.initUI()
        # Centrar la ventana en la pantalla (horizontal y vertical) DESPUES de show()
        self.show()
        qr = self.frameGeometry()
        cp = QDesktopWidget().availableGeometry().center()
        qr.moveCenter(cp)
        self.move(qr.topLeft())
        self.hide()

    def initUI(self):
        main_layout = QVBoxLayout(self)

        # --- Write Focus Section ---
        write_focus_group = QGroupBox()
        write_focus_layout_container = QVBoxLayout()
        write_focus_title = QLabel(&quot;Write Focus&quot;)
        write_focus_title.setStyleSheet(&quot;font-weight: bold; font-size: 11pt;&quot;)
        write_focus_layout_container.addWidget(write_focus_title)
        write_focus_form_layout = QFormLayout()
        self.write_focus_input = QLineEdit()
        try:
            wf_ensure_config_exists()
            current_node_name = wf_get_node_name_from_config()
            self.write_focus_input.setText(current_node_name or WF_DEFAULT_NODE_NAME)
        except Exception as e:
            debug_print(f&quot;Error al cargar config de Write Focus: {e}&quot;)
            self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)
        write_focus_form_layout.addRow(
            &quot;Name of the Write Node to Focus:&quot;, self.write_focus_input
        )
        write_focus_layout_container.addLayout(write_focus_form_layout)
        self.save_write_focus_button = QPushButton(&quot;Save&quot;)
        self.save_write_focus_button.clicked.connect(self.save_write_focus_settings)
        write_focus_layout_container.addWidget(
            self.save_write_focus_button, 0, Qt.AlignRight
        )
        write_focus_group.setLayout(write_focus_layout_container)
        main_layout.addWidget(write_focus_group)
        main_layout.addSpacing(12)

        # --- Render Complete Mail Settings Section ---
        render_mail_group = QGroupBox()
        render_mail_layout_container = QVBoxLayout()
        render_mail_title = QLabel(&quot;Render Complete&quot;)
        render_mail_title.setStyleSheet(&quot;font-weight: bold; font-size: 11pt;&quot;)
        render_mail_layout_container.addWidget(render_mail_title)
        render_mail_form_layout = QFormLayout()
        self.render_mail_from_input = QLineEdit()
        self.render_mail_pass_input = QLineEdit()
        self.render_mail_pass_input.setEchoMode(QLineEdit.Password)
        self.render_mail_to_input = QLineEdit()
        self.render_mail_from_input.setPlaceholderText(&quot;e.g., tuMail@outlook.com&quot;)
        self.render_mail_pass_input.setPlaceholderText(&quot;&quot;)
        self.render_mail_to_input.setPlaceholderText(&quot;e.g., tuMail@gmail.com&quot;)
        try:
            rc_ensure_config_exists()
            from_email, from_password, to_email = rc_get_mail_settings_from_config()
            self.render_mail_from_input.setText(from_email or &quot;&quot;)
            self.render_mail_pass_input.setText(from_password or &quot;&quot;)
            self.render_mail_to_input.setText(to_email or &quot;&quot;)
        except Exception as e:
            debug_print(f&quot;Error al cargar config de Render Complete Mail: {e}&quot;)
        # --- NUEVOS SETTINGS ---
        self.cb_enable_render_time = QCheckBox(&quot;Enable render time calculation&quot;)
        self.cb_enable_sound = QCheckBox(&quot;Enable sound notification&quot;)
        try:
            self.cb_enable_render_time.setChecked(get_render_time_enabled_from_config())
        except Exception as e:
            debug_print(f&quot;Error al leer setting de render time: {e}&quot;)
            self.cb_enable_render_time.setChecked(True)
        try:
            self.cb_enable_sound.setChecked(get_sound_enabled_from_config())
        except Exception as e:
            debug_print(f&quot;Error al leer setting de sonido: {e}&quot;)
            self.cb_enable_sound.setChecked(True)
        render_mail_layout_container.addWidget(self.cb_enable_render_time)
        render_mail_layout_container.addWidget(self.cb_enable_sound)
        wav_layout = QHBoxLayout()
        self.wav_path_input = QLineEdit()
        self.wav_path_input.setPlaceholderText(&quot;Select .wav file...&quot;)
        try:
            wav_path = get_wav_path_from_config()
            self.wav_path_input.setText(wav_path)
        except Exception as e:
            debug_print(f&quot;Error al cargar ruta wav: {e}&quot;)
            self.wav_path_input.setText(&quot;&quot;)
        self.wav_browse_btn = QPushButton(&quot;Browse&quot;)
        self.wav_browse_btn.clicked.connect(self.browse_wav_file)
        wav_layout.addWidget(self.wav_path_input)
        wav_layout.addWidget(self.wav_browse_btn)
        render_mail_layout_container.addLayout(wav_layout)
        # Ahora agrego los campos de mail al final
        render_mail_form_layout.addRow(&quot;From (Outlook):&quot;, self.render_mail_from_input)
        render_mail_form_layout.addRow(&quot;Password:&quot;, self.render_mail_pass_input)
        render_mail_form_layout.addRow(&quot;To (Recipient):&quot;, self.render_mail_to_input)
        render_mail_layout_container.addLayout(render_mail_form_layout)
        self.save_render_mail_button = QPushButton(&quot;Save&quot;)
        self.save_render_mail_button.clicked.connect(self.save_render_mail_settings)
        render_mail_layout_container.addWidget(
            self.save_render_mail_button, 0, Qt.AlignRight
        )
        render_mail_group.setLayout(render_mail_layout_container)
        main_layout.addWidget(render_mail_group)
        main_layout.addSpacing(12)

        # --- Show in Flow Section ---
        show_flow_group = QGroupBox()
        show_flow_layout_container = QVBoxLayout()
        show_flow_title = QLabel(&quot;Show in Flow&quot;)
        show_flow_title.setStyleSheet(&quot;font-weight: bold; font-size: 11pt;&quot;)
        show_flow_layout_container.addWidget(show_flow_title)
        show_flow_form_layout = QFormLayout()
        self.username_input = QLineEdit()
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.Password)
        self.site_input = QLineEdit()
        self.site_input.setPlaceholderText(&quot;e.g., https://studio.shotgrid.autodesk.com&quot;)
        self.username_input.setPlaceholderText(&quot;e.g., artist@studio.com&quot;)
        self.password_input.setPlaceholderText(&quot;&quot;)
        show_flow_form_layout.addRow(
            &quot;ShotGrid URL:&quot;,
            self.site_input,
        )
        show_flow_form_layout.addRow(&quot;ShotGrid Login:&quot;, self.username_input)
        show_flow_form_layout.addRow(&quot;ShotGrid Password:&quot;, self.password_input)
        try:
            sif_ensure_config_exists()
            sif_url, sif_login, sif_password = sif_get_credentials_from_config()
            self.site_input.setText(sif_url or &quot;&quot;)
            self.username_input.setText(sif_login or &quot;&quot;)
            self.password_input.setText(sif_password or &quot;&quot;)
        except Exception as e:
            debug_print(f&quot;Error al cargar credenciales de Show in Flow: {e}&quot;)
        show_flow_layout_container.addLayout(show_flow_form_layout)
        self.save_show_flow_button = QPushButton(&quot;Save&quot;)
        self.save_show_flow_button.clicked.connect(self.save_show_flow_settings)
        show_flow_layout_container.addWidget(
            self.save_show_flow_button, 0, Qt.AlignRight
        )
        show_flow_group.setLayout(show_flow_layout_container)
        main_layout.addWidget(show_flow_group)
        main_layout.addSpacing(12)

        # --- Color Space Favs Section ---
        color_space_group = QGroupBox()
        color_space_layout = QVBoxLayout()
        color_space_title = QLabel(&quot;Color Space Favorites&quot;)
        color_space_title.setStyleSheet(&quot;font-weight: bold; font-size: 11pt;&quot;)
        color_space_layout.addWidget(color_space_title)
        color_space_layout.addWidget(
            QLabel(&quot;Enter favorite OCIO color spaces (one per line):&quot;)
        )
        self.color_space_edit = QTextEdit()
        self.color_space_edit.setPlaceholderText(
            &quot;e.g.,\nOutput - sRGB\nUtility - Raw\nACES - ACEScg&quot;
        )
        self.color_space_edit.setMinimumHeight(80)
        color_space_layout.addWidget(self.color_space_edit)
        try:
            self.colorspace_ini_path = get_colorspace_ini_path(create_if_missing=True)
            if self.colorspace_ini_path:
                fav_list = read_colorspaces_from_ini(self.colorspace_ini_path)
                self.color_space_edit.setText(&quot;\n&quot;.join(fav_list))
            else:
                debug_print(
                    &quot;Advertencia: No se pudo obtener la ruta del INI de ColorSpaces.&quot;
                )
        except Exception as e:
            debug_print(f&quot;Error al cargar Color Space Favs: {e}&quot;)
            QMessageBox.warning(
                self, &quot;Error&quot;, f&quot;Could not load Color Space Favorites:\n{e}&quot;
            )
        self.save_color_space_button = QPushButton(&quot;Save&quot;)
        self.save_color_space_button.clicked.connect(self.save_color_space_settings)
        color_space_layout.addWidget(self.save_color_space_button, 0, Qt.AlignRight)
        color_space_group.setLayout(color_space_layout)
        main_layout.addWidget(color_space_group)
        main_layout.addSpacing(12)

        # --- Write Presets Section (Placeholder) ---
        write_presets_group = QGroupBox()
        write_presets_layout = QVBoxLayout()
        write_presets_title = QLabel(&quot;Write Presets&quot;)
        write_presets_title.setStyleSheet(&quot;font-weight: bold; font-size: 11pt;&quot;)
        write_presets_layout.addWidget(write_presets_title)
        # Botón Open Editor
        self.open_write_presets_btn = QPushButton(&quot;Open Editor&quot;)
        self.open_write_presets_btn.clicked.connect(
            self.show_write_presets_not_implemented
        )
        write_presets_layout.addWidget(self.open_write_presets_btn, 0, Qt.AlignHCenter)
        write_presets_group.setLayout(write_presets_layout)
        main_layout.addWidget(write_presets_group)
        # ---
        main_layout.addStretch()

    def save_write_focus_settings(self):
        &quot;&quot;&quot;Guarda el nombre del nodo de Write Focus en su archivo .ini.&quot;&quot;&quot;
        config_file_path = wf_get_config_path()
        if not config_file_path:
            debug_print(&quot;Error: No se pudo obtener la ruta para guardar Write Focus.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Write Focus.&quot;,
            )
            return

        new_node_name = self.write_focus_input.text().strip()
        if not new_node_name:
            QMessageBox.warning(
                self, &quot;Input Error&quot;, &quot;Write Focus node name cannot be empty.&quot;
            )
            # Revertir al valor anterior o al por defecto
            try:
                current_node_name = wf_get_node_name_from_config()
                self.write_focus_input.setText(
                    current_node_name or WF_DEFAULT_NODE_NAME
                )
            except Exception:
                self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)
            return

        config = configparser.ConfigParser()
        try:
            # Leer existente para preservar otras secciones/claves
            if os.path.exists(config_file_path):
                config.read(config_file_path)

            if not config.has_section(WF_CONFIG_SECTION):
                config.add_section(WF_CONFIG_SECTION)

            config.set(WF_CONFIG_SECTION, WF_CONFIG_NODE_NAME_KEY, new_node_name)

            with open(config_file_path, &quot;w&quot;) as configfile:
                config.write(configfile)

            debug_print(f&quot;Configuracion de Write Focus guardada: {new_node_name}&quot;)
            QMessageBox.information(self, &quot;Success&quot;, &quot;Write Focus settings saved.&quot;)

        except Exception as e:
            debug_print(f&quot;Error al guardar la configuracion de Write Focus: {e}&quot;)
            QMessageBox.critical(
                self, &quot;Save Error&quot;, f&quot;Could not save Write Focus settings:\n{e}&quot;
            )

    def save_show_flow_settings(self):
        &quot;&quot;&quot;Guarda las credenciales de Show in Flow en su archivo .ini.&quot;&quot;&quot;
        config_file_path = sif_get_config_path()
        if not config_file_path:
            debug_print(&quot;Error: No se pudo obtener la ruta para guardar Show in Flow.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Show in Flow.&quot;,
            )
            return

        new_url = self.site_input.text().strip()
        new_login = self.username_input.text().strip()
        new_password = self.password_input.text()  # No hacer strip a la password

        if not new_url or not new_login or not new_password:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;Show in Flow URL, Login, and Password cannot be empty.&quot;,
            )
            # No revertimos aqui, dejamos que el usuario corrija
            return

        # Llamar a la nueva funcion de guardado que maneja la codificacion
        try:
            success = sif_save_credentials_to_config(new_url, new_login, new_password)
            if success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(self, &quot;Success&quot;, &quot;Show in Flow settings saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Show in Flow settings. Check console for details.&quot;,
                )
        except Exception as e:
            debug_print(f&quot;Error al llamar a save_credentials_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Show in Flow settings:\n{e}&quot;,
            )

    def save_color_space_settings(self):  # Nuevo metodo
        &quot;&quot;&quot;Guarda la lista de Color Space Favorites en su archivo .ini.&quot;&quot;&quot;
        # Re-obtener la ruta por si acaso, pero no forzar creacion/copia aqui
        ini_path = getattr(
            self,
            &quot;colorspace_ini_path&quot;,
            get_colorspace_ini_path(create_if_missing=False),
        )

        if not ini_path:
            debug_print(
                &quot;Error: No se pudo obtener la ruta para guardar Color Space Favs.&quot;
            )
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Color Space Favorites.&quot;,
            )
            return

        # Obtener texto del QTextEdit
        text = self.color_space_edit.toPlainText()
        # Dividir en lineas, quitar espacios y filtrar vacias/solo espacios
        favorites_list = [line.strip() for line in text.split(&quot;\n&quot;) if line.strip()]

        # Usar la funcion importada para guardar
        try:
            success = save_colorspaces_to_ini(ini_path, favorites_list)
            if success:
                debug_print(&quot;Configuracion de Color Space Favorites guardada.&quot;)
                QMessageBox.information(self, &quot;Success&quot;, &quot;Color Space Favorites saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso en la funcion save_colorspaces_to_ini
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Color Space Favorites. Check console for details.&quot;,
                )

        except Exception as e:
            # Captura por si save_colorspaces_to_ini lanza una excepcion inesperada
            debug_print(f&quot;Error inesperado al llamar a save_colorspaces_to_ini: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Color Space Favorites:\n{e}&quot;,
            )

    def save_render_mail_settings(self):
        &quot;&quot;&quot;Guarda los datos de mail de Render Complete en su archivo .ini.&quot;&quot;&quot;
        config_file_path = rc_get_config_path()
        if not config_file_path:
            debug_print(
                &quot;Error: No se pudo obtener la ruta para guardar Render Complete Mail.&quot;
            )
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Render Complete Mail.&quot;,
            )
            return
        from_email = self.render_mail_from_input.text().strip()
        from_password = self.render_mail_pass_input.text()
        to_email = self.render_mail_to_input.text().strip()
        wav_path = self.wav_path_input.text().strip()
        sound_enabled = self.cb_enable_sound.isChecked()
        render_time_enabled = self.cb_enable_render_time.isChecked()
        if not from_email or not from_password or not to_email:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;All mail fields must be filled (From, Password, To).&quot;,
            )
            # No revertimos, dejamos que el usuario corrija
            return
        try:
            # La funcion rc_save_mail_settings_to_config ahora maneja la codificacion interna
            success = rc_save_mail_settings_to_config(
                from_email, from_password, to_email
            )
            # Guardar el path del wav
            wav_success = save_wav_path_to_config(wav_path)
            # Guardar el setting de sonido
            sound_success = save_sound_enabled_to_config(sound_enabled)
            # Guardar el setting de render time
            render_time_success = save_render_time_enabled_to_config(
                render_time_enabled
            )
            if success and wav_success and sound_success and render_time_success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(
                    self, &quot;Success&quot;, &quot;Render Complete Mail settings saved.&quot;
                )
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Render Complete Mail settings. Check console for details.&quot;,
                )
        except Exception as e:
            debug_print(f&quot;Error al llamar a save_mail_settings_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Render Complete Mail settings:\n{e}&quot;,
            )

    def browse_wav_file(self):
        &quot;&quot;&quot;Abre un diálogo para seleccionar un archivo .wav y lo pone en el QLineEdit.&quot;&quot;&quot;
        file_path, _ = QFileDialog.getOpenFileName(
            self, &quot;Select WAV file&quot;, &quot;&quot;, &quot;WAV Files (*.wav)&quot;
        )
        if file_path:
            self.wav_path_input.setText(file_path)
            # Guardar inmediatamente el nuevo path seleccionado
            save_wav_path_to_config(file_path)

    def show_write_presets_not_implemented(self):
        &quot;&quot;&quot;Muestra un mensaje indicando que la función aún no está implementada.&quot;&quot;&quot;
        QMessageBox.information(
            self,
            &quot;Not Implemented&quot;,
            &quot;The Write Presets editor is not yet implemented.\nComing soon!&quot;,
        )


# --- Main Execution ---
if __name__ == &quot;__main__&quot;:
    # Necesario para ejecucion standalone fuera de Nuke
    app = QApplication.instance() or QApplication(sys.argv)

    settings_window = SettingsWindow()
    settings_window.show()

    # Mantener el bucle para ejecucion standalone
    if not QApplication.instance():  # Solo si no estamos en Nuke
        sys.exit(app.exec_())
    # Si estamos en Nuke, no llamamos a sys.exit()
&quot;&quot;&quot;
_____________________________________________________________________________________________________

  LGA_ToolPack_settings v0.43 | Lega
  Configuracion de la herramienta LGA_ToolPack
_____________________________________________________________________________________________________
&quot;&quot;&quot;

import sys
import os
import configparser
import typing  # Importar typing
from typing import Optional, Tuple

from PySide2.QtWidgets import (
    QApplication,
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QGroupBox,
    QLabel,
    QLineEdit,
    QFormLayout,
    QPushButton,
    QTextEdit,  # Importar QTextEdit
    QMessageBox,  # Importar QMessageBox
    QCheckBox,
    QFileDialog,
    QDesktopWidget,
    QFrame,  # &lt;--- Importar QFrame para divisores
)
from PySide2.QtCore import Qt

# Variable global para controlar el debug
DEBUG = False

# Espaciado vertical para divisores horizontales (en pixeles)
LINE_SPACING = 10


# Funcion debug_print
def debug_print(*message):
    if DEBUG:
        print(*message)


# Importar funciones y constantes desde LGA_Write_Focus
# Asumiendo que ambos scripts estan en el mismo directorio o en el sys.path
try:
    from LGA_Write_Focus import (
        get_config_path as wf_get_config_path,  # Renombrar para claridad
        ensure_config_exists as wf_ensure_config_exists,
        get_node_name_from_config as wf_get_node_name_from_config,
        DEFAULT_NODE_NAME as WF_DEFAULT_NODE_NAME,  # Renombrar constante
        CONFIG_SECTION as WF_CONFIG_SECTION,  # Renombrar constante
        CONFIG_NODE_NAME_KEY as WF_CONFIG_NODE_NAME_KEY,  # Renombrar constante
    )
except ImportError as e_wf:
    print(f&quot;Error al importar LGA_Write_Focus.py: {e_wf}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def wf_ensure_config_exists():
        pass

    def wf_get_node_name_from_config() -&gt; str:
        return &quot;Write_Pub&quot;

    def wf_get_config_path() -&gt; typing.Optional[str]:
        return None

    WF_DEFAULT_NODE_NAME = &quot;Write_Pub&quot;
    WF_CONFIG_SECTION = &quot;Settings&quot;
    WF_CONFIG_NODE_NAME_KEY = &quot;node_name&quot;

# --- Importaciones de LGA_showInlFlow ---
try:
    from LGA_showInlFlow import (
        get_config_path as sif_get_config_path,
        ensure_config_exists as sif_ensure_config_exists,
        get_credentials_from_config as sif_get_credentials_from_config,
        save_credentials_to_config as sif_save_credentials_to_config,
    )
except ImportError as e_sif:
    print(f&quot;Error al importar LGA_showInlFlow.py: {e_sif}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def sif_ensure_config_exists():
        pass

    def sif_get_credentials_from_config() -&gt; (
        typing.Tuple[typing.Optional[str], typing.Optional[str], typing.Optional[str]]
    ):
        return None, None, None

    def sif_get_config_path() -&gt; typing.Optional[str]:
        return None

    # Funcion save dummy
    def sif_save_credentials_to_config(url, login, password) -&gt; bool:
        debug_print(
            &quot;Error: LGA_showInlFlow.py no encontrado, no se pueden guardar credenciales.&quot;
        )
        return False


# --- Importaciones de LGA_RnW_ColorSpace_Favs --- Nuevo
try:
    from LGA_RnW_ColorSpace_Favs import (
        get_colorspace_ini_path,
        read_colorspaces_from_ini,
        save_colorspaces_to_ini,
        COLORSPACE_SECTION,  # Importar tambien la constante de seccion
    )
except ImportError as e_csf:
    print(
        f&quot;Error al importar LGA_RnW_ColorSpace_Favs.py: {e_csf}. Funcionalidad limitada.&quot;
    )

    # Definir funciones dummy
    def get_colorspace_ini_path(create_if_missing: bool = True) -&gt; typing.Optional[str]:
        return None

    def read_colorspaces_from_ini(ini_path: typing.Optional[str]) -&gt; typing.List[str]:
        return []

    def save_colorspaces_to_ini(
        ini_path: typing.Optional[str], colorspaces_list: typing.List[str]
    ) -&gt; bool:
        return False

    COLORSPACE_SECTION = &quot;ColorSpaces&quot;

# --- Importaciones de LGA_Render_Complete --- NUEVO
try:
    from LGA_Render_Complete import (
        get_config_path as rc_get_config_path,
        ensure_config_exists as rc_ensure_config_exists,
        get_mail_settings_from_config as rc_get_mail_settings_from_config,
        save_mail_settings_to_config as rc_save_mail_settings_to_config,
        CONFIG_FROM_KEY as RC_CONFIG_FROM_KEY,
        CONFIG_PASS_KEY as RC_CONFIG_PASS_KEY,
        CONFIG_TO_KEY as RC_CONFIG_TO_KEY,
        get_wav_path_from_config,
        save_wav_path_to_config,
        get_sound_enabled_from_config,
        save_sound_enabled_to_config,
        get_render_time_enabled_from_config,
        save_render_time_enabled_to_config,
    )
except ImportError as e_rc:
    print(f&quot;Error al importar LGA_Render_Complete.py: {e_rc}. Funcionalidad limitada.&quot;)

    def rc_ensure_config_exists() -&gt; None:
        pass

    def rc_get_mail_settings_from_config() -&gt; (
        Tuple[Optional[str], Optional[str], Optional[str]]
    ):
        return None, None, None

    def rc_save_mail_settings_to_config(from_email, from_password, to_email) -&gt; bool:
        debug_print(
            &quot;Error: LGA_Render_Complete.py no encontrado, no se pueden guardar settings de mail.&quot;
        )
        return False

    def rc_get_config_path() -&gt; Optional[str]:
        return None

    RC_CONFIG_FROM_KEY = &quot;from_email&quot;
    RC_CONFIG_PASS_KEY = &quot;from_password&quot;
    RC_CONFIG_TO_KEY = &quot;to_email&quot;


class SettingsWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(&quot;LGA ToolPack Settings&quot;)
        self.setMinimumWidth(500)  # Más ancho para la ventana
        self.initUI()
        # Centrar la ventana en la pantalla (horizontal y vertical) DESPUES de show()
        self.show()
        qr = self.frameGeometry()
        cp = QDesktopWidget().availableGeometry().center()
        qr.moveCenter(cp)
        self.move(qr.topLeft())
        self.hide()

    def initUI(self):
        main_layout = QVBoxLayout(self)

        # --- Write Focus Section ---
        write_focus_layout = QVBoxLayout()
        write_focus_title = QLabel(&quot;Write Focus&quot;)
        write_focus_title.setStyleSheet(&quot;font-weight: bold; font-size: 11pt;&quot;)
        write_focus_layout.addWidget(write_focus_title)
        write_focus_form_layout = QFormLayout()
        self.write_focus_input = QLineEdit()
        try:
            wf_ensure_config_exists()
            current_node_name = wf_get_node_name_from_config()
            self.write_focus_input.setText(current_node_name or WF_DEFAULT_NODE_NAME)
        except Exception as e:
            debug_print(f&quot;Error al cargar config de Write Focus: {e}&quot;)
            self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)
        write_focus_form_layout.addRow(
            &quot;Name of the Write Node to Focus:&quot;, self.write_focus_input
        )
        write_focus_layout.addLayout(write_focus_form_layout)
        self.save_write_focus_button = QPushButton(&quot;Save&quot;)
        self.save_write_focus_button.clicked.connect(self.save_write_focus_settings)
        write_focus_layout.addWidget(self.save_write_focus_button, 0, Qt.AlignRight)
        main_layout.addLayout(write_focus_layout)

        # Espaciado antes del divisor
        main_layout.addSpacing(LINE_SPACING)
        # Divisor
        line1 = QFrame()
        line1.setFrameShape(QFrame.HLine)
        line1.setFrameShadow(QFrame.Sunken)
        main_layout.addWidget(line1)
        # Espaciado después del divisor
        main_layout.addSpacing(LINE_SPACING)

        # --- Render Complete Mail Settings Section ---
        render_mail_layout = QVBoxLayout()
        render_mail_title = QLabel(&quot;Render Complete&quot;)
        render_mail_title.setStyleSheet(&quot;font-weight: bold; font-size: 11pt;&quot;)
        render_mail_layout.addWidget(render_mail_title)
        render_mail_form_layout = QFormLayout()
        self.render_mail_from_input = QLineEdit()
        self.render_mail_pass_input = QLineEdit()
        self.render_mail_pass_input.setEchoMode(QLineEdit.Password)
        self.render_mail_to_input = QLineEdit()
        self.render_mail_from_input.setPlaceholderText(&quot;e.g., tuMail@outlook.com&quot;)
        self.render_mail_pass_input.setPlaceholderText(&quot;&quot;)
        self.render_mail_to_input.setPlaceholderText(&quot;e.g., tuMail@gmail.com&quot;)
        try:
            rc_ensure_config_exists()
            from_email, from_password, to_email = rc_get_mail_settings_from_config()
            self.render_mail_from_input.setText(from_email or &quot;&quot;)
            self.render_mail_pass_input.setText(from_password or &quot;&quot;)
            self.render_mail_to_input.setText(to_email or &quot;&quot;)
        except Exception as e:
            debug_print(f&quot;Error al cargar config de Render Complete Mail: {e}&quot;)
        self.cb_enable_render_time = QCheckBox(&quot;Enable render time calculation&quot;)
        self.cb_enable_sound = QCheckBox(&quot;Enable sound notification&quot;)
        try:
            self.cb_enable_render_time.setChecked(get_render_time_enabled_from_config())
        except Exception as e:
            debug_print(f&quot;Error al leer setting de render time: {e}&quot;)
            self.cb_enable_render_time.setChecked(True)
        try:
            self.cb_enable_sound.setChecked(get_sound_enabled_from_config())
        except Exception as e:
            debug_print(f&quot;Error al leer setting de sonido: {e}&quot;)
            self.cb_enable_sound.setChecked(True)
        render_mail_layout.addWidget(self.cb_enable_render_time)

        # Layout horizontal para sonido: checkbox + input + browse
        sound_layout = QHBoxLayout()
        sound_layout.addWidget(self.cb_enable_sound)
        self.wav_path_input = QLineEdit()
        self.wav_path_input.setPlaceholderText(&quot;Select .wav file...&quot;)
        try:
            wav_path = get_wav_path_from_config()
            self.wav_path_input.setText(wav_path)
        except Exception as e:
            debug_print(f&quot;Error al cargar ruta wav: {e}&quot;)
            self.wav_path_input.setText(&quot;&quot;)
        self.wav_browse_btn = QPushButton(&quot;Browse&quot;)
        self.wav_browse_btn.clicked.connect(self.browse_wav_file)
        sound_layout.addWidget(self.wav_path_input)
        sound_layout.addWidget(self.wav_browse_btn)
        render_mail_layout.addLayout(sound_layout)
        # Espaciado antes del texto informativo
        render_mail_layout.addSpacing(10)
        # Texto informativo para la sección de mail
        mail_info_label = QLabel(&quot;Send mail when render is complete info:&quot;)
        mail_info_label.setStyleSheet(&quot;font-weight: bold; margin-bottom: 4px;&quot;)
        render_mail_layout.addWidget(mail_info_label)
        render_mail_form_layout.addRow(&quot;From (Outlook):&quot;, self.render_mail_from_input)
        render_mail_form_layout.addRow(&quot;Password:&quot;, self.render_mail_pass_input)
        render_mail_form_layout.addRow(&quot;To (Recipient):&quot;, self.render_mail_to_input)
        render_mail_layout.addLayout(render_mail_form_layout)
        self.save_render_mail_button = QPushButton(&quot;Save&quot;)
        self.save_render_mail_button.clicked.connect(self.save_render_mail_settings)
        render_mail_layout.addWidget(self.save_render_mail_button, 0, Qt.AlignRight)
        main_layout.addLayout(render_mail_layout)

        main_layout.addSpacing(LINE_SPACING)
        line2 = QFrame()
        line2.setFrameShape(QFrame.HLine)
        line2.setFrameShadow(QFrame.Sunken)
        main_layout.addWidget(line2)
        main_layout.addSpacing(LINE_SPACING)

        # --- Show in Flow Section ---
        show_flow_layout = QVBoxLayout()
        show_flow_title = QLabel(&quot;Show in Flow&quot;)
        show_flow_title.setStyleSheet(&quot;font-weight: bold; font-size: 11pt;&quot;)
        show_flow_layout.addWidget(show_flow_title)
        show_flow_form_layout = QFormLayout()
        self.username_input = QLineEdit()
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.Password)
        self.site_input = QLineEdit()
        self.site_input.setPlaceholderText(&quot;e.g., https://studio.shotgrid.autodesk.com&quot;)
        self.username_input.setPlaceholderText(&quot;e.g., artist@studio.com&quot;)
        self.password_input.setPlaceholderText(&quot;&quot;)
        show_flow_form_layout.addRow(
            &quot;ShotGrid URL:&quot;,
            self.site_input,
        )
        show_flow_form_layout.addRow(&quot;ShotGrid Login:&quot;, self.username_input)
        show_flow_form_layout.addRow(&quot;ShotGrid Password:&quot;, self.password_input)
        try:
            sif_ensure_config_exists()
            sif_url, sif_login, sif_password = sif_get_credentials_from_config()
            self.site_input.setText(sif_url or &quot;&quot;)
            self.username_input.setText(sif_login or &quot;&quot;)
            self.password_input.setText(sif_password or &quot;&quot;)
        except Exception as e:
            debug_print(f&quot;Error al cargar credenciales de Show in Flow: {e}&quot;)
        show_flow_layout.addLayout(show_flow_form_layout)
        self.save_show_flow_button = QPushButton(&quot;Save&quot;)
        self.save_show_flow_button.clicked.connect(self.save_show_flow_settings)
        show_flow_layout.addWidget(self.save_show_flow_button, 0, Qt.AlignRight)
        main_layout.addLayout(show_flow_layout)

        main_layout.addSpacing(LINE_SPACING)
        line3 = QFrame()
        line3.setFrameShape(QFrame.HLine)
        line3.setFrameShadow(QFrame.Sunken)
        main_layout.addWidget(line3)
        main_layout.addSpacing(LINE_SPACING)

        # --- Color Space Favs Section ---
        color_space_layout = QVBoxLayout()
        color_space_title = QLabel(&quot;Color Space Favorites&quot;)
        color_space_title.setStyleSheet(&quot;font-weight: bold; font-size: 11pt;&quot;)
        color_space_layout.addWidget(color_space_title)
        color_space_layout.addWidget(
            QLabel(&quot;Enter favorite OCIO color spaces (one per line):&quot;)
        )
        self.color_space_edit = QTextEdit()
        self.color_space_edit.setPlaceholderText(
            &quot;e.g.,\nOutput - sRGB\nUtility - Raw\nACES - ACEScg&quot;
        )
        self.color_space_edit.setMinimumHeight(80)
        color_space_layout.addWidget(self.color_space_edit)
        try:
            self.colorspace_ini_path = get_colorspace_ini_path(create_if_missing=True)
            if self.colorspace_ini_path:
                fav_list = read_colorspaces_from_ini(self.colorspace_ini_path)
                self.color_space_edit.setText(&quot;\n&quot;.join(fav_list))
            else:
                debug_print(
                    &quot;Advertencia: No se pudo obtener la ruta del INI de ColorSpaces.&quot;
                )
        except Exception as e:
            debug_print(f&quot;Error al cargar Color Space Favs: {e}&quot;)
            QMessageBox.warning(
                self, &quot;Error&quot;, f&quot;Could not load Color Space Favorites:\n{e}&quot;
            )
        self.save_color_space_button = QPushButton(&quot;Save&quot;)
        self.save_color_space_button.clicked.connect(self.save_color_space_settings)
        color_space_layout.addWidget(self.save_color_space_button, 0, Qt.AlignRight)
        main_layout.addLayout(color_space_layout)

        main_layout.addSpacing(LINE_SPACING)
        line4 = QFrame()
        line4.setFrameShape(QFrame.HLine)
        line4.setFrameShadow(QFrame.Sunken)
        main_layout.addWidget(line4)
        main_layout.addSpacing(LINE_SPACING)

        # --- Write Presets Section (Placeholder) ---
        write_presets_layout = QVBoxLayout()
        write_presets_title = QLabel(&quot;Write Presets&quot;)
        write_presets_title.setStyleSheet(&quot;font-weight: bold; font-size: 11pt;&quot;)
        write_presets_layout.addWidget(write_presets_title)
        self.open_write_presets_btn = QPushButton(&quot;Open Editor&quot;)
        self.open_write_presets_btn.clicked.connect(
            self.show_write_presets_not_implemented
        )
        write_presets_layout.addWidget(self.open_write_presets_btn, 0, Qt.AlignHCenter)
        main_layout.addLayout(write_presets_layout)
        main_layout.addStretch()

    def save_write_focus_settings(self):
        &quot;&quot;&quot;Guarda el nombre del nodo de Write Focus en su archivo .ini.&quot;&quot;&quot;
        config_file_path = wf_get_config_path()
        if not config_file_path:
            debug_print(&quot;Error: No se pudo obtener la ruta para guardar Write Focus.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Write Focus.&quot;,
            )
            return

        new_node_name = self.write_focus_input.text().strip()
        if not new_node_name:
            QMessageBox.warning(
                self, &quot;Input Error&quot;, &quot;Write Focus node name cannot be empty.&quot;
            )
            # Revertir al valor anterior o al por defecto
            try:
                current_node_name = wf_get_node_name_from_config()
                self.write_focus_input.setText(
                    current_node_name or WF_DEFAULT_NODE_NAME
                )
            except Exception:
                self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)
            return

        config = configparser.ConfigParser()
        try:
            # Leer existente para preservar otras secciones/claves
            if os.path.exists(config_file_path):
                config.read(config_file_path)

            if not config.has_section(WF_CONFIG_SECTION):
                config.add_section(WF_CONFIG_SECTION)

            config.set(WF_CONFIG_SECTION, WF_CONFIG_NODE_NAME_KEY, new_node_name)

            with open(config_file_path, &quot;w&quot;) as configfile:
                config.write(configfile)

            debug_print(f&quot;Configuracion de Write Focus guardada: {new_node_name}&quot;)
            QMessageBox.information(self, &quot;Success&quot;, &quot;Write Focus settings saved.&quot;)

        except Exception as e:
            debug_print(f&quot;Error al guardar la configuracion de Write Focus: {e}&quot;)
            QMessageBox.critical(
                self, &quot;Save Error&quot;, f&quot;Could not save Write Focus settings:\n{e}&quot;
            )

    def save_show_flow_settings(self):
        &quot;&quot;&quot;Guarda las credenciales de Show in Flow en su archivo .ini.&quot;&quot;&quot;
        config_file_path = sif_get_config_path()
        if not config_file_path:
            debug_print(&quot;Error: No se pudo obtener la ruta para guardar Show in Flow.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Show in Flow.&quot;,
            )
            return

        new_url = self.site_input.text().strip()
        new_login = self.username_input.text().strip()
        new_password = self.password_input.text()  # No hacer strip a la password

        if not new_url or not new_login or not new_password:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;Show in Flow URL, Login, and Password cannot be empty.&quot;,
            )
            # No revertimos aqui, dejamos que el usuario corrija
            return

        # Llamar a la nueva funcion de guardado que maneja la codificacion
        try:
            success = sif_save_credentials_to_config(new_url, new_login, new_password)
            if success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(self, &quot;Success&quot;, &quot;Show in Flow settings saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Show in Flow settings. Check console for details.&quot;,
                )
        except Exception as e:
            debug_print(f&quot;Error al llamar a save_credentials_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Show in Flow settings:\n{e}&quot;,
            )

    def save_color_space_settings(self):  # Nuevo metodo
        &quot;&quot;&quot;Guarda la lista de Color Space Favorites en su archivo .ini.&quot;&quot;&quot;
        # Re-obtener la ruta por si acaso, pero no forzar creacion/copia aqui
        ini_path = getattr(
            self,
            &quot;colorspace_ini_path&quot;,
            get_colorspace_ini_path(create_if_missing=False),
        )

        if not ini_path:
            debug_print(
                &quot;Error: No se pudo obtener la ruta para guardar Color Space Favs.&quot;
            )
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Color Space Favorites.&quot;,
            )
            return

        # Obtener texto del QTextEdit
        text = self.color_space_edit.toPlainText()
        # Dividir en lineas, quitar espacios y filtrar vacias/solo espacios
        favorites_list = [line.strip() for line in text.split(&quot;\n&quot;) if line.strip()]

        # Usar la funcion importada para guardar
        try:
            success = save_colorspaces_to_ini(ini_path, favorites_list)
            if success:
                debug_print(&quot;Configuracion de Color Space Favorites guardada.&quot;)
                QMessageBox.information(self, &quot;Success&quot;, &quot;Color Space Favorites saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso en la funcion save_colorspaces_to_ini
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Color Space Favorites. Check console for details.&quot;,
                )

        except Exception as e:
            # Captura por si save_colorspaces_to_ini lanza una excepcion inesperada
            debug_print(f&quot;Error inesperado al llamar a save_colorspaces_to_ini: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Color Space Favorites:\n{e}&quot;,
            )

    def save_render_mail_settings(self):
        &quot;&quot;&quot;Guarda los datos de mail de Render Complete en su archivo .ini.&quot;&quot;&quot;
        config_file_path = rc_get_config_path()
        if not config_file_path:
            debug_print(
                &quot;Error: No se pudo obtener la ruta para guardar Render Complete Mail.&quot;
            )
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Render Complete Mail.&quot;,
            )
            return
        from_email = self.render_mail_from_input.text().strip()
        from_password = self.render_mail_pass_input.text()
        to_email = self.render_mail_to_input.text().strip()
        wav_path = self.wav_path_input.text().strip()
        sound_enabled = self.cb_enable_sound.isChecked()
        render_time_enabled = self.cb_enable_render_time.isChecked()
        if not from_email or not from_password or not to_email:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;All mail fields must be filled (From, Password, To).&quot;,
            )
            # No revertimos, dejamos que el usuario corrija
            return
        try:
            # La funcion rc_save_mail_settings_to_config ahora maneja la codificacion interna
            success = rc_save_mail_settings_to_config(
                from_email, from_password, to_email
            )
            # Guardar el path del wav
            wav_success = save_wav_path_to_config(wav_path)
            # Guardar el setting de sonido
            sound_success = save_sound_enabled_to_config(sound_enabled)
            # Guardar el setting de render time
            render_time_success = save_render_time_enabled_to_config(
                render_time_enabled
            )
            if success and wav_success and sound_success and render_time_success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(
                    self, &quot;Success&quot;, &quot;Render Complete Mail settings saved.&quot;
                )
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Render Complete Mail settings. Check console for details.&quot;,
                )
        except Exception as e:
            debug_print(f&quot;Error al llamar a save_mail_settings_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Render Complete Mail settings:\n{e}&quot;,
            )

    def browse_wav_file(self):
        &quot;&quot;&quot;Abre un diálogo para seleccionar un archivo .wav y lo pone en el QLineEdit.&quot;&quot;&quot;
        file_path, _ = QFileDialog.getOpenFileName(
            self, &quot;Select WAV file&quot;, &quot;&quot;, &quot;WAV Files (*.wav)&quot;
        )
        if file_path:
            self.wav_path_input.setText(file_path)
            # Guardar inmediatamente el nuevo path seleccionado
            save_wav_path_to_config(file_path)

    def show_write_presets_not_implemented(self):
        &quot;&quot;&quot;Muestra un mensaje indicando que la función aún no está implementada.&quot;&quot;&quot;
        QMessageBox.information(
            self,
            &quot;Not Implemented&quot;,
            &quot;The Write Presets editor is not yet implemented.\nComing soon!&quot;,
        )

    def keyPressEvent(self, event):
        &quot;&quot;&quot;Cerrar la ventana si se presiona ESC.&quot;&quot;&quot;
        if event.key() == Qt.Key_Escape:
            self.close()
        else:
            super().keyPressEvent(event)


# --- Main Execution ---
if __name__ == &quot;__main__&quot;:
    # Necesario para ejecucion standalone fuera de Nuke
    app = QApplication.instance() or QApplication(sys.argv)

    settings_window = SettingsWindow()
    settings_window.show()

    # Mantener el bucle para ejecucion standalone
    if not QApplication.instance():  # Solo si no estamos en Nuke
        sys.exit(app.exec_())
    # Si estamos en Nuke, no llamamos a sys.exit()
&quot;&quot;&quot;
_____________________________________________________________________________________________________

  LGA_ToolPack_settings v0.44 | Lega
  Configuracion de la herramienta LGA_ToolPack
_____________________________________________________________________________________________________
&quot;&quot;&quot;

import sys
import os
import configparser
import typing  # Importar typing
from typing import Optional, Tuple

from PySide2.QtWidgets import (
    QApplication,
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QGroupBox,
    QLabel,
    QLineEdit,
    QFormLayout,
    QPushButton,
    QTextEdit,  # Importar QTextEdit
    QMessageBox,  # Importar QMessageBox
    QCheckBox,
    QFileDialog,
    QDesktopWidget,
    QFrame,  # &lt;--- Importar QFrame para divisores
)
from PySide2.QtCore import Qt

# Variable global para controlar el debug
DEBUG = False

# Espaciado vertical para divisores horizontales (en pixeles)
LINE_SPACING = 10


# Funcion debug_print
def debug_print(*message):
    if DEBUG:
        print(*message)


# Importar funciones y constantes desde LGA_Write_Focus
# Asumiendo que ambos scripts estan en el mismo directorio o en el sys.path
try:
    from LGA_Write_Focus import (
        get_config_path as wf_get_config_path,  # Renombrar para claridad
        ensure_config_exists as wf_ensure_config_exists,
        get_node_name_from_config as wf_get_node_name_from_config,
        DEFAULT_NODE_NAME as WF_DEFAULT_NODE_NAME,  # Renombrar constante
        CONFIG_SECTION as WF_CONFIG_SECTION,  # Renombrar constante
        CONFIG_NODE_NAME_KEY as WF_CONFIG_NODE_NAME_KEY,  # Renombrar constante
    )
except ImportError as e_wf:
    print(f&quot;Error al importar LGA_Write_Focus.py: {e_wf}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def wf_ensure_config_exists():
        pass

    def wf_get_node_name_from_config() -&gt; str:
        return &quot;Write_Pub&quot;

    def wf_get_config_path() -&gt; typing.Optional[str]:
        return None

    WF_DEFAULT_NODE_NAME = &quot;Write_Pub&quot;
    WF_CONFIG_SECTION = &quot;Settings&quot;
    WF_CONFIG_NODE_NAME_KEY = &quot;node_name&quot;

# --- Importaciones de LGA_showInlFlow ---
try:
    from LGA_showInlFlow import (
        get_config_path as sif_get_config_path,
        ensure_config_exists as sif_ensure_config_exists,
        get_credentials_from_config as sif_get_credentials_from_config,
        save_credentials_to_config as sif_save_credentials_to_config,
    )
except ImportError as e_sif:
    print(f&quot;Error al importar LGA_showInlFlow.py: {e_sif}. Funcionalidad limitada.&quot;)

    # Definir funciones dummy y valores por defecto
    def sif_ensure_config_exists():
        pass

    def sif_get_credentials_from_config() -&gt; (
        typing.Tuple[typing.Optional[str], typing.Optional[str], typing.Optional[str]]
    ):
        return None, None, None

    def sif_get_config_path() -&gt; typing.Optional[str]:
        return None

    # Funcion save dummy
    def sif_save_credentials_to_config(url, login, password) -&gt; bool:
        debug_print(
            &quot;Error: LGA_showInlFlow.py no encontrado, no se pueden guardar credenciales.&quot;
        )
        return False


# --- Importaciones de LGA_RnW_ColorSpace_Favs --- Nuevo
try:
    from LGA_RnW_ColorSpace_Favs import (
        get_colorspace_ini_path,
        read_colorspaces_from_ini,
        save_colorspaces_to_ini,
        COLORSPACE_SECTION,  # Importar tambien la constante de seccion
    )
except ImportError as e_csf:
    print(
        f&quot;Error al importar LGA_RnW_ColorSpace_Favs.py: {e_csf}. Funcionalidad limitada.&quot;
    )

    # Definir funciones dummy
    def get_colorspace_ini_path(create_if_missing: bool = True) -&gt; typing.Optional[str]:
        return None

    def read_colorspaces_from_ini(ini_path: typing.Optional[str]) -&gt; typing.List[str]:
        return []

    def save_colorspaces_to_ini(
        ini_path: typing.Optional[str], colorspaces_list: typing.List[str]
    ) -&gt; bool:
        return False

    COLORSPACE_SECTION = &quot;ColorSpaces&quot;

# --- Importaciones de LGA_Render_Complete --- NUEVO
try:
    from LGA_Render_Complete import (
        get_config_path as rc_get_config_path,
        ensure_config_exists as rc_ensure_config_exists,
        get_mail_settings_from_config as rc_get_mail_settings_from_config,
        save_mail_settings_to_config as rc_save_mail_settings_to_config,
        CONFIG_FROM_KEY as RC_CONFIG_FROM_KEY,
        CONFIG_PASS_KEY as RC_CONFIG_PASS_KEY,
        CONFIG_TO_KEY as RC_CONFIG_TO_KEY,
        get_wav_path_from_config,
        save_wav_path_to_config,
        get_sound_enabled_from_config,
        save_sound_enabled_to_config,
        get_render_time_enabled_from_config,
        save_render_time_enabled_to_config,
    )
except ImportError as e_rc:
    print(f&quot;Error al importar LGA_Render_Complete.py: {e_rc}. Funcionalidad limitada.&quot;)

    def rc_ensure_config_exists() -&gt; None:
        pass

    def rc_get_mail_settings_from_config() -&gt; (
        Tuple[Optional[str], Optional[str], Optional[str]]
    ):
        return None, None, None

    def rc_save_mail_settings_to_config(from_email, from_password, to_email) -&gt; bool:
        debug_print(
            &quot;Error: LGA_Render_Complete.py no encontrado, no se pueden guardar settings de mail.&quot;
        )
        return False

    def rc_get_config_path() -&gt; Optional[str]:
        return None

    RC_CONFIG_FROM_KEY = &quot;from_email&quot;
    RC_CONFIG_PASS_KEY = &quot;from_password&quot;
    RC_CONFIG_TO_KEY = &quot;to_email&quot;


class SettingsWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle(&quot;LGA ToolPack Settings&quot;)
        self.setMinimumWidth(500)  # Más ancho para la ventana
        self.initUI()
        # Centrar la ventana en la pantalla (horizontal y vertical) DESPUES de show()
        self.show()
        qr = self.frameGeometry()
        cp = QDesktopWidget().availableGeometry().center()
        qr.moveCenter(cp)
        self.move(qr.topLeft())
        self.hide()

    def initUI(self):
        main_layout = QVBoxLayout(self)

        # --- Write Focus Section ---
        write_focus_layout = QVBoxLayout()
        write_focus_title = QLabel(&quot;Write Focus&quot;)
        write_focus_title.setStyleSheet(&quot;font-weight: bold; font-size: 11pt;&quot;)
        write_focus_layout.addWidget(write_focus_title)
        write_focus_form_layout = QFormLayout()
        self.write_focus_input = QLineEdit()
        try:
            wf_ensure_config_exists()
            current_node_name = wf_get_node_name_from_config()
            self.write_focus_input.setText(current_node_name or WF_DEFAULT_NODE_NAME)
        except Exception as e:
            debug_print(f&quot;Error al cargar config de Write Focus: {e}&quot;)
            self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)
        write_focus_form_layout.addRow(
            &quot;Name of the Write Node to Focus:&quot;, self.write_focus_input
        )
        write_focus_layout.addLayout(write_focus_form_layout)
        self.save_write_focus_button = QPushButton(&quot;Save&quot;)
        self.save_write_focus_button.clicked.connect(self.save_write_focus_settings)
        write_focus_layout.addWidget(self.save_write_focus_button, 0, Qt.AlignRight)
        main_layout.addLayout(write_focus_layout)

        # Espaciado antes del divisor
        main_layout.addSpacing(LINE_SPACING)
        # Divisor
        line1 = QFrame()
        line1.setFrameShape(QFrame.HLine)
        line1.setFrameShadow(QFrame.Sunken)
        main_layout.addWidget(line1)
        # Espaciado después del divisor
        main_layout.addSpacing(LINE_SPACING)

        # --- Render Complete Mail Settings Section ---
        render_mail_layout = QVBoxLayout()
        render_mail_title = QLabel(&quot;Render Complete&quot;)
        render_mail_title.setStyleSheet(&quot;font-weight: bold; font-size: 11pt;&quot;)
        render_mail_layout.addWidget(render_mail_title)
        render_mail_form_layout = QFormLayout()
        self.render_mail_from_input = QLineEdit()
        self.render_mail_pass_input = QLineEdit()
        self.render_mail_pass_input.setEchoMode(QLineEdit.Password)
        self.render_mail_to_input = QLineEdit()
        self.render_mail_from_input.setPlaceholderText(&quot;e.g., tuMail@outlook.com&quot;)
        self.render_mail_pass_input.setPlaceholderText(&quot;&quot;)
        self.render_mail_to_input.setPlaceholderText(&quot;e.g., tuMail@gmail.com&quot;)
        try:
            rc_ensure_config_exists()
            from_email, from_password, to_email = rc_get_mail_settings_from_config()
            self.render_mail_from_input.setText(from_email or &quot;&quot;)
            self.render_mail_pass_input.setText(from_password or &quot;&quot;)
            self.render_mail_to_input.setText(to_email or &quot;&quot;)
        except Exception as e:
            debug_print(f&quot;Error al cargar config de Render Complete Mail: {e}&quot;)
        self.cb_enable_render_time = QCheckBox(&quot;Enable render time calculation&quot;)
        self.cb_enable_sound = QCheckBox(&quot;Enable sound notification&quot;)
        try:
            self.cb_enable_render_time.setChecked(get_render_time_enabled_from_config())
        except Exception as e:
            debug_print(f&quot;Error al leer setting de render time: {e}&quot;)
            self.cb_enable_render_time.setChecked(True)
        try:
            self.cb_enable_sound.setChecked(get_sound_enabled_from_config())
        except Exception as e:
            debug_print(f&quot;Error al leer setting de sonido: {e}&quot;)
            self.cb_enable_sound.setChecked(True)
        render_mail_layout.addWidget(self.cb_enable_render_time)

        # Layout horizontal para sonido: checkbox + input + browse
        sound_layout = QHBoxLayout()
        sound_layout.addWidget(self.cb_enable_sound)
        self.wav_path_input = QLineEdit()
        self.wav_path_input.setPlaceholderText(&quot;Select .wav file...&quot;)
        try:
            wav_path = get_wav_path_from_config()
            self.wav_path_input.setText(wav_path)
        except Exception as e:
            debug_print(f&quot;Error al cargar ruta wav: {e}&quot;)
            self.wav_path_input.setText(&quot;&quot;)
        self.wav_browse_btn = QPushButton(&quot;Browse&quot;)
        self.wav_browse_btn.clicked.connect(self.browse_wav_file)
        sound_layout.addWidget(self.wav_path_input)
        sound_layout.addWidget(self.wav_browse_btn)
        render_mail_layout.addLayout(sound_layout)
        # Espaciado antes del texto informativo
        render_mail_layout.addSpacing(10)
        # Texto informativo para la sección de mail
        mail_info_label = QLabel(&quot;Send mail when render is complete info:&quot;)
        mail_info_label.setStyleSheet(&quot;font-weight: bold; margin-bottom: 4px;&quot;)
        render_mail_layout.addWidget(mail_info_label)
        render_mail_form_layout.addRow(&quot;From (Outlook):&quot;, self.render_mail_from_input)
        render_mail_form_layout.addRow(&quot;Password:&quot;, self.render_mail_pass_input)
        render_mail_form_layout.addRow(&quot;To (Recipient):&quot;, self.render_mail_to_input)
        render_mail_layout.addLayout(render_mail_form_layout)
        self.save_render_mail_button = QPushButton(&quot;Save&quot;)
        self.save_render_mail_button.clicked.connect(self.save_render_mail_settings)
        render_mail_layout.addWidget(self.save_render_mail_button, 0, Qt.AlignRight)
        main_layout.addLayout(render_mail_layout)

        main_layout.addSpacing(LINE_SPACING)
        line2 = QFrame()
        line2.setFrameShape(QFrame.HLine)
        line2.setFrameShadow(QFrame.Sunken)
        main_layout.addWidget(line2)
        main_layout.addSpacing(LINE_SPACING)

        # --- Show in Flow Section ---
        show_flow_layout = QVBoxLayout()
        show_flow_title = QLabel(&quot;Show in Flow&quot;)
        show_flow_title.setStyleSheet(&quot;font-weight: bold; font-size: 11pt;&quot;)
        show_flow_layout.addWidget(show_flow_title)
        show_flow_form_layout = QFormLayout()
        self.username_input = QLineEdit()
        self.password_input = QLineEdit()
        self.password_input.setEchoMode(QLineEdit.Password)
        self.site_input = QLineEdit()
        self.site_input.setPlaceholderText(&quot;e.g., https://studio.shotgrid.autodesk.com&quot;)
        self.username_input.setPlaceholderText(&quot;e.g., artist@studio.com&quot;)
        self.password_input.setPlaceholderText(&quot;&quot;)
        show_flow_form_layout.addRow(
            &quot;ShotGrid URL:&quot;,
            self.site_input,
        )
        show_flow_form_layout.addRow(&quot;ShotGrid Login:&quot;, self.username_input)
        show_flow_form_layout.addRow(&quot;ShotGrid Password:&quot;, self.password_input)
        try:
            sif_ensure_config_exists()
            sif_url, sif_login, sif_password = sif_get_credentials_from_config()
            self.site_input.setText(sif_url or &quot;&quot;)
            self.username_input.setText(sif_login or &quot;&quot;)
            self.password_input.setText(sif_password or &quot;&quot;)
        except Exception as e:
            debug_print(f&quot;Error al cargar credenciales de Show in Flow: {e}&quot;)
        show_flow_layout.addLayout(show_flow_form_layout)
        self.save_show_flow_button = QPushButton(&quot;Save&quot;)
        self.save_show_flow_button.clicked.connect(self.save_show_flow_settings)
        show_flow_layout.addWidget(self.save_show_flow_button, 0, Qt.AlignRight)
        main_layout.addLayout(show_flow_layout)

        main_layout.addSpacing(LINE_SPACING)
        line3 = QFrame()
        line3.setFrameShape(QFrame.HLine)
        line3.setFrameShadow(QFrame.Sunken)
        main_layout.addWidget(line3)
        main_layout.addSpacing(LINE_SPACING)

        # --- Color Space Favs Section ---
        color_space_layout = QVBoxLayout()
        color_space_title = QLabel(&quot;Color Space Favorites&quot;)
        color_space_title.setStyleSheet(&quot;font-weight: bold; font-size: 11pt;&quot;)
        color_space_layout.addWidget(color_space_title)
        color_space_layout.addWidget(
            QLabel(&quot;Enter favorite OCIO color spaces (one per line):&quot;)
        )
        self.color_space_edit = QTextEdit()
        self.color_space_edit.setPlaceholderText(
            &quot;e.g.,\nOutput - sRGB\nUtility - Raw\nACES - ACEScg&quot;
        )
        self.color_space_edit.setMinimumHeight(80)
        color_space_layout.addWidget(self.color_space_edit)
        try:
            self.colorspace_ini_path = get_colorspace_ini_path(create_if_missing=True)
            if self.colorspace_ini_path:
                fav_list = read_colorspaces_from_ini(self.colorspace_ini_path)
                self.color_space_edit.setText(&quot;\n&quot;.join(fav_list))
            else:
                debug_print(
                    &quot;Advertencia: No se pudo obtener la ruta del INI de ColorSpaces.&quot;
                )
        except Exception as e:
            debug_print(f&quot;Error al cargar Color Space Favs: {e}&quot;)
            QMessageBox.warning(
                self, &quot;Error&quot;, f&quot;Could not load Color Space Favorites:\n{e}&quot;
            )
        self.save_color_space_button = QPushButton(&quot;Save&quot;)
        self.save_color_space_button.clicked.connect(self.save_color_space_settings)
        color_space_layout.addWidget(self.save_color_space_button, 0, Qt.AlignRight)
        main_layout.addLayout(color_space_layout)

        main_layout.addSpacing(LINE_SPACING)
        line4 = QFrame()
        line4.setFrameShape(QFrame.HLine)
        line4.setFrameShadow(QFrame.Sunken)
        main_layout.addWidget(line4)
        main_layout.addSpacing(LINE_SPACING)

        # --- Write Presets Section (Placeholder) ---
        write_presets_layout = QVBoxLayout()
        write_presets_title = QLabel(&quot;Write Presets&quot;)
        write_presets_title.setStyleSheet(&quot;font-weight: bold; font-size: 11pt;&quot;)
        write_presets_layout.addWidget(write_presets_title)
        self.open_write_presets_btn = QPushButton(&quot;Open Editor&quot;)
        self.open_write_presets_btn.clicked.connect(
            self.show_write_presets_not_implemented
        )
        write_presets_layout.addWidget(self.open_write_presets_btn, 0, Qt.AlignHCenter)
        main_layout.addLayout(write_presets_layout)
        main_layout.addStretch()

    def save_write_focus_settings(self):
        &quot;&quot;&quot;Guarda el nombre del nodo de Write Focus en su archivo .ini.&quot;&quot;&quot;
        config_file_path = wf_get_config_path()
        if not config_file_path:
            debug_print(&quot;Error: No se pudo obtener la ruta para guardar Write Focus.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Write Focus.&quot;,
            )
            return

        new_node_name = self.write_focus_input.text().strip()
        if not new_node_name:
            QMessageBox.warning(
                self, &quot;Input Error&quot;, &quot;Write Focus node name cannot be empty.&quot;
            )
            # Revertir al valor anterior o al por defecto
            try:
                current_node_name = wf_get_node_name_from_config()
                self.write_focus_input.setText(
                    current_node_name or WF_DEFAULT_NODE_NAME
                )
            except Exception:
                self.write_focus_input.setText(WF_DEFAULT_NODE_NAME)
            return

        config = configparser.ConfigParser()
        try:
            # Leer existente para preservar otras secciones/claves
            if os.path.exists(config_file_path):
                config.read(config_file_path)

            if not config.has_section(WF_CONFIG_SECTION):
                config.add_section(WF_CONFIG_SECTION)

            config.set(WF_CONFIG_SECTION, WF_CONFIG_NODE_NAME_KEY, new_node_name)

            with open(config_file_path, &quot;w&quot;) as configfile:
                config.write(configfile)

            debug_print(f&quot;Configuracion de Write Focus guardada: {new_node_name}&quot;)
            QMessageBox.information(self, &quot;Success&quot;, &quot;Write Focus settings saved.&quot;)

        except Exception as e:
            debug_print(f&quot;Error al guardar la configuracion de Write Focus: {e}&quot;)
            QMessageBox.critical(
                self, &quot;Save Error&quot;, f&quot;Could not save Write Focus settings:\n{e}&quot;
            )

    def save_show_flow_settings(self):
        &quot;&quot;&quot;Guarda las credenciales de Show in Flow en su archivo .ini.&quot;&quot;&quot;
        config_file_path = sif_get_config_path()
        if not config_file_path:
            debug_print(&quot;Error: No se pudo obtener la ruta para guardar Show in Flow.&quot;)
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Show in Flow.&quot;,
            )
            return

        new_url = self.site_input.text().strip()
        new_login = self.username_input.text().strip()
        new_password = self.password_input.text()  # No hacer strip a la password

        if not new_url or not new_login or not new_password:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;Show in Flow URL, Login, and Password cannot be empty.&quot;,
            )
            # No revertimos aqui, dejamos que el usuario corrija
            return

        # Llamar a la nueva funcion de guardado que maneja la codificacion
        try:
            success = sif_save_credentials_to_config(new_url, new_login, new_password)
            if success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(self, &quot;Success&quot;, &quot;Show in Flow settings saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Show in Flow settings. Check console for details.&quot;,
                )
        except Exception as e:
            debug_print(f&quot;Error al llamar a save_credentials_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Show in Flow settings:\n{e}&quot;,
            )

    def save_color_space_settings(self):  # Nuevo metodo
        &quot;&quot;&quot;Guarda la lista de Color Space Favorites en su archivo .ini.&quot;&quot;&quot;
        # Re-obtener la ruta por si acaso, pero no forzar creacion/copia aqui
        ini_path = getattr(
            self,
            &quot;colorspace_ini_path&quot;,
            get_colorspace_ini_path(create_if_missing=False),
        )

        if not ini_path:
            debug_print(
                &quot;Error: No se pudo obtener la ruta para guardar Color Space Favs.&quot;
            )
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Color Space Favorites.&quot;,
            )
            return

        # Obtener texto del QTextEdit
        text = self.color_space_edit.toPlainText()
        # Dividir en lineas, quitar espacios y filtrar vacias/solo espacios
        favorites_list = [line.strip() for line in text.split(&quot;\n&quot;) if line.strip()]

        # Usar la funcion importada para guardar
        try:
            success = save_colorspaces_to_ini(ini_path, favorites_list)
            if success:
                debug_print(&quot;Configuracion de Color Space Favorites guardada.&quot;)
                QMessageBox.information(self, &quot;Success&quot;, &quot;Color Space Favorites saved.&quot;)
            else:
                # El error especifico ya deberia haberse impreso en la funcion save_colorspaces_to_ini
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Color Space Favorites. Check console for details.&quot;,
                )

        except Exception as e:
            # Captura por si save_colorspaces_to_ini lanza una excepcion inesperada
            debug_print(f&quot;Error inesperado al llamar a save_colorspaces_to_ini: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Color Space Favorites:\n{e}&quot;,
            )

    def save_render_mail_settings(self):
        &quot;&quot;&quot;Guarda los datos de mail de Render Complete en su archivo .ini.&quot;&quot;&quot;
        config_file_path = rc_get_config_path()
        if not config_file_path:
            debug_print(
                &quot;Error: No se pudo obtener la ruta para guardar Render Complete Mail.&quot;
            )
            QMessageBox.critical(
                self,
                &quot;Error&quot;,
                &quot;Could not determine the configuration file path for Render Complete Mail.&quot;,
            )
            return
        from_email = self.render_mail_from_input.text().strip()
        from_password = self.render_mail_pass_input.text()
        to_email = self.render_mail_to_input.text().strip()
        wav_path = self.wav_path_input.text().strip()
        sound_enabled = self.cb_enable_sound.isChecked()
        render_time_enabled = self.cb_enable_render_time.isChecked()
        if not from_email or not from_password or not to_email:
            QMessageBox.warning(
                self,
                &quot;Input Error&quot;,
                &quot;All mail fields must be filled (From, Password, To).&quot;,
            )
            # No revertimos, dejamos que el usuario corrija
            return
        try:
            # La funcion rc_save_mail_settings_to_config ahora maneja la codificacion interna
            success = rc_save_mail_settings_to_config(
                from_email, from_password, to_email
            )
            # Guardar el path del wav
            wav_success = save_wav_path_to_config(wav_path)
            # Guardar el setting de sonido
            sound_success = save_sound_enabled_to_config(sound_enabled)
            # Guardar el setting de render time
            render_time_success = save_render_time_enabled_to_config(
                render_time_enabled
            )
            if success and wav_success and sound_success and render_time_success:
                # El mensaje de exito ya se imprime en la funcion save
                QMessageBox.information(
                    self, &quot;Success&quot;, &quot;Render Complete Mail settings saved.&quot;
                )
            else:
                # El error especifico ya deberia haberse impreso
                QMessageBox.critical(
                    self,
                    &quot;Save Error&quot;,
                    &quot;Could not save Render Complete Mail settings. Check console for details.&quot;,
                )
        except Exception as e:
            debug_print(f&quot;Error al llamar a save_mail_settings_to_config: {e}&quot;)
            QMessageBox.critical(
                self,
                &quot;Save Error&quot;,
                f&quot;Unexpected error saving Render Complete Mail settings:\n{e}&quot;,
            )

    def browse_wav_file(self):
        &quot;&quot;&quot;Abre un diálogo para seleccionar un archivo .wav y lo pone en el QLineEdit.&quot;&quot;&quot;
        file_path, _ = QFileDialog.getOpenFileName(
            self, &quot;Select WAV file&quot;, &quot;&quot;, &quot;WAV Files (*.wav)&quot;
        )
        if file_path:
            self.wav_path_input.setText(file_path)
            # Guardar inmediatamente el nuevo path seleccionado
            save_wav_path_to_config(file_path)

    def show_write_presets_not_implemented(self):
        &quot;&quot;&quot;Muestra un mensaje indicando que la función aún no está implementada.&quot;&quot;&quot;
        QMessageBox.information(
            self,
            &quot;Not Implemented&quot;,
            &quot;The Write Presets editor is not yet implemented.\nComing soon!&quot;,
        )

    def keyPressEvent(self, event):
        &quot;&quot;&quot;Cerrar la ventana si se presiona ESC.&quot;&quot;&quot;
        if event.key() == Qt.Key_Escape:
            self.close()
        else:
            super().keyPressEvent(event)


# --- Main Execution ---
if __name__ == &quot;__main__&quot;:
    # Necesario para ejecucion standalone fuera de Nuke
    app = QApplication.instance() or QApplication(sys.argv)

    settings_window = SettingsWindow()
    settings_window.show()

    # Mantener el bucle para ejecucion standalone
    if not QApplication.instance():  # Solo si no estamos en Nuke
        sys.exit(app.exec_())
    # Si estamos en Nuke, no llamamos a sys.exit()
import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_ToolPack_settings
importlib.reload(LGA_ToolPack_settings)&quot;&quot;&quot;
_____________________________________________________________________________________________________

  LGA_ToolPack_settings_ShotName v0.1 | Lega
  Configuracion de la nomenclatura de archivos para LGA_ToolPack.
_____________________________________________________________________________________________________
&quot;&quot;&quot;

import sys
from PySide2.QtWidgets import (
    QApplication,
    QWidget,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QGroupBox,
    QFormLayout,
    QDesktopWidget,
    QMessageBox,
)
from PySide2.QtCore import Qt

# Variable global para controlar el debug (si se necesita en el futuro)
DEBUG = False

# --- Instancia global para la ventana de ShotName Settings ---
shotname_window_instance = None


# Funcion debug_print (si se necesita en el futuro)
def debug_print(*message):
    if DEBUG:
        print(*message)


class ShotNameSettingsWindow(QWidget):
    &quot;&quot;&quot;Ventana para configurar la nomenclatura de archivos de Nuke.&quot;&quot;&quot;

    def __init__(self, parent=None):
        super().__init__(parent)  # Pasar parent al constructor base
        self.setWindowTitle(&quot;LGA Show in Flow - Shot Naming Settings&quot;)
        self.setMinimumWidth(550)  # Ajustar ancho segun diseno
        self.initUI()
        self.center_window()

    def center_window(self):
        &quot;&quot;&quot;Centra la ventana en la pantalla.&quot;&quot;&quot;
        qr = self.frameGeometry()
        cp = QDesktopWidget().availableGeometry().center()
        qr.moveCenter(cp)
        self.move(qr.topLeft())

    def initUI(self):
        main_layout = QVBoxLayout(self)

        # --- 1. Filename Pattern Structure --- #
        pattern_group = QGroupBox(&quot;1. Filename Pattern Structure&quot;)
        pattern_layout = QVBoxLayout()

        pattern_desc1 = QLabel(
            &quot;Define the structure of your Nuke script filenames using predefined\n&quot;
            &quot;tags separated by underscores (_). Do not include the version suffix\n&quot;
            &quot;(_vXX) or the file extension (.nk).&quot;
        )
        pattern_desc2 = QLabel(
            &quot;&lt;b&gt;Available tags:&lt;/b&gt; Project, Sequence, Shot, Task, Version, Extra.&lt;br&gt;&quot;
            &quot;Ensure 'Project' and 'Shot' tags are included. 'Extra' can represent\n&quot;
            &quot;one or more optional parts. Define the full pattern structure, as\n&quot;
            &quot;other LGA tools might use all parts.&quot;
        )
        pattern_desc2.setStyleSheet(&quot;margin-top: 5px;&quot;)

        self.pattern_input = QLineEdit()
        self.pattern_input.setPlaceholderText(&quot;e.g., Project_Sequence_Shot_Extra_Task&quot;)

        pattern_example = QLabel(
            &quot;&lt;i&gt;*Example Breakdown: If your file is 'MYPROJ_SQ010_SH020_comp_v01.nk',&lt;br&gt;&quot;
            &quot;your pattern might be: Project_Sequence_Shot_Task&lt;/i&gt;&quot;
        )
        pattern_example.setStyleSheet(&quot;margin-top: 5px; font-size: 9pt; color: grey;&quot;)

        pattern_layout.addWidget(pattern_desc1)
        pattern_layout.addWidget(pattern_desc2)
        pattern_layout.addWidget(self.pattern_input)
        pattern_layout.addWidget(pattern_example)
        pattern_group.setLayout(pattern_layout)
        main_layout.addWidget(pattern_group)

        # --- 2. Shot Code Composition --- #
        shotcode_group = QGroupBox(&quot;2. Shot Code Composition&quot;)
        shotcode_layout = QVBoxLayout()

        shotcode_desc = QLabel(
            &quot;Write the tags from your pattern (above), separated by underscores (_),\n&quot;
            &quot;that combine to form the &lt;b&gt;exact Shot Code&lt;/b&gt; used in Flow's 'Shot'\n&quot;
            &quot;entity 'code' field.&quot;
        )

        self.shotcode_input = QLineEdit()
        self.shotcode_input.setPlaceholderText(&quot;e.g., Sequence_Shot&quot;)

        shotcode_examples = QLabel(
            &quot;&lt;i&gt;*Examples:*&lt;br&gt;&quot;
            &quot;- If Flow Code is 'SQ010_SH020' -&gt; Write: Sequence_Shot&lt;br&gt;&quot;
            &quot;- If Flow Code is 'MYPROJ_SH020' -&gt; Write: Project_Shot&lt;br&gt;&quot;
            &quot;- If Flow Code is just 'SH020' -&gt; Write: Shot&lt;/i&gt;&quot;
        )
        shotcode_examples.setStyleSheet(&quot;margin-top: 5px; font-size: 9pt; color: grey;&quot;)

        shotcode_layout.addWidget(shotcode_desc)
        shotcode_layout.addWidget(self.shotcode_input)
        shotcode_layout.addWidget(shotcode_examples)
        shotcode_group.setLayout(shotcode_layout)
        main_layout.addWidget(shotcode_group)

        # --- 3. Target Flow Task Name --- #
        taskname_group = QGroupBox(&quot;3. Target Flow Task Name&quot;)
        taskname_layout = QVBoxLayout()

        taskname_desc = QLabel(
            &quot;Enter the exact name (case-sensitive) of the Task to open in Flow.\n&quot;
            &quot;This must match the 'content' field of the 'Task' entity.&lt;br&gt;&quot;
            &quot;(This is often 'Comp' for Nuke scripts).&quot;  # Separar linea
        )

        self.taskname_input = QLineEdit()
        self.taskname_input.setPlaceholderText(&quot;Comp&quot;)

        taskname_layout.addWidget(taskname_desc)
        taskname_layout.addWidget(self.taskname_input)
        taskname_group.setLayout(taskname_layout)
        main_layout.addWidget(taskname_group)

        # Separador y Botones
        main_layout.addStretch()  # Empuja botones abajo

        button_layout = QHBoxLayout()
        button_layout.addStretch()  # Empuja botones a la derecha
        self.save_button = QPushButton(&quot;Save Settings&quot;)
        self.cancel_button = QPushButton(&quot;Cancel&quot;)

        # Conectar senales (por ahora, solo cierran o muestran mensaje)
        self.save_button.clicked.connect(
            self.save_settings
        )  # Cambiado a self.save_settings
        self.cancel_button.clicked.connect(self.close)  # Cancelar simplemente cierra

        button_layout.addWidget(self.save_button)
        button_layout.addWidget(self.cancel_button)
        main_layout.addLayout(button_layout)

        # Cargar settings iniciales (placeholder)
        self.load_initial_settings()

    def load_initial_settings(self):
        &quot;&quot;&quot;Carga los settings guardados (funcion placeholder).&quot;&quot;&quot;
        # TODO: Implementar la carga real desde un archivo de configuracion
        # Por ahora, podemos poner valores por defecto o dejar los placeholders
        # self.pattern_input.setText(&quot;Project_Sequence_Shot_Task&quot;)
        # self.shotcode_input.setText(&quot;Sequence_Shot&quot;)
        # self.taskname_input.setText(&quot;Comp&quot;)
        pass

    def save_settings(self):
        &quot;&quot;&quot;Guarda los settings (funcion placeholder).&quot;&quot;&quot;
        # TODO: Implementar la logica de guardado real
        pattern = self.pattern_input.text().strip()
        shotcode = self.shotcode_input.text().strip()
        taskname = self.taskname_input.text().strip()

        # Validacion basica (se puede mejorar)
        if not pattern or not shotcode or not taskname:
            QMessageBox.warning(self, &quot;Input Error&quot;, &quot;All fields are required.&quot;)
            return

        # Mensaje temporal mientras no se implementa el guardado
        QMessageBox.information(
            self, &quot;Not Implemented&quot;, &quot;Save functionality is not yet implemented.&quot;
        )
        print(f&quot;DEBUG: Pattern: {pattern}&quot;)
        print(f&quot;DEBUG: Shot Code Composition: {shotcode}&quot;)
        print(f&quot;DEBUG: Task Name: {taskname}&quot;)
        # self.close() # Opcional: cerrar despues de guardar

    def keyPressEvent(self, event):
        &quot;&quot;&quot;Cerrar la ventana si se presiona ESC.&quot;&quot;&quot;
        if event.key() == Qt.Key_Escape:
            self.close()
        else:
            super().keyPressEvent(event)


def main(parent=None):
    &quot;&quot;&quot;Funcion principal para abrir la ventana de ShotName Settings y mantenerla viva.&quot;&quot;&quot;
    global shotname_window_instance
    app = QApplication.instance() or QApplication(sys.argv)
    if shotname_window_instance is None or not shotname_window_instance.isVisible():
        shotname_window_instance = ShotNameSettingsWindow(parent=parent)
        shotname_window_instance.show()
    else:
        shotname_window_instance.raise_()
        shotname_window_instance.activateWindow()


# --- Main Execution ---
if __name__ == &quot;__main__&quot;:
    # Necesario para ejecucion standalone fuera de Nuke
    main()
import nuke
undo = nuke.Undo()
undo.end()

import importlib
import LGA_writePresets
importlib.reload(LGA_writePresets)# Version que descarga todas las versiones y notas asociadas a las tareas asignadas al usuario
# v03: solo muestra las que tuvieron cambios desde una fecha determinada

import os
import shotgun_api3

# Recuperar datos de autenticacion de las variables de entorno
url = os.environ.get(&quot;SHOTGRID_URL&quot;)
login = os.environ.get(&quot;SHOTGRID_LOGIN&quot;)
password = os.environ.get(&quot;SHOTGRID_PASSWORD&quot;)

# Crear una instancia de la API de ShotGrid usando login y password
sg = shotgun_api3.Shotgun(url, login=login, password=password)


def get_assigned_tasks(sg, user_login, min_date=None):
    filters = [
        [&quot;task_assignees.HumanUser.login&quot;, &quot;is&quot;, user_login],
        [&quot;sg_status_list&quot;, &quot;is_not&quot;, &quot;fin&quot;],
    ]

    # Añadir filtros de fecha si se especifica una fecha mínima
    if min_date:
        date_filter = {
            &quot;filter_operator&quot;: &quot;any&quot;,
            &quot;filters&quot;: [
                [&quot;created_at&quot;, &quot;greater_than&quot;, min_date],
                [&quot;updated_at&quot;, &quot;greater_than&quot;, min_date],
            ],
        }
        filters.append(date_filter)

    # Añadir campos para versiones y notas
    fields = [
        &quot;id&quot;,
        &quot;content&quot;,
        &quot;sg_description&quot;,
        &quot;sg_status_list&quot;,
        &quot;entity&quot;,
        &quot;entity.Shot.code&quot;,
        &quot;entity.Shot.description&quot;,
        &quot;entity.Shot.sg_status_list&quot;,
        &quot;project.Project.name&quot;,
        &quot;project.Project.sg_status&quot;,
        &quot;versions&quot;,  # Versiones asociadas a la tarea
        &quot;notes&quot;,  # Notas asociadas a la tarea
        &quot;task_assignees&quot;,
        &quot;task_reviewers&quot;,  # Campo para reviewers
    ]
    tasks = sg.find(&quot;Task&quot;, filters, fields)
    for t in tasks:
        t[&quot;user_role&quot;] = &quot;Artista&quot;
    return tasks


def get_reviewer_tasks(sg, user_login, min_date=None):
    filters = [
        [&quot;task_reviewers.HumanUser.login&quot;, &quot;is&quot;, user_login],
        [&quot;sg_status_list&quot;, &quot;is_not&quot;, &quot;fin&quot;],
    ]
    if min_date:
        date_filter = {
            &quot;filter_operator&quot;: &quot;any&quot;,
            &quot;filters&quot;: [
                [&quot;created_at&quot;, &quot;greater_than&quot;, min_date],
                [&quot;updated_at&quot;, &quot;greater_than&quot;, min_date],
            ],
        }
        filters.append(date_filter)
    fields = [
        &quot;id&quot;,
        &quot;content&quot;,
        &quot;sg_description&quot;,
        &quot;sg_status_list&quot;,
        &quot;entity&quot;,
        &quot;entity.Shot.code&quot;,
        &quot;entity.Shot.description&quot;,
        &quot;entity.Shot.sg_status_list&quot;,
        &quot;project.Project.name&quot;,
        &quot;project.Project.sg_status&quot;,
        &quot;versions&quot;,
        &quot;notes&quot;,
        &quot;task_assignees&quot;,
        &quot;task_reviewers&quot;,
    ]
    tasks = sg.find(&quot;Task&quot;, filters, fields)
    for t in tasks:
        t[&quot;user_role&quot;] = &quot;Reviewer&quot;
    return tasks


def find_latest_version_for_shot(sg, shot_id):
    # Buscar la última versión asociada al shot
    filters = [[&quot;entity&quot;, &quot;is&quot;, {&quot;type&quot;: &quot;Shot&quot;, &quot;id&quot;: shot_id}]]
    fields = [&quot;id&quot;, &quot;code&quot;, &quot;sg_status_list&quot;, &quot;description&quot;, &quot;created_at&quot;, &quot;user&quot;]
    # Ordenar por fecha de creación descendente y limitar a 1 resultado
    return sg.find_one(
        &quot;Version&quot;, filters, fields, [{&quot;field_name&quot;: &quot;created_at&quot;, &quot;direction&quot;: &quot;desc&quot;}]
    )


def print_task_info(task, sg):
    print(f&quot;\nProject: {task.get('project.Project.name', 'No project available')}&quot;)
    print(
        f&quot;Project Status: {task.get('project.Project.sg_status', 'No status available')}&quot;
    )
    print(f&quot;Shot: {task.get('entity.Shot.code', 'No shot available')}&quot;)
    print(
        f&quot;Shot Status: {task.get('entity.Shot.sg_status_list', 'No status available')}&quot;
    )
    print(f&quot;Task: {task['content']}&quot;)
    print(f&quot;Task Status: {task['sg_status_list']}&quot;)
    print(
        f&quot;Description: {task.get('entity.Shot.description', 'No description available')}&quot;
    )
    print(f&quot;Rol: {task.get('user_role', 'Desconocido')}&quot;)

    # Obtener la última versión asociada al shot
    if task.get(&quot;entity&quot;):
        shot_id = task[&quot;entity&quot;][&quot;id&quot;]
        version = find_latest_version_for_shot(sg, shot_id)

        if version:
            print(&quot;\nÚltima versión:&quot;)
            print(f&quot;  - Version SG: {version.get('code', 'No version code')}&quot;)
            print(f&quot;    Status: {version.get('sg_status_list', 'No status')}&quot;)
            print(f&quot;    Description: {version.get('description', 'No description')}&quot;)
            print(f&quot;    Created At: {version.get('created_at', 'No date available')}&quot;)
            print(
                f&quot;    User: {version['user']['name'] if version.get('user') else 'No user available'}&quot;
            )

            # Obtener notas de la versión
            notes = sg.find(
                &quot;Note&quot;,
                [[&quot;note_links&quot;, &quot;in&quot;, {&quot;type&quot;: &quot;Version&quot;, &quot;id&quot;: version[&quot;id&quot;]}]],
                [&quot;content&quot;, &quot;user&quot;],
            )
            if notes:
                print(&quot;    Comments:&quot;)
                for note in notes:
                    print(f&quot;      - {note['content']} (User: {note['user']['name']})&quot;)
            else:
                print(&quot;    No comments found.&quot;)
        else:
            print(&quot;\nNo se encontraron versiones asociadas en ShotGrid.&quot;)

    # Generar URL de la tarea usando la base URL de ShotGrid
    task_url = f&quot;{sg.base_url}/detail/Task/{task['id']}&quot;
    print(f&quot;\nTask URL: {task_url}&quot;)


def main():
    try:
        # Especificar fecha mínima con formato completo (ejemplo: 1 de marzo de 2025 a las 00:00 UTC)
        min_date = &quot;2025-03-01T00:00:00Z&quot;
        tasks_artist = get_assigned_tasks(sg, login, min_date)
        tasks_reviewer = get_reviewer_tasks(sg, login, min_date)
        # Unificar por id, priorizando el rol de artista si está en ambos
        tasks_dict = {}
        for t in tasks_reviewer:
            tasks_dict[t[&quot;id&quot;]] = t
        for t in tasks_artist:
            tasks_dict[t[&quot;id&quot;]] = t  # Sobrescribe si ya estaba como reviewer
        all_tasks = list(tasks_dict.values())
        if all_tasks:
            print(f&quot;\nTareas asignadas o como reviewer:&quot;)
            for task in all_tasks:
                print_task_info(task, sg)
        else:
            print(&quot;No se encontraron tareas asignadas ni como reviewer&quot;)

    except Exception as e:
        print(f&quot;Error al obtener tareas: {e}&quot;)


if __name__ == &quot;__main__&quot;:
    main()
</script>
