<?xml version="1.0" encoding="UTF-8"?><script>nuke.toNode('NoOp1').knob('knobChanged').setValue('n=nuke.thisNode()\nk=nuke.thisKnob()\nif k.name() in [&quot;lga_firstFrame_int&quot;, &quot;lga_lastFrame_int&quot;, &quot;lga_frameCount&quot;]:\n rife=nuke.toNode(&quot;RIFE1&quot;)\n if rife:\n  try:\n   fc=int(n[&quot;lga_frameCount&quot;].value())\n   tk=rife[&quot;timingFrame&quot;]\n   tk.clearAnimated()\n   tk.setAnimated()\n   tk.setValueAt(1, 1)\n   tk.setValueAt(2, fc)\n  except:\n   nuke.message(&quot;Error setting keyframes&quot;)')
nuke.toNode('LGA_Morph').knob('knobChanged').setValue('n=nuke.thisNode()\nk=nuke.thisKnob()\nif k.name() in [&quot;lga_firstFrame&quot;,&quot;lga_lastFrame&quot;,&quot;lga_frameRangeIn&quot;,&quot;lga_frameRangeOut&quot;,&quot;python_button&quot;,&quot;python_button_1&quot;,&quot;python_button_2&quot;]:\n data=nuke.toNode(&quot;NoOp_Morph&quot;)\n rife=nuke.toNode(&quot;RIFE_Morph&quot;)\n merge=nuke.toNode(&quot;Merge_Morph&quot;)\n try:\n  fi=int(data[&quot;lga_firstFrame_int&quot;].value())\n  fo=int(data[&quot;lga_lastFrame_int&quot;].value())\n  fc=int(data[&quot;lga_frameCount&quot;].value())\n  if rife:\n   tk=rife[&quot;timingFrame&quot;]\n   tk.clearAnimated()\n   tk.setAnimated()\n   tk.setValueAt(fi, fi)\n   tk.setValueAt(fi+1, fo)\n  for node in [rife, merge]:\n   if node:\n    dk=node[&quot;disable&quot;]\n    dk.clearAnimated()\n    dk.setAnimated()\n    dk.setValueAt(1, fi)\n    dk.setValueAt(0, fi+1)\n    dk.setValueAt(0, fo-1)\n    dk.setValueAt(1, fo)\n except Exception as e:\n  nuke.message(&quot;Keyframe error: {}&quot;.format(e))')
&quot;&quot;&quot;
______________________________________________________

  LGA_NKS_CreateNewTrack v1.2 - 2024 - Lega
  Crea un nuevo track de video encima del track actualmente seleccionado
  y mantiene la posicion del scroll vertical (incluso con UNDO)
______________________________________________________

&quot;&quot;&quot;

import hiero.core
import hiero.ui
from PySide2 import QtWidgets, QtCore
import time

DEBUG = False

def debug_print(*message):
    if DEBUG:
        print(*message)

def print_tracks(seq, message):
    &quot;&quot;&quot;Imprime los tracks en orden&quot;&quot;&quot;
    debug_print(f&quot;\n{message}&quot;)
    debug_print(&quot;Tracks (de abajo hacia arriba):&quot;)
    for i, track in enumerate(seq.videoTracks()):
        debug_print(f&quot;{i}: {track.name()}&quot;)

def get_selected_track_index(seq):
    &quot;&quot;&quot;Obtiene el indice del track actualmente seleccionado&quot;&quot;&quot;
    te = hiero.ui.getTimelineEditor(seq)
    selected_items = te.selection()
    
    if not selected_items:
        debug_print(&quot;No hay items seleccionados en la linea de tiempo.&quot;)
        return None
        
    # Obtener el track del primer item seleccionado
    selected_track = selected_items[0].parentTrack()
    if not selected_track:
        debug_print(&quot;No se pudo obtener el track seleccionado.&quot;)
        return None
        
    # Encontrar el indice del track en la secuencia
    for index, track in enumerate(seq.videoTracks()):
        if track == selected_track:
            return index
            
    return None

def get_vertical_scroll_state():
    &quot;&quot;&quot;
    Obtiene el estado actual del scroll vertical del timeline.
    &quot;&quot;&quot;
    try:
        t = hiero.ui.getTimelineEditor(hiero.ui.activeSequence())
        if not t:
            return None
            
        # Buscar el QSplitter primero
        splitter = None
        for child in t.window().children():
            if isinstance(child, QtWidgets.QSplitter):
                splitter = child
                break
                
        if not splitter:
            debug_print(&quot;No se pudo encontrar el QSplitter&quot;)
            return None
            
        # Buscar el TimelineView dentro del primer widget del QSplitter
        timeline_view = None
        for child in splitter.children():
            if isinstance(child, QtWidgets.QWidget):
                for subchild in child.children():
                    if isinstance(subchild, QtWidgets.QAbstractScrollArea):
                        timeline_view = subchild
                        break
                if timeline_view:
                    break
                    
        if not timeline_view:
            debug_print(&quot;No se pudo encontrar el TimelineView&quot;)
            return None
            
        # Buscar v_container por nombre
        v_container = None
        for child in timeline_view.children():
            if hasattr(child, 'objectName'):
                if child.objectName() == &quot;qt_scrollarea_vcontainer&quot;:
                    v_container = child
                    break
        
        if not v_container:
            debug_print(&quot;No se pudo encontrar el contenedor vertical&quot;)
            return None
            
        # Obtener scrollbar vertical
        v_scrollbar = v_container.children()[0]  # QScrollBar vertical
        
        state = {
            'v_scroll_value': v_scrollbar.value(),
            'v_scroll_min': v_scrollbar.minimum(),
            'v_scroll_max': v_scrollbar.maximum(),
            'v_page_step': v_scrollbar.pageStep()
        }
        
        debug_print(f&quot;Estado del scroll vertical capturado: {state['v_scroll_value']}&quot;)
        return state
            
    except Exception as e:
        debug_print(f&quot;Error al obtener el estado del scroll vertical: {e}&quot;)
        import traceback
        debug_print(traceback.format_exc())
        
    return None

def restore_vertical_scroll_state(state):
    &quot;&quot;&quot;
    Restaura el estado del scroll vertical del timeline.
    Devuelve True si tuvo éxito, False en caso contrario.
    &quot;&quot;&quot;
    if not state:
        debug_print(&quot;No hay estado de scroll vertical para restaurar&quot;)
        return False
        
    try:
        t = hiero.ui.getTimelineEditor(hiero.ui.activeSequence())
        if not t:
            return False
            
        # Buscar el QSplitter primero
        splitter = None
        for child in t.window().children():
            if isinstance(child, QtWidgets.QSplitter):
                splitter = child
                break
                
        if not splitter:
            debug_print(&quot;No se pudo encontrar el QSplitter&quot;)
            return False
            
        # Buscar el TimelineView dentro del primer widget del QSplitter
        timeline_view = None
        for child in splitter.children():
            if isinstance(child, QtWidgets.QWidget):
                for subchild in child.children():
                    if isinstance(subchild, QtWidgets.QAbstractScrollArea):
                        timeline_view = subchild
                        break
                if timeline_view:
                    break
                    
        if not timeline_view:
            debug_print(&quot;No se pudo encontrar el TimelineView&quot;)
            return False
            
        # Buscar v_container por nombre
        v_container = None
        for child in timeline_view.children():
            if hasattr(child, 'objectName'):
                if child.objectName() == &quot;qt_scrollarea_vcontainer&quot;:
                    v_container = child
                    break
        
        if not v_container:
            debug_print(&quot;No se pudo encontrar el contenedor vertical&quot;)
            return False
            
        # Obtener scrollbar vertical
        v_scrollbar = v_container.children()[0]  # QScrollBar vertical
        
        debug_print(f&quot;Restaurando valor del scroll vertical a: {state['v_scroll_value']}&quot;)
        v_scrollbar.setPageStep(state['v_page_step'])
        v_scrollbar.setMaximum(state['v_scroll_max'])
        v_scrollbar.setMinimum(state['v_scroll_min'])
        v_scrollbar.setValue(state['v_scroll_value'])
        
        # Procesar eventos
        QtCore.QCoreApplication.processEvents()
        
        # Verificar si la restauración fue exitosa
        current_value = v_scrollbar.value()
        debug_print(f&quot;Valor actual después de la restauración: {current_value}&quot;)
        
        # Permitir una pequeña diferencia (por si el layout cambió ligeramente)
        if abs(current_value - state['v_scroll_value']) &lt;= 5:
            return True
        else:
            debug_print(&quot;La restauración no fue precisa&quot;)
            return False
            
    except Exception as e:
        debug_print(f&quot;Error al restaurar el scroll vertical: {e}&quot;)
        import traceback
        debug_print(traceback.format_exc())
        
    return False

def create_new_track(seq, track_index):
    &quot;&quot;&quot;Crea un nuevo track y lo inserta en la posicion especificada&quot;&quot;&quot;
    if track_index is None:
        debug_print(&quot;No se pudo determinar la posicion del nuevo track.&quot;)
        return None
        
    # Crear el nuevo track
    new_track = hiero.core.VideoTrack(&quot;New&quot;)
    
    # Obtener todos los tracks de video
    video_tracks = list(seq.videoTracks())
    
    # Imprimir tracks antes de la operación
    print_tracks(seq, &quot;ANTES DE LA OPERACIÓN&quot;)
    
    # Remover todos los tracks existentes
    for track in video_tracks:
        seq.removeTrack(track)
    
    # Insertar el nuevo track en la posicion deseada (encima del track seleccionado)
    # Insertamos en track_index + 1 para que aparezca encima del track seleccionado
    new_tracks = video_tracks[:track_index+1] + [new_track] + video_tracks[track_index+1:]
    
    # Imprimir el orden que vamos a insertar
    debug_print(&quot;\nORDEN DE INSERCIÓN:&quot;)
    for i, track in enumerate(new_tracks):
        debug_print(f&quot;{i}: {track.name()}&quot;)
    
    # Reinsertar todos los tracks en el orden correcto
    for track in new_tracks:
        seq.addTrack(track)
    
    # Imprimir tracks después de la operación
    print_tracks(seq, &quot;DESPUÉS DE LA OPERACIÓN&quot;)
        
    debug_print(f&quot;Nuevo track creado encima del track en la posicion {track_index}&quot;)
    return new_track

def multi_restore_attempt(state, max_attempts=3, delay_ms=120):
    &quot;&quot;&quot;
    Realiza múltiples intentos para restaurar el scroll vertical.
    Esto es importante porque a veces el primer intento falla.
    &quot;&quot;&quot;
    def attempt_restore():
        nonlocal attempt_count
        if attempt_count &lt; max_attempts:
            attempt_count += 1
            debug_print(f&quot;Intento de restauración #{attempt_count}&quot;)
            if restore_vertical_scroll_state(state):
                debug_print(f&quot;Restauración exitosa en el intento #{attempt_count}&quot;)
                return
            else:
                # Programar el siguiente intento
                QtCore.QTimer.singleShot(delay_ms, attempt_restore)
        else:
            debug_print(f&quot;Se agotaron los {max_attempts} intentos de restauración&quot;)
    
    attempt_count = 0
    attempt_restore()

# Este callback será llamado después de cada operación de UNDO/REDO
def undo_callback_wrapper(vertical_scroll_state):
    &quot;&quot;&quot;
    Wrapper para el callback de UNDO/REDO que restaura el scroll vertical.
    &quot;&quot;&quot;
    def callback():
        debug_print(&quot;Callback de UNDO/REDO activado&quot;)
        # Esperar un momento para que la UI se actualice después del UNDO/REDO
        QtCore.QTimer.singleShot(150, lambda: multi_restore_attempt(vertical_scroll_state))
    
    return callback

def main():
    try:
        # Obtener la secuencia activa
        seq = hiero.ui.activeSequence()
        if not seq:
            debug_print(&quot;No se encontro una secuencia activa en Hiero.&quot;)
            return
        
        # Capturar el estado del scroll vertical
        vertical_scroll_state = get_vertical_scroll_state()
        if vertical_scroll_state:
            debug_print(&quot;Estado del scroll vertical capturado correctamente&quot;)
        else:
            debug_print(&quot;No se pudo capturar el estado del scroll vertical&quot;)
            return
            
        # Iniciar una accion de undo
        project = seq.project()
        project.beginUndo(&quot;Crear Nuevo Track&quot;)
        
        try:
            # Obtener el indice del track seleccionado
            track_index = get_selected_track_index(seq)
            
            # Crear el nuevo track
            new_track = create_new_track(seq, track_index)
            
            if new_track:
                debug_print(&quot;Operacion completada exitosamente.&quot;)
            else:
                debug_print(&quot;No se pudo crear el nuevo track.&quot;)
                
        except Exception as e:
            debug_print(f&quot;Error durante la operacion: {e}&quot;)
        finally:
            # Finalizar la accion de undo
            project.endUndo()
            
            # Restaurar el scroll vertical con múltiples intentos
            multi_restore_attempt(vertical_scroll_state)
            
            # Registrar un callback para UNDO/REDO si es posible
            try:
                # Crear un objeto que mantenga la referencia al callback
                callback = undo_callback_wrapper(vertical_scroll_state)
                
                # Registrar callbacks para UNDO/REDO si están disponibles
                if hasattr(hiero.core.events, 'registerInterest'):
                    event_type = None
                    if hasattr(hiero.core.events, 'EventType') and hasattr(hiero.core.events.EventType, 'kUndoRedoFinished'):
                        event_type = hiero.core.events.EventType.kUndoRedoFinished
                    elif hasattr(hiero.core.events, 'kUndoRedoFinished'):
                        event_type = hiero.core.events.kUndoRedoFinished
                        
                    if event_type:
                        hiero.core.events.registerInterest(event_type, callback)
                        debug_print(&quot;Callback de UNDO/REDO registrado&quot;)
            except Exception as e:
                debug_print(f&quot;No se pudo registrar el callback para UNDO/REDO: {e}&quot;)
            
    except Exception as e:
        debug_print(f&quot;Error general: {e}&quot;)

if __name__ == &quot;__main__&quot;:
    main() </script>
