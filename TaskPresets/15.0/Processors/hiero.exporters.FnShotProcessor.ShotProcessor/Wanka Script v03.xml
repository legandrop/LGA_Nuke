<root tasktype="hiero.exporters.FnShotProcessor.ShotProcessor" presetname="Wanka Script v03">
    <excludeTags valuetype="list" />
    <includeTags valuetype="list" />
    <versionIndex valuetype="int">0</versionIndex>
    <versionPadding valuetype="int">2</versionPadding>
    <exportTemplate valuetype="list">
        <SequenceItem valuetype="tuple">
            <SequenceItem valuetype="str">{sequence}/{shot}/Comp/4_publish/{shot}_comp_{version}/{shot}_comp_{version}.####.{ext}</SequenceItem>
            <SequenceItem valuetype="hiero.exporters.FnExternalRender.NukeRenderPreset">
                <root tasktype="hiero.exporters.FnExternalRender.NukeRenderTask" presetname="">
                    <file_type valuetype="str">exr</file_type>
                    <reformat valuetype="dict">
                        <filter valuetype="str">Cubic</filter>
                        <to_type valuetype="str">None</to_type>
                        <scale valuetype="float">1.0</scale>
                        <center valuetype="bool">True</center>
                        <resize valuetype="str">width</resize>
                    </reformat>
                    <channels valuetype="str">rgb</channels>
                    <views valuetype="list">
                        <SequenceItem valuetype="str">all</SequenceItem>
                    </views>
                    <colourspace valuetype="str">ACES - ACES2065-1</colourspace>
                    <create_directories valuetype="bool">True</create_directories>
                    <burninDataEnabled valuetype="bool">False</burninDataEnabled>
                    <dpx valuetype="dict">
                        <datatype valuetype="str">10 bit</datatype>
                        <transfer valuetype="str">(auto detect)</transfer>
                        <bigEndian valuetype="bool">True</bigEndian>
                        <fill valuetype="bool">False</fill>
                    </dpx>
                    <burninData valuetype="dict">
                        <burnIn_bottomRight valuetype="NoneType">None</burnIn_bottomRight>
                        <burnIn_topLeft valuetype="NoneType">None</burnIn_topLeft>
                        <burnIn_topMiddle valuetype="NoneType">None</burnIn_topMiddle>
                        <burnIn_padding valuetype="NoneType">None</burnIn_padding>
                        <burnIn_topRight valuetype="NoneType">None</burnIn_topRight>
                        <burnIn_bottomMiddle valuetype="NoneType">None</burnIn_bottomMiddle>
                        <burnIn_bottomLeft valuetype="NoneType">None</burnIn_bottomLeft>
                        <burnIn_textSize valuetype="NoneType">None</burnIn_textSize>
                        <burnIn_font valuetype="NoneType">None</burnIn_font>
                    </burninData>
                    <exr valuetype="dict">
                        <compression valuetype="str">DWAA</compression>
                        <datatype valuetype="str">16 bit half</datatype>
                        <noprefix valuetype="bool">False</noprefix>
                        <write_full_layer_names valuetype="bool">False</write_full_layer_names>
                        <standard_layer_name_format valuetype="bool">False</standard_layer_name_format>
                        <interleave valuetype="str">channels, layers and views</interleave>
                        <dw_compression_level valuetype="float">60.0</dw_compression_level>
                        <truncateChannelNames valuetype="bool">False</truncateChannelNames>
                        <write_ACES_compliant_EXR valuetype="bool">False</write_ACES_compliant_EXR>
                        <metadata valuetype="str">default metadata</metadata>
                    </exr>
                    <writeNodeName valuetype="str">Write_{ext}</writeNodeName>
                </root>
            </SequenceItem>
        </SequenceItem>
        <SequenceItem valuetype="tuple">
            <SequenceItem valuetype="str">{sequence}/{shot}/Comp/3_review/{shot}_comp_{version}.####.{ext}</SequenceItem>
            <SequenceItem valuetype="hiero.exporters.FnExternalRender.NukeRenderPreset">
                <root tasktype="hiero.exporters.FnExternalRender.NukeRenderTask" presetname="hiero.exporters.FnExternalRender.NukeRenderTask">
                    <file_type valuetype="str">mov</file_type>
                    <reformat valuetype="dict">
                        <filter valuetype="str">Cubic</filter>
                        <to_type valuetype="str">None</to_type>
                        <scale valuetype="float">1.0</scale>
                        <center valuetype="bool">True</center>
                        <resize valuetype="str">width</resize>
                    </reformat>
                    <channels valuetype="str">rgb</channels>
                    <views valuetype="list">
                        <SequenceItem valuetype="str">all</SequenceItem>
                    </views>
                    <colourspace valuetype="str">Output - Rec.709</colourspace>
                    <create_directories valuetype="bool">False</create_directories>
                    <mov valuetype="dict">
                        <mov64_dnxhr_codec_profile valuetype="NoneType">None</mov64_dnxhr_codec_profile>
                        <mov64_quality_min valuetype="NoneType">None</mov64_quality_min>
                        <dataRange valuetype="str">Video Range</dataRange>
                        <mov_h264_codec_profile valuetype="NoneType">None</mov_h264_codec_profile>
                        <mov64_gop_size valuetype="NoneType">None</mov64_gop_size>
                        <mov_prores_codec_profile valuetype="str">ProRes 4:2:2 LT 10-bit</mov_prores_codec_profile>
                        <mov64_b_frames valuetype="NoneType">None</mov64_b_frames>
                        <mov64_write_timecode valuetype="bool">True</mov64_write_timecode>
                        <mov64_bitrate_tolerance valuetype="NoneType">None</mov64_bitrate_tolerance>
                        <mov64_dnxhd_codec_profile valuetype="NoneType">None</mov64_dnxhd_codec_profile>
                        <mov64_bitrate valuetype="NoneType">None</mov64_bitrate>
                        <mov64_pixel_format valuetype="NoneType">None</mov64_pixel_format>
                        <mov64_limit_bitrate valuetype="NoneType">None</mov64_limit_bitrate>
                        <mov64_quality valuetype="NoneType">None</mov64_quality>
                        <mov64_quality_max valuetype="NoneType">None</mov64_quality_max>
                        <mov64_codec valuetype="str">appr</mov64_codec>
                        <mov64_fast_start valuetype="bool">True</mov64_fast_start>
                        <encoder valuetype="str">mov64</encoder>
                        <mov64_ycbcr_matrix_type valuetype="str">Auto</mov64_ycbcr_matrix_type>
                    </mov>
                    <burninDataEnabled valuetype="bool">False</burninDataEnabled>
                    <dpx valuetype="dict">
                        <datatype valuetype="str">8 bit</datatype>
                        <transfer valuetype="str">(auto detect)</transfer>
                        <bigEndian valuetype="bool">True</bigEndian>
                        <fill valuetype="bool">False</fill>
                    </dpx>
                    <burninData valuetype="dict">
                        <burnIn_bottomRight valuetype="NoneType">None</burnIn_bottomRight>
                        <burnIn_topLeft valuetype="NoneType">None</burnIn_topLeft>
                        <burnIn_topMiddle valuetype="NoneType">None</burnIn_topMiddle>
                        <burnIn_padding valuetype="NoneType">None</burnIn_padding>
                        <burnIn_topRight valuetype="NoneType">None</burnIn_topRight>
                        <burnIn_bottomMiddle valuetype="NoneType">None</burnIn_bottomMiddle>
                        <burnIn_bottomLeft valuetype="NoneType">None</burnIn_bottomLeft>
                        <burnIn_textSize valuetype="NoneType">None</burnIn_textSize>
                        <burnIn_font valuetype="NoneType">None</burnIn_font>
                    </burninData>
                    <writeNodeName valuetype="str">Write_{ext}</writeNodeName>
                </root>
            </SequenceItem>
        </SequenceItem>
        <SequenceItem valuetype="tuple">
            <SequenceItem valuetype="str">{sequence}/{shot}/Comp/1_projects/{shot}_comp_{version}.{ext}</SequenceItem>
            <SequenceItem valuetype="hiero.exporters.FnNukeShotExporter.NukeShotPreset">
                <root tasktype="hiero.exporters.FnNukeShotExporter.NukeShotExporter" presetname="">
                    <enable valuetype="bool">True</enable>
                    <readPaths valuetype="list" />
                    <writePaths valuetype="list">
                        <SequenceItem valuetype="str">{sequence}/{shot}/Comp/4_publish/{shot}_comp_{version}/{shot}_comp_{version}.####.{ext}</SequenceItem>
                        <SequenceItem valuetype="str">{sequence}/{shot}/Comp/3_review/{shot}_comp_{version}.####.{ext}</SequenceItem>
                    </writePaths>
                    <timelineWriteNode valuetype="str" />
                    <collateTracks valuetype="bool">True</collateTracks>
                    <collateShotNames valuetype="bool">False</collateShotNames>
                    <annotationsPreCompPaths valuetype="list" />
                    <includeAnnotations valuetype="bool">False</includeAnnotations>
                    <showAnnotations valuetype="bool">True</showAnnotations>
                    <includeEffects valuetype="bool">False</includeEffects>
                    <connectTracks valuetype="bool">False</connectTracks>
                    <collateSequence valuetype="bool">False</collateSequence>
                    <collateCustomStart valuetype="bool">True</collateCustomStart>
                    <additionalNodesEnabled valuetype="bool">True</additionalNodesEnabled>
                    <additionalNodesData valuetype="list">
                        <SequenceItem valuetype="tuple">
                            <SequenceItem valuetype="str">None</SequenceItem>
                            <SequenceItem valuetype="list" />
                            <SequenceItem valuetype="str">BackdropNode {&#x0A; inputs 0&#x0A; name BackdropNode6&#x0A; tile_color 0x999999ff&#x0A; label input&#x0A; note_font_size 42&#x0A; selected true&#x0A; bdwidth 762&#x0A; bdheight 489&#x0A;}&#x0A;BackdropNode {&#x0A; inputs 0&#x0A; name BackdropNode7&#x0A; tile_color 0x999999ff&#x0A; label output&#x0A; note_font_size 42&#x0A; selected true&#x0A; bdwidth 534&#x0A; bdheight 451&#x0A;}&#x0A;Read {&#x0A; inputs 0&#x0A; origset true&#x0A; name Read4&#x0A; selected true&#x0A;}&#x0A;Write {&#x0A; file &quot;\[file dir \[value root.name]]/../3_review/\[file tail \[file rootname \[value root.name]]].mov&quot;&#x0A; colorspace &quot;Output - Rec.709&quot;&#x0A; file_type mov&#x0A; mov64_format &quot;mov (QuickTime / MOV)&quot;&#x0A; mov64_codec appr&#x0A; mov_prores_codec_profile &quot;ProRes 4:2:2 LT 10-bit&quot;&#x0A; mov_h264_codec_profile &quot;High 4:2:0 8-bit&quot;&#x0A; mov64_pixel_format {{0} &quot;yuv420p\tYCbCr 4:2:0 8-bit&quot;}&#x0A; mov64_quality High&#x0A; mov64_fast_start true&#x0A; mov64_write_timecode true&#x0A; mov64_gop_size 12&#x0A; mov64_b_frames 0&#x0A; mov64_bitrate 20000&#x0A; mov64_bitrate_tolerance 4000000&#x0A; mov64_quality_min 1&#x0A; mov64_quality_max 3&#x0A; create_directories true&#x0A; checkHashOnRead false&#x0A; version 2&#x0A; in_colorspace scene_linear&#x0A; out_colorspace scene_linear&#x0A; name Write_Pub1&#x0A; selected true&#x0A; bookmark true&#x0A;}&#x0A;StickyNote {&#x0A; inputs 0&#x0A; name StickyNote2&#x0A; label &quot;  EXR publish  ---&gt; &quot;&#x0A; note_font_size 21&#x0A; selected true&#x0A;}&#x0A;StickyNote {&#x0A; inputs 0&#x0A; name StickyNote3&#x0A; label &quot;  MOV review  ---&gt; &quot;&#x0A; note_font_size 21&#x0A; selected true&#x0A;}&#x0A;StickyNote {&#x0A; inputs 0&#x0A; name StickyNote1&#x0A; label &quot;  EXR publish  ---&gt; &quot;&#x0A; note_font_size 21&#x0A; selected true&#x0A;}&#x0A;StickyNote {&#x0A; inputs 0&#x0A; name StickyNote4&#x0A; label &quot;  Trabajo ---&gt; &quot;&#x0A; note_font_size 21&#x0A; selected true&#x0A;}&#x0A;Read {&#x0A; inputs 0&#x0A; origset true&#x0A; name Read_EditRef&#x0A; tile_color 0xffaac9ff&#x0A; selected true&#x0A;}&#x0A;NoOp {&#x0A; name Anchor_1d0d2bd14c&#x0A; help &quot;Stamps by Adrian Pueyo and Alexey Kuchinski.\nUpdated May 18 2021&quot;&#x0A; onCreate &quot;if nuke.GUI:\n    try:\n        import stamps; stamps.anchorOnCreate()\n    except:\n        pass&quot;&#x0A; knobChanged stamps.anchorKnobChanged()&#x0A; autolabel &quot;nuke.thisNode().knob(\&quot;title\&quot;).value()&quot;&#x0A; tile_color 0xffaac9ff&#x0A; note_font_size 20&#x0A; selected true&#x0A; addUserKnob {20 anchor_tab l &quot;Anchor Stamp&quot;}&#x0A; addUserKnob {26 identifier +HIDDEN T anchor}&#x0A; addUserKnob {1 title l Title: t &quot;Displayed name on the Node Graph for this Stamp and its Anchor.\nIMPORTANT: This is only for display purposes, and is different from the real/internal name of the Stamps.&quot;}&#x0A; title EditRef&#x0A; addUserKnob {26 prev_title l &quot;&quot; +STARTLINE +HIDDEN T EditRef}&#x0A; addUserKnob {26 prev_name l &quot;&quot; +STARTLINE +HIDDEN T Anchor_1d0d2bd14c}&#x0A; addUserKnob {3 showing l &quot;&quot; +STARTLINE +HIDDEN}&#x0A; addUserKnob {1 tags l Tags t &quot;Comma-separated tags you can define for each Anchor, that will help you find it when invoking the Stamp Selector by pressing the Stamps shortkey with nothing selected.&quot;}&#x0A; tags 2D,&#x0A; addUserKnob {26 line1 l &quot;&quot; +STARTLINE}&#x0A; addUserKnob {26 stamps_label l Stamps: T &quot; &quot;}&#x0A; addUserKnob {22 createStamp l new t &quot;Create a new Stamp for this Anchor.&quot; -STARTLINE T stamps.stampCreateWired(nuke.thisNode())}&#x0A; addUserKnob {22 selectStamps l select t &quot;Reconnect all of this Anchor&apos;s Stamps.&quot; -STARTLINE T stamps.wiredSelectSimilar(nuke.thisNode().name())}&#x0A; addUserKnob {22 reconnectStamps l reconnect -STARTLINE T stamps.anchorReconnectWired()}&#x0A; addUserKnob {22 zoomNext l &quot;zoom next&quot; t &quot;Navigate to this Anchor&apos;s next Stamp on the Node Graph.&quot; -STARTLINE T stamps.wiredZoomNext(nuke.thisNode().name())}&#x0A; addUserKnob {26 line2 l &quot;&quot; +STARTLINE}&#x0A; addUserKnob {22 buttonHelp l Help -STARTLINE T stamps.showHelp()}&#x0A; addUserKnob {26 version l &quot; &quot; t &quot;Stamps by Adrian Pueyo and Alexey Kuchinski.\nUpdated May 18 2021.&quot; -STARTLINE T &quot;&lt;a href=\&quot;http://www.nukepedia.com/gizmos/other/stamps\&quot; style=\&quot;color:#666;text-decoration: none;\&quot;&gt;&lt;span style=\&quot;color:#666\&quot;&gt; &lt;big&gt;Stamps v1.1&lt;/big&gt;&lt;/b&gt;&lt;/a&gt;&quot;}&#x0A;}&#x0A;Read {&#x0A; inputs 0&#x0A; origset true&#x0A; name Read_aPlate&#x0A; selected true&#x0A;}&#x0A;NoOp {&#x0A; name Anchor_286e15befe&#x0A; help &quot;Stamps by Adrian Pueyo and Alexey Kuchinski.\nUpdated May 18 2021&quot;&#x0A; onCreate &quot;if nuke.GUI:\n    try:\n        import stamps; stamps.anchorOnCreate()\n    except:\n        pass&quot;&#x0A; knobChanged stamps.anchorKnobChanged()&#x0A; autolabel &quot;nuke.thisNode().knob(\&quot;title\&quot;).value()&quot;&#x0A; tile_color 0xffffff01&#x0A; note_font_size 20&#x0A; selected true&#x0A; addUserKnob {20 anchor_tab l &quot;Anchor Stamp&quot;}&#x0A; addUserKnob {26 identifier -STARTLINE +HIDDEN T anchor}&#x0A; addUserKnob {1 title l Title: t &quot;Displayed name on the Node Graph for this Stamp and its Anchor.\nIMPORTANT: This is only for display purposes, and is different from the real/internal name of the Stamps.&quot;}&#x0A; title aPlate&#x0A; addUserKnob {26 prev_title l &quot;&quot; +STARTLINE +HIDDEN T aPlate}&#x0A; addUserKnob {26 prev_name l &quot;&quot; +STARTLINE +HIDDEN T Anchor_286e15befe}&#x0A; addUserKnob {3 showing l &quot;&quot; +STARTLINE +HIDDEN}&#x0A; addUserKnob {1 tags l Tags t &quot;Comma-separated tags you can define for each Anchor, that will help you find it when invoking the Stamp Selector by pressing the Stamps shortkey with nothing selected.&quot;}&#x0A; addUserKnob {26 line1 l &quot;&quot; +STARTLINE}&#x0A; addUserKnob {26 stamps_label l Stamps: T &quot; &quot;}&#x0A; addUserKnob {22 createStamp l new t &quot;Create a new Stamp for this Anchor.&quot; -STARTLINE T stamps.stampCreateWired(nuke.thisNode())}&#x0A; addUserKnob {22 selectStamps l select t &quot;Reconnect all of this Anchor&apos;s Stamps.&quot; -STARTLINE T stamps.wiredSelectSimilar(nuke.thisNode().name())}&#x0A; addUserKnob {22 reconnectStamps l reconnect -STARTLINE T stamps.anchorReconnectWired()}&#x0A; addUserKnob {22 zoomNext l &quot;zoom next&quot; t &quot;Navigate to this Anchor&apos;s next Stamp on the Node Graph.&quot; -STARTLINE T stamps.wiredZoomNext(nuke.thisNode().name())}&#x0A; addUserKnob {26 line2 l &quot;&quot; +STARTLINE}&#x0A; addUserKnob {22 buttonHelp l Help -STARTLINE T stamps.showHelp()}&#x0A; addUserKnob {26 version l &quot; &quot; t &quot;Stamps by Adrian Pueyo and Alexey Kuchinski.\nUpdated May 18 2021.&quot; -STARTLINE T &quot;&lt;a href=\&quot;http://www.nukepedia.com/gizmos/other/stamps\&quot; style=\&quot;color:#666;text-decoration: none;\&quot;&gt;&lt;span style=\&quot;color:#666\&quot;&gt; &lt;big&gt;Stamps v1.1&lt;/big&gt;&lt;/b&gt;&lt;/a&gt;&quot;}&#x0A;}&#x0A;set Nda50fc00 [stack 0]&#x0A;PostageStamp {&#x0A; name Stamp1&#x0A; help &quot;Stamps by Adrian Pueyo and Alexey Kuchinski.\nUpdated May 18 2021&quot;&#x0A; onCreate &quot;if nuke.GUI:\n    try:\n        import stamps; stamps.wiredOnCreate()\n    except:\n        pass\n&quot;&#x0A; knobChanged &quot;import stamps; stamps.wiredKnobChanged()&quot;&#x0A; autolabel &quot;nuke.thisNode().knob(\&quot;title\&quot;).value()&quot;&#x0A; tile_color 0x1000001&#x0A; note_font Verdana&#x0A; note_font_size 20&#x0A; selected true&#x0A; hide_input true&#x0A; addUserKnob {20 wired_tab l &quot;Wired Stamp&quot;}&#x0A; addUserKnob {26 identifier -STARTLINE +HIDDEN T wired}&#x0A; addUserKnob {3 lockCallbacks l &quot;&quot; +STARTLINE +HIDDEN}&#x0A; addUserKnob {6 toReconnect -STARTLINE +HIDDEN}&#x0A; addUserKnob {1 title l Title: t &quot;Displayed name on the Node Graph for this Stamp and its Anchor.\nIMPORTANT: This is only for display purposes, and is different from the real/internal name of the Stamps.&quot;}&#x0A; title aPlate&#x0A; addUserKnob {26 prev_title l &quot;&quot; +STARTLINE +HIDDEN T aPlate}&#x0A; addUserKnob {26 tags l Tags: t &quot;Tags of this stamp&apos;s Anchor, for information purpose only.\nClick \&quot;show anchor\&quot; to change them.&quot; +HIDDEN T &quot; &quot;}&#x0A; addUserKnob {26 backdrops l Backdrops: t &quot;Labels of backdrop nodes which contain this stamp&apos;s Anchor.&quot; +HIDDEN T &quot; &quot;}&#x0A; addUserKnob {26 line1 l &quot;&quot; +STARTLINE}&#x0A; addUserKnob {6 postageStamp_show l &quot;postage stamp&quot; t &quot;Enable the postage stamp thumbnail in this node.\nYou&apos;re seeing this because the class of this node includes the postage_stamp knob.&quot; +STARTLINE}&#x0A; addUserKnob {26 anchor_label l Anchor: T &quot; &quot;}&#x0A; addUserKnob {22 show_anchor l &quot; show anchor &quot; t &quot;Show the properties panel for this Stamp&apos;s Anchor.&quot; -STARTLINE T stamps.wiredShowAnchor()}&#x0A; addUserKnob {22 zoom_anchor l &quot;zoom anchor&quot; t &quot;Navigate to this Stamp&apos;s Anchor on the Node Graph.&quot; -STARTLINE T stamps.wiredZoomAnchor()}&#x0A; addUserKnob {26 stamps_label l Stamps: T &quot; &quot;}&#x0A; addUserKnob {22 zoomNext l &quot; zoom next &quot; t &quot;Navigate to this Stamp&apos;s next sibling on the Node Graph.&quot; -STARTLINE T stamps.wiredZoomNext()}&#x0A; addUserKnob {22 selectSimilar l &quot; select similar &quot; t &quot;Select all similar Stamps to this one on the Node Graph.&quot; -STARTLINE T stamps.wiredSelectSimilar()}&#x0A; addUserKnob {26 space_1 l &quot;&quot; +STARTLINE T &quot; &quot;}&#x0A; addUserKnob {26 reconnect_label l Reconnect: t &quot;Reconnect by the stored Anchor name.&quot; T &quot; &quot;}&#x0A; addUserKnob {22 reconnect_this l this t &quot;Reconnect this Stamp to its Anchor, by its stored Anchor name.&quot; -STARTLINE T &quot;n = nuke.thisNode()\ntry:\n    n.setInput(0,nuke.toNode(n.knob(\&quot;anchor\&quot;).value()))\nexcept:\n    nuke.message(\&quot;Unable to reconnect.\&quot;)\ntry:\n    import stamps\n    stamps.wiredGetStyle(n)\nexcept:\n    pass\n&quot;}&#x0A; addUserKnob {22 reconnect_similar l similar t &quot;Reconnect this Stamp and similar ones to their Anchor, by their stored anchor name.&quot; -STARTLINE T stamps.wiredReconnectSimilar()}&#x0A; addUserKnob {22 reconnect_all l all t &quot;Reconnect all the Stamps to their Anchors, by their stored anchor names.&quot; -STARTLINE T stamps.wiredReconnectAll()}&#x0A; addUserKnob {26 space_2 l &quot;&quot; +STARTLINE T &quot; &quot;}&#x0A; addUserKnob {20 advanced_reconnection l &quot;Advanced Reconnection&quot; n 2}&#x0A; addUserKnob {26 reconnect_by_title_label l &quot;&lt;font color=gold&gt;By Title:&quot; t &quot;Reconnect by searching for a matching title.&quot; T &quot; &quot;}&#x0A; addUserKnob {22 reconnect_by_title_this l this t &quot;Look for an Anchor that shares this Stamp&apos;s title, and connect this Stamp to it.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectByTitle()}&#x0A; addUserKnob {22 reconnect_by_title_similar l similar t &quot;Look for an Anchor that shares this Stamp&apos;s title, and connect this Stamp and similar ones to it.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectByTitleSimilar()}&#x0A; addUserKnob {22 reconnect_by_title_selected l selected t &quot;For each Stamp selected, look for an Anchor that shares its title, and connect to it.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectByTitleSelected()}&#x0A; addUserKnob {26 reconnect_by_selection_label l &quot;&lt;font color=orangered&gt;By Selection:&quot; t &quot;Force reconnect to a selected Anchor.&quot; T &quot; &quot;}&#x0A; addUserKnob {22 reconnect_by_selection_this l this t &quot;Force reconnect this Stamp to a selected Anchor, whatever its name or title.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectBySelection()}&#x0A; addUserKnob {22 reconnect_by_selection_similar l similar t &quot;Force reconnect this Stamp and similar ones to a selected Anchor, whatever its name or title.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectBySelectionSimilar()}&#x0A; addUserKnob {22 reconnect_by_selection_selected l selected t &quot;Force reconnect all selected Stamps to an also selected Anchor, whatever its name or title.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectBySelectionSelected()}&#x0A; addUserKnob {1 anchor l Anchor}&#x0A; anchor Anchor_286e15befe&#x0A; addUserKnob {6 auto_reconnect_by_title l &quot;&lt;font color=#ED9977&gt;&amp;nbsp; auto-reconnect by title&quot; t &quot;When creating this stamp again (like on copy-paste), auto-reconnect it by title instead of doing it by the saved anchor&apos;s name, and auto-turn this off immediately.\nIMPORTANT: Should be off by default. Only use this for setting up templates.&quot; +STARTLINE}&#x0A; addUserKnob {26 line2 l &quot;&quot; +STARTLINE}&#x0A; addUserKnob {22 buttonHelp l Help -STARTLINE T stamps.showHelp()}&#x0A; addUserKnob {26 version l &quot; &quot; t &quot;Stamps by Adrian Pueyo and Alexey Kuchinski.\nUpdated May 18 2021.&quot; -STARTLINE T &quot;&lt;a href=\&quot;http://www.nukepedia.com/gizmos/other/stamps\&quot; style=\&quot;color:#666;text-decoration: none;\&quot;&gt;&lt;span style=\&quot;color:#666\&quot;&gt; &lt;big&gt;Stamps v1.1&lt;/big&gt;&lt;/b&gt;&lt;/a&gt;&quot;}&#x0A;}&#x0A;OFXcom.absoft.neatvideo4_v4 {&#x0A; DNP &quot;&quot;&#x0A; NFP &quot;&quot;&#x0A; ParamsHash1 0&#x0A; ParamsHash2 0&#x0A; ParamsHash3 0&#x0A; name &quot;Reduce Noise v4_1&quot;&#x0A; selected true78&#x0A;}&#x0A;Write {&#x0A; file &quot;\[file dir \[value root.name]]/../2_prerenders/\[join \[lrange \[split \[file tail \[knob \[topnode].file]] _ ] 0 5 ] _]_aPlate_Denoised/\[join \[lrange \[split \[file tail \[knob \[topnode].file]] _ ] 0 5 ] _]_aPlate_Denoised_%04d.exr&quot;&#x0A; file_type exr&#x0A; compression DWAA&#x0A; dw_compression_level 60&#x0A; first_part rgba&#x0A; create_directories true&#x0A; version 9&#x0A; name Write_aDenoised&#x0A; selected true&#x0A; bookmark true&#x0A;}&#x0A;Read {&#x0A; inputs 0&#x0A; origset true&#x0A; name Read_aDenoised&#x0A; selected true&#x0A;}&#x0A;NoOp {&#x0A; name Anchor_1218aa251d&#x0A; help &quot;Stamps by Adrian Pueyo and Alexey Kuchinski.\nUpdated May 18 2021&quot;&#x0A; onCreate &quot;if nuke.GUI:\n    try:\n        import stamps; stamps.anchorOnCreate()\n    except:\n        pass&quot;&#x0A; knobChanged stamps.anchorKnobChanged()&#x0A; autolabel &quot;nuke.thisNode().knob(\&quot;title\&quot;).value()&quot;&#x0A; tile_color 0xffffff01&#x0A; note_font_size 20&#x0A; selected true&#x0A; addUserKnob {20 anchor_tab l &quot;Anchor Stamp&quot;}&#x0A; addUserKnob {26 identifier -STARTLINE +HIDDEN T anchor}&#x0A; addUserKnob {1 title l Title: t &quot;Displayed name on the Node Graph for this Stamp and its Anchor.\nIMPORTANT: This is only for display purposes, and is different from the real/internal name of the Stamps.&quot;}&#x0A; title aDenoised&#x0A; addUserKnob {26 prev_title l &quot;&quot; +STARTLINE +HIDDEN T aDenoised}&#x0A; addUserKnob {26 prev_name l &quot;&quot; +STARTLINE +HIDDEN T Anchor_1218aa251d}&#x0A; addUserKnob {3 showing l &quot;&quot; +STARTLINE +HIDDEN}&#x0A; addUserKnob {1 tags l Tags t &quot;Comma-separated tags you can define for each Anchor, that will help you find it when invoking the Stamp Selector by pressing the Stamps shortkey with nothing selected.&quot;}&#x0A; tags 2D,&#x0A; addUserKnob {26 line1 l &quot;&quot; +STARTLINE}&#x0A; addUserKnob {26 stamps_label l Stamps: T &quot; &quot;}&#x0A; addUserKnob {22 createStamp l new t &quot;Create a new Stamp for this Anchor.&quot; -STARTLINE T stamps.stampCreateWired(nuke.thisNode())}&#x0A; addUserKnob {22 selectStamps l select t &quot;Reconnect all of this Anchor&apos;s Stamps.&quot; -STARTLINE T stamps.wiredSelectSimilar(nuke.thisNode().name())}&#x0A; addUserKnob {22 reconnectStamps l reconnect -STARTLINE T stamps.anchorReconnectWired()}&#x0A; addUserKnob {22 zoomNext l &quot;zoom next&quot; t &quot;Navigate to this Anchor&apos;s next Stamp on the Node Graph.&quot; -STARTLINE T stamps.wiredZoomNext(nuke.thisNode().name())}&#x0A; addUserKnob {26 line2 l &quot;&quot; +STARTLINE}&#x0A; addUserKnob {22 buttonHelp l Help -STARTLINE T stamps.showHelp()}&#x0A; addUserKnob {26 version l &quot; &quot; t &quot;Stamps by Adrian Pueyo and Alexey Kuchinski.\nUpdated May 18 2021.&quot; -STARTLINE T &quot;&lt;a href=\&quot;http://www.nukepedia.com/gizmos/other/stamps\&quot; style=\&quot;color:#666;text-decoration: none;\&quot;&gt;&lt;span style=\&quot;color:#666\&quot;&gt; &lt;big&gt;Stamps v1.1&lt;/big&gt;&lt;/b&gt;&lt;/a&gt;&quot;}&#x0A;}&#x0A;set Nda50e000 [stack 0]&#x0A;PostageStamp {&#x0A; name Stamp4&#x0A; help &quot;Stamps by Adrian Pueyo and Alexey Kuchinski.\nUpdated May 18 2021&quot;&#x0A; onCreate &quot;if nuke.GUI:\n    try:\n        import stamps; stamps.wiredOnCreate()\n    except:\n        pass\n&quot;&#x0A; knobChanged &quot;import stamps; stamps.wiredKnobChanged()&quot;&#x0A; autolabel &quot;nuke.thisNode().knob(\&quot;title\&quot;).value()&quot;&#x0A; tile_color 0x1000001&#x0A; note_font Verdana&#x0A; note_font_size 20&#x0A; selected true&#x0A; hide_input true&#x0A; addUserKnob {20 wired_tab l &quot;Wired Stamp&quot;}&#x0A; addUserKnob {26 identifier -STARTLINE +HIDDEN T wired}&#x0A; addUserKnob {3 lockCallbacks l &quot;&quot; +STARTLINE +HIDDEN}&#x0A; addUserKnob {6 toReconnect -STARTLINE +HIDDEN}&#x0A; addUserKnob {1 title l Title: t &quot;Displayed name on the Node Graph for this Stamp and its Anchor.\nIMPORTANT: This is only for display purposes, and is different from the real/internal name of the Stamps.&quot;}&#x0A; title aDenoised&#x0A; addUserKnob {26 prev_title l &quot;&quot; +STARTLINE +HIDDEN T aDenoised}&#x0A; addUserKnob {26 tags l Tags: t &quot;Tags of this stamp&apos;s Anchor, for information purpose only.\nClick \&quot;show anchor\&quot; to change them.&quot; T &lt;i&gt;2D&lt;/i&gt;}&#x0A; addUserKnob {26 backdrops l Backdrops: t &quot;Labels of backdrop nodes which contain this stamp&apos;s Anchor.&quot; T &lt;i&gt;input&lt;/i&gt;}&#x0A; addUserKnob {26 line1 l &quot;&quot; +STARTLINE}&#x0A; addUserKnob {6 postageStamp_show l &quot;postage stamp&quot; t &quot;Enable the postage stamp thumbnail in this node.\nYou&apos;re seeing this because the class of this node includes the postage_stamp knob.&quot; +STARTLINE}&#x0A; addUserKnob {26 anchor_label l Anchor: T &quot; &quot;}&#x0A; addUserKnob {22 show_anchor l &quot; show anchor &quot; t &quot;Show the properties panel for this Stamp&apos;s Anchor.&quot; -STARTLINE T stamps.wiredShowAnchor()}&#x0A; addUserKnob {22 zoom_anchor l &quot;zoom anchor&quot; t &quot;Navigate to this Stamp&apos;s Anchor on the Node Graph.&quot; -STARTLINE T stamps.wiredZoomAnchor()}&#x0A; addUserKnob {26 stamps_label l Stamps: T &quot; &quot;}&#x0A; addUserKnob {22 zoomNext l &quot; zoom next &quot; t &quot;Navigate to this Stamp&apos;s next sibling on the Node Graph.&quot; -STARTLINE T stamps.wiredZoomNext()}&#x0A; addUserKnob {22 selectSimilar l &quot; select similar &quot; t &quot;Select all similar Stamps to this one on the Node Graph.&quot; -STARTLINE T stamps.wiredSelectSimilar()}&#x0A; addUserKnob {26 space_1 l &quot;&quot; +STARTLINE T &quot; &quot;}&#x0A; addUserKnob {26 reconnect_label l Reconnect: t &quot;Reconnect by the stored Anchor name.&quot; T &quot; &quot;}&#x0A; addUserKnob {22 reconnect_this l this t &quot;Reconnect this Stamp to its Anchor, by its stored Anchor name.&quot; -STARTLINE T &quot;n = nuke.thisNode()\ntry:\n    n.setInput(0,nuke.toNode(n.knob(\&quot;anchor\&quot;).value()))\nexcept:\n    nuke.message(\&quot;Unable to reconnect.\&quot;)\ntry:\n    import stamps\n    stamps.wiredGetStyle(n)\nexcept:\n    pass\n&quot;}&#x0A; addUserKnob {22 reconnect_similar l similar t &quot;Reconnect this Stamp and similar ones to their Anchor, by their stored anchor name.&quot; -STARTLINE T stamps.wiredReconnectSimilar()}&#x0A; addUserKnob {22 reconnect_all l all t &quot;Reconnect all the Stamps to their Anchors, by their stored anchor names.&quot; -STARTLINE T stamps.wiredReconnectAll()}&#x0A; addUserKnob {26 space_2 l &quot;&quot; +STARTLINE T &quot; &quot;}&#x0A; addUserKnob {20 advanced_reconnection l &quot;Advanced Reconnection&quot; n 2}&#x0A; addUserKnob {26 reconnect_by_title_label l &quot;&lt;font color=gold&gt;By Title:&quot; t &quot;Reconnect by searching for a matching title.&quot; T &quot; &quot;}&#x0A; addUserKnob {22 reconnect_by_title_this l this t &quot;Look for an Anchor that shares this Stamp&apos;s title, and connect this Stamp to it.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectByTitle()}&#x0A; addUserKnob {22 reconnect_by_title_similar l similar t &quot;Look for an Anchor that shares this Stamp&apos;s title, and connect this Stamp and similar ones to it.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectByTitleSimilar()}&#x0A; addUserKnob {22 reconnect_by_title_selected l selected t &quot;For each Stamp selected, look for an Anchor that shares its title, and connect to it.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectByTitleSelected()}&#x0A; addUserKnob {26 reconnect_by_selection_label l &quot;&lt;font color=orangered&gt;By Selection:&quot; t &quot;Force reconnect to a selected Anchor.&quot; T &quot; &quot;}&#x0A; addUserKnob {22 reconnect_by_selection_this l this t &quot;Force reconnect this Stamp to a selected Anchor, whatever its name or title.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectBySelection()}&#x0A; addUserKnob {22 reconnect_by_selection_similar l similar t &quot;Force reconnect this Stamp and similar ones to a selected Anchor, whatever its name or title.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectBySelectionSimilar()}&#x0A; addUserKnob {22 reconnect_by_selection_selected l selected t &quot;Force reconnect all selected Stamps to an also selected Anchor, whatever its name or title.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectBySelectionSelected()}&#x0A; addUserKnob {1 anchor l Anchor}&#x0A; anchor Anchor_1218aa251d&#x0A; addUserKnob {6 auto_reconnect_by_title l &quot;&lt;font color=#ED9977&gt;&amp;nbsp; auto-reconnect by title&quot; t &quot;When creating this stamp again (like on copy-paste), auto-reconnect it by title instead of doing it by the saved anchor&apos;s name, and auto-turn this off immediately.\nIMPORTANT: Should be off by default. Only use this for setting up templates.&quot; +STARTLINE}&#x0A; addUserKnob {26 line2 l &quot;&quot; +STARTLINE}&#x0A; addUserKnob {22 buttonHelp l Help -STARTLINE T stamps.showHelp()}&#x0A; addUserKnob {26 version l &quot; &quot; t &quot;Stamps by Adrian Pueyo and Alexey Kuchinski.\nUpdated May 18 2021.&quot; -STARTLINE T &quot;&lt;a href=\&quot;http://www.nukepedia.com/gizmos/other/stamps\&quot; style=\&quot;color:#666;text-decoration: none;\&quot;&gt;&lt;span style=\&quot;color:#666\&quot;&gt; &lt;big&gt;Stamps v1.1&lt;/big&gt;&lt;/b&gt;&lt;/a&gt;&quot;}&#x0A;}&#x0A;push $Nda50fc00&#x0A;PostageStamp {&#x0A; name Stamp3&#x0A; help &quot;Stamps by Adrian Pueyo and Alexey Kuchinski.\nUpdated May 18 2021&quot;&#x0A; onCreate &quot;if nuke.GUI:\n    try:\n        import stamps; stamps.wiredOnCreate()\n    except:\n        pass\n&quot;&#x0A; knobChanged &quot;import stamps; stamps.wiredKnobChanged()&quot;&#x0A; autolabel &quot;nuke.thisNode().knob(\&quot;title\&quot;).value()&quot;&#x0A; tile_color 0x1000001&#x0A; note_font Verdana&#x0A; note_font_size 20&#x0A; selected true&#x0A; hide_input true&#x0A; addUserKnob {20 wired_tab l &quot;Wired Stamp&quot;}&#x0A; addUserKnob {26 identifier -STARTLINE +HIDDEN T wired}&#x0A; addUserKnob {3 lockCallbacks l &quot;&quot; +STARTLINE +HIDDEN}&#x0A; addUserKnob {6 toReconnect -STARTLINE +HIDDEN}&#x0A; addUserKnob {1 title l Title: t &quot;Displayed name on the Node Graph for this Stamp and its Anchor.\nIMPORTANT: This is only for display purposes, and is different from the real/internal name of the Stamps.&quot;}&#x0A; title aPlate&#x0A; addUserKnob {26 prev_title l &quot;&quot; +STARTLINE +HIDDEN T aPlate}&#x0A; addUserKnob {26 tags l Tags: t &quot;Tags of this stamp&apos;s Anchor, for information purpose only.\nClick \&quot;show anchor\&quot; to change them.&quot; +HIDDEN T &quot; &quot;}&#x0A; addUserKnob {26 backdrops l Backdrops: t &quot;Labels of backdrop nodes which contain this stamp&apos;s Anchor.&quot; +HIDDEN T &quot; &quot;}&#x0A; addUserKnob {26 line1 l &quot;&quot; +STARTLINE}&#x0A; addUserKnob {6 postageStamp_show l &quot;postage stamp&quot; t &quot;Enable the postage stamp thumbnail in this node.\nYou&apos;re seeing this because the class of this node includes the postage_stamp knob.&quot; +STARTLINE}&#x0A; addUserKnob {26 anchor_label l Anchor: T &quot; &quot;}&#x0A; addUserKnob {22 show_anchor l &quot; show anchor &quot; t &quot;Show the properties panel for this Stamp&apos;s Anchor.&quot; -STARTLINE T stamps.wiredShowAnchor()}&#x0A; addUserKnob {22 zoom_anchor l &quot;zoom anchor&quot; t &quot;Navigate to this Stamp&apos;s Anchor on the Node Graph.&quot; -STARTLINE T stamps.wiredZoomAnchor()}&#x0A; addUserKnob {26 stamps_label l Stamps: T &quot; &quot;}&#x0A; addUserKnob {22 zoomNext l &quot; zoom next &quot; t &quot;Navigate to this Stamp&apos;s next sibling on the Node Graph.&quot; -STARTLINE T stamps.wiredZoomNext()}&#x0A; addUserKnob {22 selectSimilar l &quot; select similar &quot; t &quot;Select all similar Stamps to this one on the Node Graph.&quot; -STARTLINE T stamps.wiredSelectSimilar()}&#x0A; addUserKnob {26 space_1 l &quot;&quot; +STARTLINE T &quot; &quot;}&#x0A; addUserKnob {26 reconnect_label l Reconnect: t &quot;Reconnect by the stored Anchor name.&quot; T &quot; &quot;}&#x0A; addUserKnob {22 reconnect_this l this t &quot;Reconnect this Stamp to its Anchor, by its stored Anchor name.&quot; -STARTLINE T &quot;n = nuke.thisNode()\ntry:\n    n.setInput(0,nuke.toNode(n.knob(\&quot;anchor\&quot;).value()))\nexcept:\n    nuke.message(\&quot;Unable to reconnect.\&quot;)\ntry:\n    import stamps\n    stamps.wiredGetStyle(n)\nexcept:\n    pass\n&quot;}&#x0A; addUserKnob {22 reconnect_similar l similar t &quot;Reconnect this Stamp and similar ones to their Anchor, by their stored anchor name.&quot; -STARTLINE T stamps.wiredReconnectSimilar()}&#x0A; addUserKnob {22 reconnect_all l all t &quot;Reconnect all the Stamps to their Anchors, by their stored anchor names.&quot; -STARTLINE T stamps.wiredReconnectAll()}&#x0A; addUserKnob {26 space_2 l &quot;&quot; +STARTLINE T &quot; &quot;}&#x0A; addUserKnob {20 advanced_reconnection l &quot;Advanced Reconnection&quot; n 2}&#x0A; addUserKnob {26 reconnect_by_title_label l &quot;&lt;font color=gold&gt;By Title:&quot; t &quot;Reconnect by searching for a matching title.&quot; T &quot; &quot;}&#x0A; addUserKnob {22 reconnect_by_title_this l this t &quot;Look for an Anchor that shares this Stamp&apos;s title, and connect this Stamp to it.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectByTitle()}&#x0A; addUserKnob {22 reconnect_by_title_similar l similar t &quot;Look for an Anchor that shares this Stamp&apos;s title, and connect this Stamp and similar ones to it.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectByTitleSimilar()}&#x0A; addUserKnob {22 reconnect_by_title_selected l selected t &quot;For each Stamp selected, look for an Anchor that shares its title, and connect to it.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectByTitleSelected()}&#x0A; addUserKnob {26 reconnect_by_selection_label l &quot;&lt;font color=orangered&gt;By Selection:&quot; t &quot;Force reconnect to a selected Anchor.&quot; T &quot; &quot;}&#x0A; addUserKnob {22 reconnect_by_selection_this l this t &quot;Force reconnect this Stamp to a selected Anchor, whatever its name or title.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectBySelection()}&#x0A; addUserKnob {22 reconnect_by_selection_similar l similar t &quot;Force reconnect this Stamp and similar ones to a selected Anchor, whatever its name or title.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectBySelectionSimilar()}&#x0A; addUserKnob {22 reconnect_by_selection_selected l selected t &quot;Force reconnect all selected Stamps to an also selected Anchor, whatever its name or title.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectBySelectionSelected()}&#x0A; addUserKnob {1 anchor l Anchor}&#x0A; anchor Anchor_286e15befe&#x0A; addUserKnob {6 auto_reconnect_by_title l &quot;&lt;font color=#ED9977&gt;&amp;nbsp; auto-reconnect by title&quot; t &quot;When creating this stamp again (like on copy-paste), auto-reconnect it by title instead of doing it by the saved anchor&apos;s name, and auto-turn this off immediately.\nIMPORTANT: Should be off by default. Only use this for setting up templates.&quot; +STARTLINE}&#x0A; addUserKnob {26 line2 l &quot;&quot; +STARTLINE}&#x0A; addUserKnob {22 buttonHelp l Help -STARTLINE T stamps.showHelp()}&#x0A; addUserKnob {26 version l &quot; &quot; t &quot;Stamps by Adrian Pueyo and Alexey Kuchinski.\nUpdated May 18 2021.&quot; -STARTLINE T &quot;&lt;a href=\&quot;http://www.nukepedia.com/gizmos/other/stamps\&quot; style=\&quot;color:#666;text-decoration: none;\&quot;&gt;&lt;span style=\&quot;color:#666\&quot;&gt; &lt;big&gt;Stamps v1.1&lt;/big&gt;&lt;/b&gt;&lt;/a&gt;&quot;}&#x0A;}&#x0A;push $Nda50e000&#x0A;PostageStamp {&#x0A; name Stamp2&#x0A; help &quot;Stamps by Adrian Pueyo and Alexey Kuchinski.\nUpdated May 18 2021&quot;&#x0A; onCreate &quot;if nuke.GUI:\n    try:\n        import stamps; stamps.wiredOnCreate()\n    except:\n        pass\n&quot;&#x0A; knobChanged &quot;import stamps; stamps.wiredKnobChanged()&quot;&#x0A; autolabel &quot;nuke.thisNode().knob(\&quot;title\&quot;).value()&quot;&#x0A; tile_color 0x1000001&#x0A; note_font Verdana&#x0A; note_font_size 20&#x0A; selected true&#x0A; hide_input true&#x0A; addUserKnob {20 wired_tab l &quot;Wired Stamp&quot;}&#x0A; addUserKnob {26 identifier -STARTLINE +HIDDEN T wired}&#x0A; addUserKnob {3 lockCallbacks l &quot;&quot; +STARTLINE +HIDDEN}&#x0A; addUserKnob {6 toReconnect -STARTLINE +HIDDEN}&#x0A; addUserKnob {1 title l Title: t &quot;Displayed name on the Node Graph for this Stamp and its Anchor.\nIMPORTANT: This is only for display purposes, and is different from the real/internal name of the Stamps.&quot;}&#x0A; title aDenoised&#x0A; addUserKnob {26 prev_title l &quot;&quot; +STARTLINE +HIDDEN T aDenoised}&#x0A; addUserKnob {26 tags l Tags: t &quot;Tags of this stamp&apos;s Anchor, for information purpose only.\nClick \&quot;show anchor\&quot; to change them.&quot; T &lt;i&gt;2D&lt;/i&gt;}&#x0A; addUserKnob {26 backdrops l Backdrops: t &quot;Labels of backdrop nodes which contain this stamp&apos;s Anchor.&quot; T &lt;i&gt;input&lt;/i&gt;}&#x0A; addUserKnob {26 line1 l &quot;&quot; +STARTLINE}&#x0A; addUserKnob {6 postageStamp_show l &quot;postage stamp&quot; t &quot;Enable the postage stamp thumbnail in this node.\nYou&apos;re seeing this because the class of this node includes the postage_stamp knob.&quot; +STARTLINE}&#x0A; addUserKnob {26 anchor_label l Anchor: T &quot; &quot;}&#x0A; addUserKnob {22 show_anchor l &quot; show anchor &quot; t &quot;Show the properties panel for this Stamp&apos;s Anchor.&quot; -STARTLINE T stamps.wiredShowAnchor()}&#x0A; addUserKnob {22 zoom_anchor l &quot;zoom anchor&quot; t &quot;Navigate to this Stamp&apos;s Anchor on the Node Graph.&quot; -STARTLINE T stamps.wiredZoomAnchor()}&#x0A; addUserKnob {26 stamps_label l Stamps: T &quot; &quot;}&#x0A; addUserKnob {22 zoomNext l &quot; zoom next &quot; t &quot;Navigate to this Stamp&apos;s next sibling on the Node Graph.&quot; -STARTLINE T stamps.wiredZoomNext()}&#x0A; addUserKnob {22 selectSimilar l &quot; select similar &quot; t &quot;Select all similar Stamps to this one on the Node Graph.&quot; -STARTLINE T stamps.wiredSelectSimilar()}&#x0A; addUserKnob {26 space_1 l &quot;&quot; +STARTLINE T &quot; &quot;}&#x0A; addUserKnob {26 reconnect_label l Reconnect: t &quot;Reconnect by the stored Anchor name.&quot; T &quot; &quot;}&#x0A; addUserKnob {22 reconnect_this l this t &quot;Reconnect this Stamp to its Anchor, by its stored Anchor name.&quot; -STARTLINE T &quot;n = nuke.thisNode()\ntry:\n    n.setInput(0,nuke.toNode(n.knob(\&quot;anchor\&quot;).value()))\nexcept:\n    nuke.message(\&quot;Unable to reconnect.\&quot;)\ntry:\n    import stamps\n    stamps.wiredGetStyle(n)\nexcept:\n    pass\n&quot;}&#x0A; addUserKnob {22 reconnect_similar l similar t &quot;Reconnect this Stamp and similar ones to their Anchor, by their stored anchor name.&quot; -STARTLINE T stamps.wiredReconnectSimilar()}&#x0A; addUserKnob {22 reconnect_all l all t &quot;Reconnect all the Stamps to their Anchors, by their stored anchor names.&quot; -STARTLINE T stamps.wiredReconnectAll()}&#x0A; addUserKnob {26 space_2 l &quot;&quot; +STARTLINE T &quot; &quot;}&#x0A; addUserKnob {20 advanced_reconnection l &quot;Advanced Reconnection&quot; n 2}&#x0A; addUserKnob {26 reconnect_by_title_label l &quot;&lt;font color=gold&gt;By Title:&quot; t &quot;Reconnect by searching for a matching title.&quot; T &quot; &quot;}&#x0A; addUserKnob {22 reconnect_by_title_this l this t &quot;Look for an Anchor that shares this Stamp&apos;s title, and connect this Stamp to it.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectByTitle()}&#x0A; addUserKnob {22 reconnect_by_title_similar l similar t &quot;Look for an Anchor that shares this Stamp&apos;s title, and connect this Stamp and similar ones to it.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectByTitleSimilar()}&#x0A; addUserKnob {22 reconnect_by_title_selected l selected t &quot;For each Stamp selected, look for an Anchor that shares its title, and connect to it.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectByTitleSelected()}&#x0A; addUserKnob {26 reconnect_by_selection_label l &quot;&lt;font color=orangered&gt;By Selection:&quot; t &quot;Force reconnect to a selected Anchor.&quot; T &quot; &quot;}&#x0A; addUserKnob {22 reconnect_by_selection_this l this t &quot;Force reconnect this Stamp to a selected Anchor, whatever its name or title.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectBySelection()}&#x0A; addUserKnob {22 reconnect_by_selection_similar l similar t &quot;Force reconnect this Stamp and similar ones to a selected Anchor, whatever its name or title.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectBySelectionSimilar()}&#x0A; addUserKnob {22 reconnect_by_selection_selected l selected t &quot;Force reconnect all selected Stamps to an also selected Anchor, whatever its name or title.\nIMPORTANT: Use this carefully, and only when the normal reconnection doesn&apos;t work.&quot; -STARTLINE T stamps.wiredReconnectBySelectionSelected()}&#x0A; addUserKnob {1 anchor l Anchor}&#x0A; anchor Anchor_1218aa251d&#x0A; addUserKnob {6 auto_reconnect_by_title l &quot;&lt;font color=#ED9977&gt;&amp;nbsp; auto-reconnect by title&quot; t &quot;When creating this stamp again (like on copy-paste), auto-reconnect it by title instead of doing it by the saved anchor&apos;s name, and auto-turn this off immediately.\nIMPORTANT: Should be off by default. Only use this for setting up templates.&quot; +STARTLINE}&#x0A; addUserKnob {26 line2 l &quot;&quot; +STARTLINE}&#x0A; addUserKnob {22 buttonHelp l Help -STARTLINE T stamps.showHelp()}&#x0A; addUserKnob {26 version l &quot; &quot; t &quot;Stamps by Adrian Pueyo and Alexey Kuchinski.\nUpdated May 18 2021.&quot; -STARTLINE T &quot;&lt;a href=\&quot;http://www.nukepedia.com/gizmos/other/stamps\&quot; style=\&quot;color:#666;text-decoration: none;\&quot;&gt;&lt;span style=\&quot;color:#666\&quot;&gt; &lt;big&gt;Stamps v1.1&lt;/big&gt;&lt;/b&gt;&lt;/a&gt;&quot;}&#x0A;}&#x0A;set Nda50d400 [stack 0]&#x0A;Group {&#x0A; inputs 3&#x0A; name DasGrain&#x0A; help &quot;DasGrain makes regraining as simple as clicking a few buttons.\n\nFollow the steps in the Help tab and you&apos;ll have a perfect regrain in no time!&quot;&#x0A; onCreate &quot;import random\n\ntestimonials = \[\n    \&quot;Such an elegant solution, love it!\&quot;,\n    \&quot;Your gizmo is beyond expectation\&quot;,\n    \&quot;Totally awesome!\&quot;,\n    \&quot;DasGrain is officially the best thing ever\&quot;,\n    \&quot;It&apos;s really working!\&quot;,\n    \&quot;Das bringt Tr&amp;auml;nen in meine Augen\&quot;,\n    \&quot;DasGrain is the salvation we waited for\&quot;,\n    \&quot;I save a lot of time, and definitely my nerves :)\&quot;,\n    \&quot;It&apos;s alright\&quot;,\n    \&quot;My new favourite node, thanks!&lt;br&gt;Having said that, ...\&quot;\n    ]\n\nnode = nuke.thisNode()\nnode\[&apos;testimonial&apos;].setValue(&apos;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;i&gt;&amp;laquo;%s&amp;raquo;&lt;/i&gt;&lt;br&gt;&amp;mdash; anonymous&lt;br&gt;&lt;br&gt;&apos; % random.choice(testimonials))\nnode\[&apos;box&apos;].setFlag(nuke.NO_ANIMATION)&quot;&#x0A; knobChanged &quot;n = nuke.thisNode()\nk = nuke.thisKnob()\n\nif k.name() == &apos;box&apos;:\n    this_frame = nuke.frame()\n    n\[&apos;sample_frame&apos;].setValue(this_frame)\n\nif k.name() == &apos;scatter&apos;:\n    n\[&apos;divider04&apos;].setVisible(k.value() == False)\n    n\[&apos;divider05&apos;].setVisible(k.value() == True)&quot;&#x0A; tile_color 0x7f7f7fff&#x0A; selected true&#x0A; addUserKnob {20 DasGrain_tab l DasGrain}&#x0A; addUserKnob {41 output t &quot;&lt;strong&gt;regrained comp&lt;/strong&gt; it is what it sais\n&lt;strong&gt;plate grain&lt;/strong&gt; plate minus degrained plate\n&lt;strong&gt;normalised grain&lt;/strong&gt; check if the normalization worked. It should be as even as possible. This is what you want to output if you want to prerender a grain plate. Later you can plug it into the &lt;i&gt;external grain&lt;/i&gt; input of another DasGrain\n&lt;strong&gt;adapted grain&lt;/strong&gt; check if the adaptation worked. Output this if you want to further manipulate the grain (who knows what the sup is gonna come up with...). After, simply plus it to your comp (at that point the comp has to be in the &lt;i&gt;camera&lt;/i&gt; colorspace, as set in the &lt;i&gt;Analyze&lt;/i&gt; tab).\n&lt;strong&gt;grain QC&lt;/strong&gt; check if voronoi seams are visible (&amp;#8594; edgeblend), or the scattered grain looks different to the original plate grain (&amp;#8594; maybe bad sample area or wrong luminance degrain amount)&quot; T Output.output}&#x0A; addUserKnob {4 meta l &quot;metadata from&quot; t &quot;Chances are you want to use the metadata from the plate, but who am I to assume :)&quot; M {COMP PLATE}}&#x0A; addUserKnob {26 spacer01_1 l &quot; &quot; T &quot; &quot;}&#x0A; addUserKnob {20 GrainGroupBegin l &quot;&quot; +STARTLINE n -2}&#x0A; addUserKnob {20 Analyze_tab l Analyze}&#x0A; addUserKnob {26 text l &lt;strong&gt;Colorspace}&#x0A; addUserKnob {41 project_colorspace l project t &quot;set this to the project color space&quot; T OCIOColorSpace1.in_colorspace}&#x0A; addUserKnob {22 python_button l &quot;What&apos;s this all about?&quot; -STARTLINE T &quot;nuke.message(\&quot;Regraining in other color spaces than the camera native linear space can lead to unexpected behaviour.\\n\\nFor example converting Alexa plates to ACEScg might introduce negative values due to ACEScg&apos;s smaller gamut. In that case converting back to ARRI Linear ALEXA Wide Gamut will probably help.\\nJust set &lt;i&gt;project&lt;/i&gt; to ACEScg and &lt;i&gt;camera&lt;/i&gt; to ARRI Linear ALEXA Wide Gamut.\\n\\nThis might be transferable to other cameras, but I&apos;ve only tested with Alexas.\\n---------\\nBypass by setting both knobs to the same value.\&quot;)&quot;}&#x0A; addUserKnob {41 camera_colorspace l camera t &quot;set this to the camera native linear space&quot; T OCIOColorSpace1.out_colorspace}&#x0A; addUserKnob {26 text_2 l &quot; &quot; T &quot; &quot;}&#x0A; addUserKnob {26 level l &quot;&lt;strong&gt;Degrain amount&quot;}&#x0A; addUserKnob {78 luminance t &quot;Leave this at 1 if you&apos;re working on a completely degrained plate.\n\nIn case you decided to leave some luminance grain in the degrained plate (use the DegrainHelper node for this!), set this to the same value as in the DegrainHelper in order to compensate.\n\nIf the luminance degrain amount was set to 0.8, this needs to be set to 0.8 as well.\n\nYou need to select a mask of all elements that cover the plate, otherwise the grain of whole comp will be too strong &quot; n 1}&#x0A; luminance 1&#x0A; addUserKnob {26 divider01 l &quot; &quot;}&#x0A; addUserKnob {41 degrain_amount_mask l &quot;degrain amount mask&quot; t &quot;Use this channel from the mask input to specify in what area of the comp the missing luminance grain needs to be compensated.&quot; T Multiply1.maskChannelMask}&#x0A; addUserKnob {41 invert_mask l invert -STARTLINE T Multiply1.invert_mask}&#x0A; addUserKnob {26 spacer02 l &quot; &quot; T &quot; &quot;}&#x0A; addUserKnob {26 divider02 l &lt;strong&gt;Analyze}&#x0A; addUserKnob {3 number_of_frames l &quot;number of frames&quot; t &quot;Set the number of sample frames to be spread across the input range.\n\nMore frames lead to higher accuracy.\n\nIf there are particularly bright or dark frames, set them manually in the knob below to make sure they are part of the analysis.\n\nIf you want to set all sample frames manually, set this to 0 and add the frames in the knob below.&quot;}&#x0A; number_of_frames 10&#x0A; addUserKnob {1 additional_frames l &quot;additional frames&quot; t &quot;Set additional frames like this:\n\n1001,1020,1053 (single frames)\n1020-1040 (frame ranges)\n1020-1040x4 (frame ranges with step)&quot;}&#x0A; addUserKnob {3 sample_count l &quot;sample count&quot; t &quot;The samples are spread across the sample range (which gets calculated automatically) based on the AlexaV3LogC curve. This results in more samples in the dark areas and less samples in the brights.\n\nMore samples lead to a more detailed response curve (while the accuracy is limited by the quality of the degrain).&quot;}&#x0A; sample_count 20&#x0A; addUserKnob {22 analyze l Analyze t &quot;this is where the magic happens&quot; T &quot;import base64\nthis = nuke.thisNode()\n\n\ndef _sample_count(this):\n    \&quot;\&quot;\&quot;returns the sample count\&quot;\&quot;\&quot;\n\n    sample_count = int(this\[&apos;sample_count&apos;].value())\n\n    if sample_count &lt;= 0:\n        raise RuntimeError(&apos;Enter a sample count greater than 0&apos;)\n\n    else:\n        return sample_count\n\n\ndef _generate_frame_list(this):\n    \&quot;\&quot;\&quot;converts the frames submitted by the user into a list\&quot;\&quot;\&quot;\n\n    frame_list = \[]\n    number_of_frames = int(this\[&apos;number_of_frames&apos;].value())\n    additional_frames = this\[&apos;additional_frames&apos;].value()\n\n    if number_of_frames &lt; 1 and additional_frames is &apos;&apos;:\n        raise RuntimeError(&apos;Either set the number of frames &gt; 0\\nor define additional frames&apos;)\n\n    first_frame = max(this.input(1).firstFrame(), this.input(2).firstFrame())\n    last_frame = min(this.input(1).lastFrame(), this.input(2).lastFrame())\n\n    if number_of_frames &gt; 0:\n        distance = (last_frame - first_frame) / (number_of_frames)\n        frame = first_frame + distance / 2\n\n        for x in range(number_of_frames):\n            int_frame = int(round(frame))\n            if int_frame not in frame_list:\n                frame_list.append(int_frame)\n\n            frame += distance\n\n    frange = nuke.FrameRanges(additional_frames.split(&apos;,&apos;))\n\n    for r in frange:\n        for f in r:\n            if f &gt;= first_frame and f &lt;= last_frame:\n                if f not in frame_list:\n                    frame_list.append(f)\n\n    frame_list.sort()\n\n    return frame_list\n\n\ndef _setup_for_multiframe(frame_list):\n    \&quot;\&quot;\&quot; arranges all sample frames next to each other, starting at frame 0\n    and sets the frame number knob of the FrameBlend node\&quot;\&quot;\&quot;\n\n    time_warp = nuke.toNode(&apos;TimeWarp1&apos;)\n    time_warp\[&apos;lookup&apos;].clearAnimated()\n    time_warp\[&apos;lookup&apos;].setAnimated()\n    anim_list = \[]\n\n    for n, frame in enumerate(frame_list):\n        anim_list.append(nuke.AnimationKey(n, frame))\n\n    anim = time_warp\[&apos;lookup&apos;].animation(0)\n    anim.addKey(anim_list)\n\n    frame_blend = nuke.toNode(&apos;FrameBlend1&apos;)\n    frame_blend\[&apos;endframe&apos;].setValue(len(frame_list)-1)\n\n\ndef _generate_sample_list(sample_count, sample_range, sample_radius):\n    \&quot;\&quot;\&quot;generate a list of sample values spread equally between the\n    min and max values of the sample range\&quot;\&quot;\&quot;\n\n    sample_list = \[]\n\n    for item in range(0, sample_count):\n        sample_list.append(float(item) / sample_count * (sample_range\[1] - sample_range\[0]) + sample_range\[0] + sample_radius)\n\n    return sample_list\n\n\ndef _get_sample_range(channel, channel_list, frame_list):\n    \&quot;\&quot;\&quot; samples the minimum and maximum values of the given frame range and\n    sets the sample range to those values\&quot;\&quot;\&quot;\n\n    curve_tool = nuke.toNode(&apos;CurveTool_Range&apos;)\n    min_knob = curve_tool\[&apos;minlumapixvalue&apos;]\n    max_knob = curve_tool\[&apos;maxlumapixvalue&apos;]\n\n    min_knob.setAnimated()\n    max_knob.setAnimated()\n\n    curve_tool\[&apos;channels&apos;].setValue(channel)\n\n    nuke.execute(curve_tool, nuke.FrameRanges(frame_list))\n\n    index = channel_list.index(channel)\n    min_list = \[key.y for key in min_knob.animation(index).keys()]\n    max_list = \[key.y for key in max_knob.animation(index).keys()]\n\n    min_value = min(min_list)\n    max_value = max(max_list)\n\n    min_knob.clearAnimated()\n    max_knob.clearAnimated()\n    curve_tool\[&apos;minlumapixdata&apos;].clearAnimated()\n    curve_tool\[&apos;maxlumapixdata&apos;].clearAnimated()\n\n    return \[min_value, max_value]\n\n\ndef _sample_it(keyer, curve_tool, sample, sample_radius):\n    \&quot;\&quot;\&quot;analyze the grain level per channel and sample value in the sample range\&quot;\&quot;\&quot;\n\n    keyer\[&apos;temp_expr0&apos;].setValue(str(sample - sample_radius))\n    keyer\[&apos;temp_expr1&apos;].setValue(str(sample + sample_radius))\n\n    intensity_knob = curve_tool\[&apos;intensitydata&apos;]\n    intensity_knob.clearAnimated()\n    intensity_knob.setAnimated()\n\n    nuke.execute(curve_tool, nuke.frame(), nuke.frame())\n    sample_values = intensity_knob.value()\n    intensity_knob.clearAnimated()\n\n    return sample_values\n\n\ndef check_inputs(this):\n    if this.input(1) is None:\n        raise RuntimeError(&apos;no plate connected&apos;)\n\n    if this.input(2) is None:\n        raise RuntimeError(&apos;no degrained plate connected&apos;)\n\n    def format_tuple(node):\n        return node.format().width(), node.format().height(), node.format().pixelAspect()\n\n    if format_tuple(this.input(1)) != format_tuple(this.input(2)):\n        raise RuntimeError(\&quot;Format missmatch: Make sure the formats of plate and degrained plate match.\&quot;)\n\n\ndef start(this):\n    \&quot;\&quot;\&quot;let&apos;s do this!\&quot;\&quot;\&quot;\n\n    check_inputs(this)\n\n    with this:\n        frame_list = _generate_frame_list(this)\n        _setup_for_multiframe(frame_list)\n        sample_count = _sample_count(this)\n\n        blank = base64.b64decode(&apos;cmVkIHtjdXJ2ZX0KZ3JlZW4ge2N1cnZlfQpibHVlIHtjdXJ2ZX0=&apos;).decode(&apos;ascii&apos;)\n\n        lut = nuke.toNode(&apos;Sampler1&apos;)\[&apos;lut&apos;]\n        lut.fromScript(blank)\n\n        channel_list = \[&apos;red&apos;, &apos;green&apos;, &apos;blue&apos;]\n\n        keyer = nuke.toNode(&apos;Expression2&apos;)\n        copy = nuke.toNode(&apos;Copy2&apos;)\n\n        curve_tool = nuke.toNode(&apos;CurveTool&apos;)\n        pixel = curve_tool\[&apos;ROI&apos;].value()\[2] * curve_tool\[&apos;ROI&apos;].value()\[3]\n\n        task = nuke.ProgressTask(&apos;Analysing...&apos;)\n        step = 100.0 / 3 / sample_count\n        progress = step\n\n        time_warp = nuke.toNode(&apos;TimeWarp1&apos;)\n        frame_blend = nuke.toNode(&apos;FrameBlend1&apos;)\n\n        time_warp\[&apos;disable&apos;].setValue(False)\n        frame_blend\[&apos;disable&apos;].setValue(False)\n\n        for channel in channel_list:\n            task.setMessage(&apos;\{\} range&apos;.format(channel))\n\n            copy\[&apos;from0&apos;].setValue(&apos;rgba.\{\}&apos;.format(channel))\n\n            sample_range = _get_sample_range(channel, channel_list, frame_list)\n            sample_radius = (sample_range\[1] - sample_range\[0]) / sample_count / 2\n            sample_list = _generate_sample_list(sample_count, sample_range, sample_radius)\n\n            for sample in sample_list:\n                if task.isCancelled():\n                    return\n\n                task.setProgress(int(progress))\n\n                sample_values = _sample_it(keyer, curve_tool, sample, sample_radius)\n\n                task.setMessage(&apos;\{\} channel at \{\}&apos;.format(channel, round(sample, 2)))\n\n                if sample_values\[3] * pixel &gt;= 10:\n                    lut.setValueAt(sample_values\[0] / sample_values\[3], sample_values\[1] / sample_values\[3], channel_list.index(channel))\n\n                progress += step\n\n        time_warp\[&apos;lookup&apos;].clearAnimated()\n        time_warp\[&apos;disable&apos;].setValue(True)  # hopefully prevents slowing down the comp\n        frame_blend\[&apos;disable&apos;].setValue(True)  # hopefully prevents slowing down the comp\n\n    del task\n\n\nstart(this)\n&quot; +STARTLINE}&#x0A; addUserKnob {26 divider03 l &quot; &quot;}&#x0A; addUserKnob {41 analysis_mask l &quot;analysis mask&quot; t &quot;Use this channel from the mask input to control what area of the plate will be analyzed.\n\nUsefull if the degrain is obviously bad in some areas.&quot; T ChannelMerge1.A}&#x0A; addUserKnob {6 invert_1 l invert -STARTLINE}&#x0A; addUserKnob {20 Adjust_tab l Adjust}&#x0A; addUserKnob {22 whatsthis l &quot;What am I looking at?&quot; T &quot;nuke.message(\&quot;After the analysis you&apos;ll see the sampled grain response curves here. On the x-axis is the brightness of the image and on the y-axis the grain intensity. Grain increases with brightness, so &lt;strong&gt;the slope of the curves should always be positive&lt;/strong&gt; (they should always go up &amp;#8599;).&lt;br&gt;&lt;br&gt;The quality of the curves depends entirely on the quality of the degrain. If the curves look wrong (for example they go up and down), try to improve the degrain first. If they still look wrong and the resulting regrain doesn&apos;t work well enough, you can try to improve the curves here by deleting/correcting all points that don&apos;t follow an upwards trend.&lt;br&gt;&lt;br&gt;You can also extend the curves (again: with an upwards trend) if the comp has values that don&apos;t exist in the plate.&lt;br&gt;&lt;br&gt;Note: The curve is used for both the normalization as well as the adaptation of the grain, so it doesn&apos;t give direct control of the grain intensity.\&quot;)&quot; +STARTLINE}&#x0A; addUserKnob {41 lut l &quot;&quot; +STARTLINE T Sampler1.lut}&#x0A; addUserKnob {20 Replace_tab l Replace}&#x0A; addUserKnob {6 external_grain l &quot;use external grain&quot; t &quot;Use external grain from a second DasGrain, with the output set to &apos;normalised grain&apos;, to replace masked area.\nConnect it to the &apos;external grain&apos; input of this DasGrain (it&apos;s a bit hidden on the left side of the node).&quot; +STARTLINE}&#x0A; addUserKnob {26 divider04 l &lt;strong&gt;Scatter}&#x0A; addUserKnob {26 divider05 l &lt;strong&gt;Scatter +HIDDEN T &quot;&lt;span style=\&quot;color:red\&quot;&gt;Make sure you&apos;re sampling an area without any plate detail.&lt;/a&gt;&quot;}&#x0A; addUserKnob {6 scatter l activate t &quot;Activates the scatter function. It generates a new grain based on the plate grain in the sample box using a Voronoi noise.&quot; +STARTLINE}&#x0A; addUserKnob {41 useGPUIfAvailable l &quot;Use GPU if available&quot; -STARTLINE T VoronoiScatter.useGPUIfAvailable}&#x0A; addUserKnob {15 box l &quot;sample box&quot; t &quot;Define an area that is used as a source for the scatter function. The plate grain in this area should be as even as possible, without any visible detail.&quot;}&#x0A; box {100 100 500 300}&#x0A; addUserKnob {3 sample_frame l &quot;sample frame&quot; t &quot;The frame at which the grain is being sampled. Is set automatically once the sample box is changed.&quot; +DISABLED}&#x0A; sample_frame 1&#x0A; addUserKnob {4 stereo l &quot;stereo behaviour&quot; t &quot;randomize offset per view: same voronoy pattern for all views, but different offset\n\nrandomize pattern per view: different voronoy pattern for every view&quot; M {none &quot;randomize offset per view&quot; &quot;randomize pattern per view&quot; &quot;&quot;}}&#x0A; addUserKnob {26 spacer06 l &quot;&quot; +STARTLINE T &quot; &quot;}&#x0A; addUserKnob {6 overlay l &quot;overlay cell pattern&quot; t &quot;Overlay the cell pattern of the voronoy noise. Useful to check where the seams are and if distortion or blending is necessary.&quot; +STARTLINE}&#x0A; addUserKnob {7 cell_size l &quot;cell size&quot; t &quot;Cell size of the scatter. Shoudn&apos;t be too small, as lower grain frequencies might break.\nCan&apos;t be too big either, to prevent it from breaking the border of the samplebox (will error if it does).&quot; R 5 100}&#x0A; cell_size 40&#x0A; addUserKnob {26 spacer07 l &quot;&quot; +STARTLINE T &quot; &quot;}&#x0A; addUserKnob {20 concealer l &quot;edge concealer&quot; n 1}&#x0A; concealer 0&#x0A; addUserKnob {26 concealer_help l &quot; &quot; T &quot;If you can see the voronoi pattern in the grain QC output,\nincrease the edge blend size.&quot;}&#x0A; addUserKnob {3 edge_blend_size l &quot;edge blend size&quot; t &quot;Set the output to grain QC. If you see the cell seams, increase the edge blend size to conceal them.\n\nThis is a bit hacky and slow.&quot;}&#x0A; addUserKnob {26 tip l &quot;&quot; -STARTLINE T &quot;sloooow - keep this below 3 if possible&quot;}&#x0A; addUserKnob {26 distortion_help l &quot; &quot; T &quot;\nDistortion might help as well, if somehow the straight\nseams are visible (you might want to toggle the overlay\nwhile adjusting).&quot;}&#x0A; addUserKnob {7 amplitude R 0 50}&#x0A; addUserKnob {7 frequency R 0 50}&#x0A; frequency 15&#x0A; addUserKnob {20 endGroup n -1}&#x0A; addUserKnob {26 divider06 l &quot;&quot; +STARTLINE}&#x0A; addUserKnob {41 replace_mask l &quot;replace mask&quot; t &quot;Use this channel from the mask input to specify where you want to use scattered grain instead of the adapted plate grain.&quot; -STARTLINE T Merge9.maskChannelMask}&#x0A; addUserKnob {41 invert_mask_1 l invert -STARTLINE T Merge9.invert_mask}&#x0A; addUserKnob {20 GrainGroupEnd l &quot;&quot; +STARTLINE n -3}&#x0A; addUserKnob {20 Help_tab l Help}&#x0A; addUserKnob {26 basic_setup l &quot;&quot; +STARTLINE T &quot;&lt;font size=\&quot;5\&quot;&gt;Basic setup&lt;/font&gt;&quot;}&#x0A; addUserKnob {26 &quot;&quot;}&#x0A; addUserKnob {26 explanation l &quot;&quot; +STARTLINE T &quot;&lt;strong&gt;Bold&lt;/strong&gt; steps are always necessary&quot;}&#x0A; addUserKnob {26 steps l &quot;&quot; +STARTLINE T &quot;&lt;br&gt;&lt;strong&gt;1. This should be the only regrain node in your comp.&lt;br&gt;2. Connect &lt;i&gt;plate&lt;/i&gt;, &lt;i&gt;degrained plate&lt;/i&gt; and &lt;i&gt;comp&lt;/i&gt;.&lt;br&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;The comp should be done on the degrained plate!&lt;/strong&gt;&lt;br&gt;3. Set the &lt;i&gt;luminance degrain amount&lt;/i&gt;.&lt;br&gt;&lt;strong&gt;4. Press the &lt;i&gt;Analyze&lt;/i&gt; button.&lt;/strong&gt;&lt;br&gt;5. Correct the response curves in the &lt;i&gt;Adjust&lt;/i&gt; tab.&lt;br&gt;6. Move the &lt;i&gt;sample box&lt;/i&gt; to an area without any plate detail and activate &lt;i&gt;scatter&lt;/i&gt;.&lt;br&gt;7. If necessary, activate &lt;i&gt;edge blend&lt;/i&gt; and/or &lt;i&gt;distortion&lt;/i&gt; to conceal seams.&quot;}&#x0A; addUserKnob {26 in_depth l &quot;&quot; +STARTLINE T &quot;&lt;br&gt;For an in depth explanation of the steps, read the tooltips and check out this video:&lt;br&gt;&lt;a href=\&quot;https://vimeo.com/284820390/\&quot;&gt;&lt;span style=\&quot;color:#C8C8C8;\&quot;&gt;https://vimeo.com/284820390&lt;/a&gt;&quot;}&#x0A; addUserKnob {26 pushthebutton l &quot;&quot; +STARTLINE T &quot;&lt;br&gt;&lt;br&gt;If the result is not as expected and you don&apos;t know why, push this button:&quot;}&#x0A; addUserKnob {22 troubleshoot l Troubleshoot t HEEEEEEELP T &quot;import base64\n\nmessages = \[]\n\nthis = nuke.thisNode()\n\n#########################\n\nif this.input(0) is None or this.input(1) is None or this.input(2) is None:\n    messages.append(\&quot;&lt;font color=&apos;red&apos;&gt;&lt;strong&gt;ERROR&lt;/strong&gt;&lt;/font&gt; Plate, degrained plate and comp need to be connected to the appropriate inputs.\&quot;)\n\n#########################\n\nelse:\n\n    def format_to_tuple(g):\n        \&quot;\&quot;\&quot;returns (1024, 786, 2.0)\n        \&quot;\&quot;\&quot;\n        return (g.format().width(), g.format().height(), g.format().pixelAspect())\n\n    format_set = set(\[\n        format_to_tuple(this.input(0)),\n        format_to_tuple(this.input(1)),\n        format_to_tuple(this.input(2)),\n        ])\n    if len(format_set) != 1:\n        messages.append(\&quot;&lt;font color=&apos;orange&apos;&gt;&lt;strong&gt;WARNING&lt;/strong&gt;&lt;/font&gt; Format missmatch: Make sure formats of plate, degrained plate and comp match.\&quot;)\n\n    if (this.input(1).firstFrame() != this.input(2).firstFrame()) or (this.input(1).lastFrame() != this.input(2).lastFrame()):\n        messages.append(\&quot;&lt;font color=&apos;orange&apos;&gt;&lt;strong&gt;WARNING&lt;/strong&gt;&lt;/font&gt; The frame ranges of plate and degrained plate don&apos;t match. Double check that they belong together.\&quot;)\n\n#########################\n\nmessages.append(\&quot;Double check that plate and degrained plate haven&apos;t been modified in any way (paint, despill, etc).\&quot;)\n\n#########################\n\nif this\[&apos;luminance&apos;].getValue() == 1:\n    messages.append(\&quot;Are you working on a completely degrained plate? If not, you might have to set the luminance degrain amount.\&quot;)\n\n#########################\n\nblank = base64.b64decode(&apos;cmVkIHtjdXJ2ZX0KZ3JlZW4ge2N1cnZlfQpibHVlIHtjdXJ2ZX0=&apos;).decode(&apos;ascii&apos;)\n\nwith this:\n    Sampler = nuke.toNode(&apos;Sampler1&apos;)     \n    if Sampler\[&apos;lut&apos;].toScript() == blank:\n        messages.append(\&quot;&lt;font color=&apos;red&apos;&gt;&lt;strong&gt;ERROR&lt;/strong&gt;&lt;/font&gt; You haven&apos;t pressed the Analyze button yet!\&quot;)\n\n#########################\n\nclass BadThings(Exception): pass\n\ndef thingy():\n    with this:\n        Sampler = nuke.toNode(&apos;Sampler1&apos;)\n        list = this\[&apos;lut&apos;].toScript().replace(&apos;\}&apos;,&apos;&apos;).split(&apos;\\n&apos;)\n        for item in list:\n            sample_value = 0\n            for value in item.split(&apos; &apos;):\n                try:\n                    value == float(value)\n                    if value &lt; sample_value:\n                        raise BadThings(\&quot;&lt;font color=&apos;orange&apos;&gt;&lt;strong&gt;WARNING&lt;/strong&gt;&lt;/font&gt; Check and fix the response curves. Their slopes should always be positive (the curves should always go up &amp;#8599;).\&quot;)\n                        \n                    else:\n                        sample_value = value\n                except ValueError:\n                    # Ignore non-numeric things like x-values of \&quot;x5.46\&quot; and channel names like \&quot;red\{\&quot; etc\n                    pass\ntry:\n    thingy()\nexcept BadThings as e:\n    messages.append(str(e))\n    \n#########################\n\nif this\[&apos;scatter&apos;].value() == True:\n    if this\[&apos;box&apos;].getValue() == \[100.0, 100.0, 500.0, 300.0]:\n        messages.append(\&quot;&lt;font color=&apos;orange&apos;&gt;&lt;strong&gt;WARNING&lt;/strong&gt;&lt;/font&gt; Scatter has been activated, but the sample box is still in its default position. Are you sure that&apos;s a good area to sample?\&quot;)\n\n#########################\n\nmessages.append(\&quot;Did you copy/paste DasGrain from another script? Make sure to reanalyze and to reset the sample area if you are using scatter.\&quot;)\n\n#########################\n\nif len(messages) &gt; 0:\n    nuke.message(\&quot;&lt;font size=\\\&quot;5\\\&quot;&gt;Things worth checking&lt;/font&gt;&lt;br&gt;&lt;br&gt;\&quot;\n                               \&quot;%s&lt;br&gt;&lt;br&gt;&lt;br&gt;If any of this doesn&apos;t make sense to you, it might be worth checking out the video on vimeo.\&quot; % (\n                                  \&quot;&lt;hr&gt;\&quot;.join(\&quot;%s: %s\&quot; % (i+1, m) for i, m in enumerate(messages))))\n&quot; +STARTLINE}&#x0A; addUserKnob {26 dont_despair l &quot;&quot; +STARTLINE T &quot;&lt;br&gt;If it still doesn&apos;t work and you&apos;re about to flip the table, send me a &lt;a href=\&quot;mailto:holtzf+nuke@gmail.com?subject=Help with DasGrain v1.7.8\&quot;&gt;&lt;span style=\&quot;color:#C8C8C8;\&quot;&gt;mail&lt;/a&gt;.&lt;br&gt;I&apos;m happy to help! :)&quot;}&#x0A; addUserKnob {20 Info_tab l Info}&#x0A; addUserKnob {26 dasname l &quot;&quot; +STARTLINE T &quot;&lt;font size=&apos;5&apos;&gt;DasGrain&lt;/font&gt; v1.8&lt;br&gt;&quot;}&#x0A; addUserKnob {26 text_1 l &quot;&quot; +STARTLINE T &quot;DasGrain makes regraining as simple as clicking a few buttons.&lt;br&gt;Follow the steps in the &lt;i&gt;Help&lt;/i&gt; tab and you&apos;ll have a perfect\nregrain&lt;br&gt;in no time!&quot;}&#x0A; addUserKnob {26 &quot;&quot;}&#x0A; addUserKnob {26 info l &quot;&quot; +STARTLINE T &quot;Last change: 2021-03-07\n\n&quot;}&#x0A; addUserKnob {26 name_1 l &quot;&quot; +STARTLINE T &quot;Fabian Holtz&quot;}&#x0A; addUserKnob {26 mail l &quot;&quot; +STARTLINE T &quot;&lt;a href=\&quot;mailto:holtzf+nuke@gmail.com?subject=Help with DasGrain v1.7.8\&quot;&gt;&lt;span style=\&quot;color:#C8C8C8;\&quot;&gt;holtzf+nuke@gmail.com&lt;/a&gt;&quot;}&#x0A; addUserKnob {26 testimonial l &quot;&quot; +STARTLINE T &quot;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;i&gt;&amp;laquo;Totally awesome!&amp;raquo;&lt;/i&gt;&lt;br&gt;&amp;mdash; anonymous&lt;br&gt;&lt;br&gt;&quot;}&#x0A; addUserKnob {26 &quot;&quot;}&#x0A; addUserKnob {26 credit l &quot;&quot; +STARTLINE T &quot;&lt;br&gt;VoronoiScatter based on &lt;a href=\&quot;http://www.nukepedia.com/blink/image/voronoi/\&quot;&gt;&lt;span style=\&quot;color:#C8C8C8;\&quot;&gt;Ivan Busquets&apos; implementation&lt;/a&gt; of&lt;br&gt; libNoise&apos;s\nVoronoi generator&quot;}&#x0A; addUserKnob {26 thanks l &quot;&quot; +STARTLINE T &quot;&lt;br&gt;Special thanks to Ben Dickson for bearing with my questions and&lt;br&gt;problems and RSP comp for the valuable feedback.&quot;}&#x0A;}&#x0A; BackdropNode {&#x0A;  inputs 0&#x0A;  name BackdropNode1&#x0A;  tile_color 0x7f7f7fff&#x0A;  label &quot;normalise grain&quot;&#x0A;  note_font_size 30&#x0A;  bdwidth 320&#x0A;  bdheight 110&#x0A; }&#x0A; BackdropNode {&#x0A;  inputs 0&#x0A;  name BackdropNode11&#x0A;  tile_color 0x7f7f7fff&#x0A;  label &quot;add grain&quot;&#x0A;  note_font_size 30&#x0A;  bdwidth 320&#x0A;  bdheight 110&#x0A; }&#x0A; BackdropNode {&#x0A;  inputs 0&#x0A;  name BackdropNode13&#x0A;  tile_color 0x7f7f7fff&#x0A;  label scatter&#x0A;  note_font_size 30&#x0A;  bdwidth 320&#x0A;  bdheight 110&#x0A; }&#x0A; BackdropNode {&#x0A;  inputs 0&#x0A;  name BackdropNode14&#x0A;  tile_color 0x7f7f7fff&#x0A;  label &quot;analyze grain&quot;&#x0A;  note_font_size 30&#x0A;  bdwidth 319&#x0A;  bdheight 877&#x0A; }&#x0A; BackdropNode {&#x0A;  inputs 0&#x0A;  name BackdropNode2&#x0A;  tile_color 0x7f7f7fff&#x0A;  label &quot;grain response curve&quot;&#x0A;  note_font_size 30&#x0A;  bdwidth 320&#x0A;  bdheight 110&#x0A; }&#x0A; BackdropNode {&#x0A;  inputs 0&#x0A;  name BackdropNode3&#x0A;  tile_color 0x7f7f7fff&#x0A;  label QC&#x0A;  note_font_size 30&#x0A;  bdwidth 320&#x0A;  bdheight 110&#x0A; }&#x0A; BackdropNode {&#x0A;  inputs 0&#x0A;  name BackdropNode4&#x0A;  tile_color 0x7f7f7fff&#x0A;  label &quot;grain response curve&quot;&#x0A;  note_font_size 30&#x0A;  bdwidth 320&#x0A;  bdheight 110&#x0A; }&#x0A; BackdropNode {&#x0A;  inputs 0&#x0A;  name BackdropNode5&#x0A;  tile_color 0x7f7f7fff&#x0A;  label &quot;adapt grain&quot;&#x0A;  note_font_size 30&#x0A;  bdwidth 320&#x0A;  bdheight 110&#x0A; }&#x0A; BackdropNode {&#x0A;  inputs 0&#x0A;  name BackdropNode6&#x0A;  tile_color 0x7f7f7fff&#x0A;  label &quot;sample range&quot;&#x0A;  note_font_size 30&#x0A;  bdwidth 320&#x0A;  bdheight 110&#x0A; }&#x0A; BackdropNode {&#x0A;  inputs 0&#x0A;  name BackdropNode7&#x0A;  tile_color 0x7f7f7fff&#x0A;  label &quot;luminance level&quot;&#x0A;  note_font_size 30&#x0A;  bdwidth 760&#x0A;  bdheight 685&#x0A; }&#x0A; BackdropNode {&#x0A;  inputs 0&#x0A;  name BackdropNode8&#x0A;  tile_color 0x7f7f7fff&#x0A;  label &quot;plate grain&quot;&#x0A;  note_font_size 30&#x0A;  bdwidth 320&#x0A;  bdheight 110&#x0A; }&#x0A; BackdropNode {&#x0A;  inputs 0&#x0A;  name BackdropNode9&#x0A;  tile_color 0x7f7f7fff&#x0A;  label replace&#x0A;  note_font_size 30&#x0A;  bdwidth 540&#x0A;  bdheight 226&#x0A; }&#x0A; Input {&#x0A;  inputs 0&#x0A;  name DEGRAINED_PLATE&#x0A;  label &quot;\[value number]&quot;&#x0A;  note_font_size 30&#x0A;  number 2&#x0A; }&#x0A; OCIOColorSpace {&#x0A;  in_colorspace {{OCIOColorSpace1.in_colorspace}}&#x0A;  out_colorspace {{OCIOColorSpace1.out_colorspace}}&#x0A;  name OCIOColorSpace2&#x0A; }&#x0A; Dot {&#x0A;  name Dot9&#x0A; }&#x0A;set Nda4b1000 [stack 0]&#x0A; Dot {&#x0A;  name Dot28&#x0A; }&#x0A;set Nda4b0c00 [stack 0]&#x0A; Dot {&#x0A;  name Dot32&#x0A; }&#x0A;set Nda4b0800 [stack 0]&#x0A;push $Nda4b0c00&#x0A; Dot {&#x0A;  name Dot27&#x0A; }&#x0A; Colorspace {&#x0A;  colorspace_out YCbCr&#x0A;  name Colorspace1&#x0A; }&#x0A; Dot {&#x0A;  name Dot7&#x0A; }&#x0A;set Nda46f800 [stack 0]&#x0A; Input {&#x0A;  inputs 0&#x0A;  name PLATE&#x0A;  label &quot;\[value number]&quot;&#x0A;  note_font_size 30&#x0A;  number 1&#x0A; }&#x0A; Dot {&#x0A;  name Dot50&#x0A; }&#x0A;set Nda46f000 [stack 0]&#x0A; OCIOColorSpace {&#x0A;  in_colorspace scene_linear&#x0A;  out_colorspace scene_linear&#x0A;  name OCIOColorSpace1&#x0A; }&#x0A; Dot {&#x0A;  name Dot29&#x0A; }&#x0A;set Nda46e400 [stack 0]&#x0A; Dot {&#x0A;  name Dot6&#x0A; }&#x0A; Colorspace {&#x0A;  colorspace_out YCbCr&#x0A;  name Colorspace2&#x0A; }&#x0A; Merge2 {&#x0A;  inputs 2&#x0A;  operation from&#x0A;  bbox B&#x0A;  Achannels rgb&#x0A;  Bchannels rgb&#x0A;  output rgb&#x0A;  name Merge4&#x0A; }&#x0A; Multiply {&#x0A;  channels rgb&#x0A;  value {{&quot;1 / parent.luminance - 1&quot;} 0 0 0}&#x0A;  name Multiply6&#x0A; }&#x0A; Dot {&#x0A;  name Dot31&#x0A; }&#x0A;push $Nda46f800&#x0A; Merge2 {&#x0A;  inputs 2&#x0A;  operation plus&#x0A;  bbox B&#x0A;  Achannels rgb&#x0A;  Bchannels rgb&#x0A;  output rgb&#x0A;  name Merge5&#x0A; }&#x0A; Colorspace {&#x0A;  colorspace_in YCbCr&#x0A;  name Colorspace3&#x0A; }&#x0A; Merge2 {&#x0A;  inputs 2&#x0A;  operation from&#x0A;  bbox B&#x0A;  Achannels rgb&#x0A;  Bchannels rgb&#x0A;  output rgb&#x0A;  name Merge6&#x0A; }&#x0A; Dot {&#x0A;  name Dot35&#x0A; }&#x0A;set Nda417c00 [stack 0]&#x0A;push $Nda4b0800&#x0A; Merge2 {&#x0A;  inputs 2&#x0A;  operation from&#x0A;  bbox B&#x0A;  Achannels rgb&#x0A;  Bchannels rgb&#x0A;  output rgb&#x0A;  name Merge7&#x0A;  disable {{&quot;Multiply6.value.r == 0&quot;}}&#x0A; }&#x0A; Dot {&#x0A;  name Dot2&#x0A; }&#x0A;set Nda417400 [stack 0]&#x0A; Dot {&#x0A;  name Dot30&#x0A; }&#x0A;set Nda417000 [stack 0]&#x0A; Dot {&#x0A;  name Dot55&#x0A; }&#x0A;set Nda416c00 [stack 0]&#x0A; Input {&#x0A;  inputs 0&#x0A;  name mask&#x0A;  label &quot;\[value number]&quot;&#x0A;  note_font_size 30&#x0A;  number 3&#x0A; }&#x0A; Dot {&#x0A;  name Dot39&#x0A; }&#x0A;set Nda416400 [stack 0]&#x0A; Dot {&#x0A;  name Dot26&#x0A; }&#x0A;set Nda416000 [stack 0]&#x0A; Invert {&#x0A;  name Invert2&#x0A;  disable {{!parent.invert_1}}&#x0A; }&#x0A;push $Nda417000&#x0A;push $Nda46e400&#x0A; Merge2 {&#x0A;  inputs 2&#x0A;  operation from&#x0A;  bbox B&#x0A;  Achannels rgb&#x0A;  Bchannels rgb&#x0A;  output rgb&#x0A;  name Merge27&#x0A; }&#x0A; Dot {&#x0A;  name Dot3&#x0A; }&#x0A;set Nda415400 [stack 0]&#x0A; Dot {&#x0A;  name Dot5&#x0A; }&#x0A;set Nda415000 [stack 0]&#x0A;push $Nda415000&#x0A; Copy {&#x0A;  inputs 2&#x0A;  from0 {{{parent.Copy2.from0}}}&#x0A;  to0 rgba.red&#x0A;  name Copy3&#x0A; }&#x0A; Expression {&#x0A;  expr0 abs(r)&#x0A;  channel1 {none none none rgba.alpha}&#x0A;  expr1 &quot;r == 0&quot;&#x0A;  channel2 none&#x0A;  channel3 none&#x0A;  name Expression4&#x0A; }&#x0A;set Nda414800 [stack 0]&#x0A;push $Nda417400&#x0A; Colorspace {&#x0A;  colorspace_out AlexaV3LogC&#x0A;  name Colorspace5&#x0A; }&#x0A; Clamp {&#x0A;  maximum_enable false&#x0A;  name Clamp2&#x0A; }&#x0A; Dot {&#x0A;  name Dot1&#x0A; }&#x0A;set Nda3d3800 [stack 0]&#x0A; Dot {&#x0A;  name Dot48&#x0A; }&#x0A;set Nda3d3400 [stack 0]&#x0A;push $Nda3d3400&#x0A; Copy {&#x0A;  inputs 2&#x0A;  from0 rgba.blue&#x0A;  to0 rgba.red&#x0A;  name Copy2&#x0A; }&#x0A; Expression {&#x0A;  temp_name0 min&#x0A;  temp_name1 max&#x0A;  channel0 {none none none rgba.alpha}&#x0A;  expr0 &quot;r &gt;= min &amp;&amp; r &lt;= max&quot;&#x0A;  channel1 none&#x0A;  channel2 none&#x0A;  channel3 none&#x0A;  name Expression2&#x0A; }&#x0A; Dot {&#x0A;  name Dot4&#x0A; }&#x0A; ChannelMerge {&#x0A;  inputs 2&#x0A;  operation stencil&#x0A;  name ChannelMerge2&#x0A; }&#x0A;push $Nda414800&#x0A; Copy {&#x0A;  inputs 2&#x0A;  from0 rgba.alpha&#x0A;  to0 rgba.alpha&#x0A;  name Copy1&#x0A; }&#x0A; ChannelMerge {&#x0A;  inputs 2&#x0A;  A -rgba.green&#x0A;  operation multiply&#x0A;  name ChannelMerge1&#x0A;  disable {{!A}}&#x0A; }&#x0A; Copy {&#x0A;  inputs 2&#x0A;  from0 {{{parent.Copy2.from0}}}&#x0A;  to0 rgba.green&#x0A;  name Copy4&#x0A; }&#x0A; Premult {&#x0A;  channels {rgba.red rgba.green -rgba.blue none}&#x0A;  name Premult1&#x0A; }&#x0A; TimeWarp {&#x0A;  lookup 1081&#x0A;  time &quot;&quot;&#x0A;  filter nearest&#x0A;  name TimeWarp1&#x0A;  disable true&#x0A; }&#x0A; FrameBlend {&#x0A;  channels {rgba.red rgba.green -rgba.blue rgba.alpha}&#x0A;  startframe 0&#x0A;  endframe 9&#x0A;  userange true&#x0A;  name FrameBlend1&#x0A;  disable true&#x0A; }&#x0A; CurveTool {&#x0A;  avgframes 0&#x0A;  channels {rgba.red rgba.green -rgba.blue rgba.alpha}&#x0A;  ROI {0 0 {width} {height}}&#x0A;  name CurveTool24&#x0A; }&#x0A;push $Nda3d3800&#x0A; Dot {&#x0A;  name Dot16&#x0A; }&#x0A; CurveTool {&#x0A;  operation &quot;Max Luma Pixel&quot;&#x0A;  channels {-rgba.red -rgba.green rgba.blue none}&#x0A;  ROI {0 0 {width} {height}}&#x0A;  name CurveTool_Range&#x0A; }&#x0A; Sampler {&#x0A;  inputs 0&#x0A;  lut {red {curve}&#x0A;    green {curve}&#x0A;    blue {curve}}&#x0A;  name Sampler1&#x0A;  onCreate &quot;n = nuke.thisNode()\nn\[&apos;sampler&apos;].setEnabled(False)&quot;&#x0A;  knobChanged &quot;n = nuke.thisNode()\nk = nuke.thisKnob()\np = nuke.thisParent()\n\nif k.name() == &apos;lut&apos;:\n    with p:\n        for c in \[&apos;ColorLookup1&apos;,&apos;ColorLookup2&apos;]:\n           nuke.toNode(c)\[&apos;lut&apos;].fromScript(k.toScript())&quot;&#x0A; }&#x0A;push $Nda46f000&#x0A; Dot {&#x0A;  name Dot51&#x0A; }&#x0A; Input {&#x0A;  inputs 0&#x0A;  name COMP&#x0A;  label &quot;\[value number]&quot;&#x0A;  note_font_size 30&#x0A; }&#x0A; Dot {&#x0A;  name Dot49&#x0A; }&#x0A;set Nda36ac00 [stack 0]&#x0A; Switch {&#x0A;  inputs 2&#x0A;  which {{parent.meta}}&#x0A;  name Switch1&#x0A; }&#x0A; Dot {&#x0A;  name Dot54&#x0A; }&#x0A; Dot {&#x0A;  name Dot52&#x0A; }&#x0A; Dot {&#x0A;  name Dot53&#x0A; }&#x0A;push $Nda416400&#x0A; Dot {&#x0A;  name Dot40&#x0A; }&#x0A;push $Nda417c00&#x0A; Dot {&#x0A;  name Dot34&#x0A; }&#x0A; Multiply {&#x0A;  inputs 1+1&#x0A;  channels rgb&#x0A;  value 0&#x0A;  maskChannelMask -rgba.red&#x0A;  name Multiply1&#x0A; }&#x0A;push $Nda36ac00&#x0A; OCIOColorSpace {&#x0A;  in_colorspace {{OCIOColorSpace1.in_colorspace}}&#x0A;  out_colorspace {{OCIOColorSpace1.out_colorspace}}&#x0A;  name OCIOColorSpace3&#x0A; }&#x0A; Dot {&#x0A;  name Dot44&#x0A; }&#x0A;set Nda368400 [stack 0]&#x0A; Merge2 {&#x0A;  inputs 2&#x0A;  operation from&#x0A;  bbox B&#x0A;  Achannels rgb&#x0A;  Bchannels rgb&#x0A;  output rgb&#x0A;  name Merge8&#x0A;  disable {{&quot;Multiply6.value.r == 0&quot;}}&#x0A; }&#x0A; Dot {&#x0A;  name Dot18&#x0A; }&#x0A;set Nda32b800 [stack 0]&#x0A; ColorLookup {&#x0A;  lut {master {}&#x0A;    red {curve}&#x0A;    green {curve}&#x0A;    blue {curve}&#x0A;    alpha {}}&#x0A;  name ColorLookup2&#x0A; }&#x0A;push $Nda416000&#x0A; Dot {&#x0A;  name Dot38&#x0A; }&#x0A; Dot {&#x0A;  name Dot37&#x0A; }&#x0A; Dot {&#x0A;  name Dot22&#x0A; }&#x0A;set Nda32a800 [stack 0]&#x0A; Dot {&#x0A;  name Dot20&#x0A; }&#x0A;push $Nda32a800&#x0A; Dot {&#x0A;  name Dot17&#x0A; }&#x0A;set Nda32a000 [stack 0]&#x0A; Dot {&#x0A;  name Dot13&#x0A; }&#x0A; Input {&#x0A;  inputs 0&#x0A;  name external_grain&#x0A;  label &quot;\[value number]&quot;&#x0A;  note_font_size 30&#x0A;  number 4&#x0A; }&#x0A; Dot {&#x0A;  name Dot21&#x0A; }&#x0A;push $Nda416c00&#x0A; ColorLookup {&#x0A;  channels rgb&#x0A;  lut {master {}&#x0A;    red {curve}&#x0A;    green {curve}&#x0A;    blue {curve}&#x0A;    alpha {}}&#x0A;  name ColorLookup1&#x0A; }&#x0A; Dot {&#x0A;  name Dot24&#x0A; }&#x0A;push $Nda415400&#x0A; Dot {&#x0A;  name Dot33&#x0A; }&#x0A; MergeExpression {&#x0A;  inputs 2&#x0A;  temp_name0 target&#x0A;  temp_expr0 .01&#x0A;  expr0 &quot;Br * (target / Ar)&quot;&#x0A;  expr1 &quot;Bg * (target / Ag)&quot;&#x0A;  expr2 &quot;Bb * (target / Ab)&quot;&#x0A;  channel3 none&#x0A;  name MergeExpression1&#x0A; }&#x0A; Dot {&#x0A;  name Dot15&#x0A; }&#x0A;set Nda2ebc00 [stack 0]&#x0A; Dot {&#x0A;  name Dot25&#x0A; }&#x0A; Switch {&#x0A;  inputs 2&#x0A;  which {{parent.external_grain}}&#x0A;  name Switch2&#x0A; }&#x0A; Group {&#x0A;  name VoronoiScatter&#x0A;  disable {{!parent.scatter}}&#x0A;  addUserKnob {20 User}&#x0A;  addUserKnob {41 useGPUIfAvailable l &quot;Use GPU if available&quot; T VoroNoise.useGPUIfAvailable}&#x0A;  addUserKnob {41 vectorize l &quot;Vectorize on CPU&quot; -STARTLINE T VoroNoise.vectorize}&#x0A;  addUserKnob {15 box}&#x0A;  box {{parent.box x1004 0 x1036 -75} {parent.box x1004 100 x1036 120} {parent.box x1004 496 x1036 325} {parent.box x1004 916 x1036 320}}&#x0A;  addUserKnob {3 sample_frame l &quot;sample frame&quot;}&#x0A;  sample_frame {{parent.sample_frame}}&#x0A;  addUserKnob {7 cell_size l &quot;cell size&quot; R 0 100}&#x0A;  cell_size {{parent.cell_size}}&#x0A;  addUserKnob {6 overlay_pattern l &quot;overlay pattern&quot; -STARTLINE}&#x0A;  overlay_pattern {{parent.overlay}}&#x0A;  addUserKnob {3 edge_blend_size l &quot;edge blend size&quot;}&#x0A;  edge_blend_size {{parent.edge_blend_size}}&#x0A;  addUserKnob {7 amplitude R 0 100}&#x0A;  amplitude {{parent.amplitude}}&#x0A;  addUserKnob {7 frequency R 0 100}&#x0A;  frequency {{parent.frequency}}&#x0A;  addUserKnob {41 VoroNoise_Seed l Seed T VoroNoise.VoroNoise_Seed}&#x0A; }&#x0A;  Input {&#x0A;   inputs 0&#x0A;   name Input1&#x0A;  }&#x0A;  Dot {&#x0A;   name Dot14&#x0A;  }&#x0A;set Nda2eac00 [stack 0]&#x0A;  Dot {&#x0A;   name Dot16&#x0A;  }&#x0A;  Remove {&#x0A;   name Remove1&#x0A;  }&#x0A;  Dot {&#x0A;   name Dot6&#x0A;  }&#x0A;set Nda2ea000 [stack 0]&#x0A;  Dot {&#x0A;   name Dot15&#x0A;  }&#x0A;set Nda2e9c00 [stack 0]&#x0A;  Dot {&#x0A;   name Dot7&#x0A;  }&#x0A;  Noise {&#x0A;   output {rgba.red -rgba.green -rgba.blue none}&#x0A;   replace true&#x0A;   size {{parent.frequency} {&quot;parent.frequency * pixel_aspect&quot;}}&#x0A;   zoffset {{&quot;x + 1000&quot;}}&#x0A;   gamma 1&#x0A;   name Noise1&#x0A;  }&#x0A;  Noise {&#x0A;   output {-rgba.red rgba.green -rgba.blue none}&#x0A;   replace true&#x0A;   size {{parent.Noise1.size} {parent.Noise1.size}}&#x0A;   zoffset {{x}}&#x0A;   gamma 1&#x0A;   name Noise2&#x0A;  }&#x0A;  Clamp {&#x0A;   name Clamp1&#x0A;  }&#x0A;  Dot {&#x0A;   name Dot11&#x0A;  }&#x0A;push $Nda2e9c00&#x0A;  BlinkScript {&#x0A;   ProgramGroup 1&#x0A;   KernelDescription &quot;2 \&quot;VoroNoise\&quot; iterate pixelWise c117be128a07c11b6d82fd34148d66b3bcac41976ec9c2082affe38e890c2c0f 2 \&quot;src\&quot; Read Point \&quot;dst\&quot; Write Point 6 \&quot;Frequency\&quot; Float 1 AABIQg== \&quot;Seed\&quot; Int 1 AAAAAA== \&quot;aspect ratio\&quot; Float 1 AACAPw== \&quot;width\&quot; Int 1 AAAAAA== \&quot;height\&quot; Int 1 AAAAAA== \&quot;Randomness\&quot; Float 1 AAAAPw== 6 \&quot;frequency\&quot; 1 1 \&quot;seed\&quot; 1 1 \&quot;aspect_ratio\&quot; 1 1 \&quot;width\&quot; 1 1 \&quot;height\&quot; 1 1 \&quot;randomness\&quot; 1 1 0&quot;&#x0A;   kernelSource &quot;// Voronoi.blink\n// A test implementation of libNoise&apos;s Voronoi generator using Blink\n// Ivan Busquets - August 2013\n// Modified for DasGrain by Fabian Holtz - April 2019\n\n#define X_NOISE_GEN  1619\n#define Y_NOISE_GEN  31337\n#define Z_NOISE_GEN  6971\n#define SEED_NOISE_GEN  1013\n#define SQRT_3 1.73205081\n\ninline int IntValueNoise3D (int x, int y, int z, int seed)\n\{\n  // All constants are primes and must remain prime in order for this noise\n  // function to work correctly.\n  int n = (\n      X_NOISE_GEN    * x\n    + Y_NOISE_GEN    * y\n    + Z_NOISE_GEN    * z\n    + SEED_NOISE_GEN * seed)\n    &amp; 0x7fffffff;\n  n = (n &gt;&gt; 13) ^ n;\n  return (n * (n * n * 60493 + 19990303) + 1376312589) &amp; 0x7fffffff;\n\}\n\ninline float ValueNoise3D (int x, int y, int z, int seed)\n\{\n  return 1.0 - ((float)IntValueNoise3D (x, y, z, seed) / 1073741824.0);\n\}\n\nkernel VoroNoise : ImageComputationKernel&lt;ePixelWise&gt;\n\{\n  Image&lt;eRead&gt; src;\n  Image&lt;eWrite, eAccessPoint&gt; dst;\n\nparam:\n  float frequency;\n  int seed;\n  float aspect_ratio;\n  int width;\n  int height;\n  float randomness;\n\n\n  void define() \{\n    defineParam(frequency, \&quot;Frequency\&quot;, 50.0f);\n    defineParam(aspect_ratio, \&quot;aspect ratio\&quot;, 1.0f);\n    defineParam(seed, \&quot;Seed\&quot;, 0);\n    defineParam(randomness, \&quot;Randomness\&quot;, 0.5f);\n  \}\n\n\n\n\n  void process(int2 pos) \{\n   float x = pos.x * aspect_ratio * frequency / width;\n   float y = pos.y * frequency / width;\n   int xInt = (x &gt; 0.0) ? x : x - 1;\n   int yInt = (y &gt; 0.0) ? y : y - 1;\n\n\n    float minDist = 2147483647.0;\n    float xCandidate = 0;\n    float yCandidate = 0;\n\n    float dist;\n\nfor (int yCur = yInt - 2; yCur &lt;= yInt + 2; yCur++) \{\n      for (int xCur = xInt - 2; xCur &lt;= xInt + 2; xCur++) \{\n\n        // Calculate the position and distance to the seed point inside of\n        // this unit cube. Limited by the randomness value\n        float xPos = xCur + (ValueNoise3D (xCur, yCur, 0, seed    ) + 1 ) * randomness + (1-randomness) - 1;\n        float yPos = yCur + (ValueNoise3D (xCur, yCur, 0, seed + 1) + 1 ) * randomness + (1-randomness) - 1;\n\n        float xDist = xPos - x;\n        float yDist = yPos - y;\n\n        dist = pow(xDist, 2) + pow(yDist, 2);\n        if (dist &lt; minDist) \{\n          // This seed point is closer to any others found so far, so record\n          // this seed point.\n          minDist = dist;\n          xCandidate = xPos;\n          yCandidate = yPos;\n\t\}\n    \}\n\}\n\n    SampleType(dst) sample(0.0f);\n\n    sample.x = xCandidate / aspect_ratio / frequency;\n    sample.y = yCandidate / height * width / frequency;\n    sample.z = 0;\n\n    dst() = sample;\n\}\n\};&quot;&#x0A;   rebuild &quot;&quot;&#x0A;   VoroNoise_Frequency {{&quot;width / parent.cell_size&quot;}}&#x0A;   VoroNoise_Seed {{&quot;(x + (parent.parent.stereo == 2 ? \[lsearch \[value root.views] \[view]] / 2 : 0)) * 5&quot;}}&#x0A;   &quot;VoroNoise_aspect ratio&quot; {{pixel_aspect}}&#x0A;   VoroNoise_width {{width}}&#x0A;   VoroNoise_height {{height}}&#x0A;   rebuild_finalise &quot;&quot;&#x0A;   name VoroNoise&#x0A;  }&#x0A;  Copy {&#x0A;   inputs 2&#x0A;   from0 rgba.red&#x0A;   to0 forward.u&#x0A;   from1 rgba.green&#x0A;   to1 forward.v&#x0A;   name Copy1&#x0A;   disable {{&quot;parent.amplitude == 0&quot;}}&#x0A;  }&#x0A;  IDistort {&#x0A;   uv forward&#x0A;   uv_offset 0.5&#x0A;   uv_scale {{parent.amplitude} {&quot;uv_scale.w * pixel_aspect&quot;}}&#x0A;   filter impulse&#x0A;   name IDistort1&#x0A;   disable {{&quot;parent.amplitude == 0&quot;}}&#x0A;  }&#x0A;  Dot {&#x0A;   name Dot5&#x0A;  }&#x0A;  NoTimeBlur {&#x0A;   rounding floor&#x0A;   name NoTimeBlur3&#x0A;  }&#x0A;  Transform {&#x0A;   translate {{&quot;floor((x * size) % 1 * (size)) - int(size / 2)&quot;} {&quot;floor(x % 1 * (size)) - int(size/2)&quot;}}&#x0A;   filter impulse&#x0A;   black_outside false&#x0A;   name Transform1&#x0A;   disable {{&quot;parent.edge_blend_size &lt; 1&quot;}}&#x0A;   addUserKnob {20 User}&#x0A;   addUserKnob {3 size}&#x0A;   size {{&quot;parent.edge_blend_size + 1&quot;}}&#x0A;  }&#x0A;  Dot {&#x0A;   name Dot9&#x0A;  }&#x0A;set Nda27e800 [stack 0]&#x0A;push $Nda2ea000&#x0A;  Expression {&#x0A;   expr0 &quot;(x + .5) / width&quot;&#x0A;   expr1 &quot;(y + .5) / height&quot;&#x0A;   expr2 0&#x0A;   name STMapGenerator&#x0A;  }&#x0A;  NoTimeBlur {&#x0A;   rounding floor&#x0A;   name NoTimeBlur2&#x0A;  }&#x0A;  Merge2 {&#x0A;   inputs 2&#x0A;   operation from&#x0A;   Achannels {rgba.red rgba.green -rgba.blue none}&#x0A;   Bchannels {rgba.red rgba.green -rgba.blue none}&#x0A;   output {rgba.red rgba.green -rgba.blue none}&#x0A;   name Merge2&#x0A;  }&#x0A;  Dot {&#x0A;   name Dot10&#x0A;  }&#x0A;push $Nda27e800&#x0A;  Expression {&#x0A;   temp_name0 view_index&#x0A;   temp_expr0 &quot;parent.parent.stereo == 1 ? \[lsearch \[value root.views] \[view]] / 2 : 0&quot;&#x0A;   expr0 &quot;random((r + view_index) * 1000000, 0) * (maxx - minx) + minx&quot;&#x0A;   expr1 &quot;random((g + view_index) * 1000000, 0) * (maxy - miny) + miny&quot;&#x0A;   channel2 none&#x0A;   channel3 none&#x0A;   name Expression3&#x0A;   addUserKnob {20 User}&#x0A;   addUserKnob {7 frequency R 0 100}&#x0A;   frequency {{parent.parent.cell_size}}&#x0A;   addUserKnob {7 multiplier R 0 3}&#x0A;   multiplier 0.5&#x0A;   addUserKnob {15 shrink}&#x0A;   shrink {{&quot;frequency * multiplier + ceil(parent.edge_blend_size / 2) + IDistort1.uv_scale.w / 2&quot;} {&quot;frequency * multiplier + ceil(parent.edge_blend_size / 2) + IDistort1.uv_scale.h / 2&quot;} {&quot;frequency * multiplier + floor(parent.edge_blend_size / 2) + IDistort1.uv_scale.w / 2&quot;} {&quot;frequency * multiplier + floor(parent.edge_blend_size / 2) + IDistort1.uv_scale.h / 2&quot;}}&#x0A;   addUserKnob {26 &quot;&quot;}&#x0A;   addUserKnob {7 minx}&#x0A;   minx {{&quot;(parent.box.x + shrink.x + .5) / width&quot;}}&#x0A;   addUserKnob {7 maxx}&#x0A;   maxx {{&quot;(parent.box.r - shrink.r - .5) / width&quot;}}&#x0A;   addUserKnob {7 miny}&#x0A;   miny {{&quot;(parent.box.y + shrink.y + .5) / height&quot;}}&#x0A;   addUserKnob {7 maxy}&#x0A;   maxy {{&quot;(parent.box.t - shrink.t - .5) / height&quot;}}&#x0A;  }&#x0A;  Merge2 {&#x0A;   inputs 2&#x0A;   operation plus&#x0A;   Achannels {rgba.red rgba.green -rgba.blue none}&#x0A;   Bchannels {rgba.red rgba.green -rgba.blue none}&#x0A;   output {rgba.red rgba.green -rgba.blue none}&#x0A;   name Merge3&#x0A;  }&#x0A;  Expression {&#x0A;   expr0 &quot;(r + (maxx - minx) - minx) % (maxx - minx) + minx&quot;&#x0A;   expr1 &quot;(g + (maxy - miny) - miny) % (maxy - miny) + miny&quot;&#x0A;   channel2 none&#x0A;   channel3 none&#x0A;   name Expression7&#x0A;   addUserKnob {20 User}&#x0A;   addUserKnob {7 minx}&#x0A;   minx {{&quot;(parent.box.x + rint(x % 1 * parent.edge_blend_size) + .5) / width&quot;}}&#x0A;   addUserKnob {7 maxx}&#x0A;   maxx {{&quot;(parent.box.r + rint(x % 1 * parent.edge_blend_size) - .5) / width&quot;}}&#x0A;   addUserKnob {7 miny}&#x0A;   miny {{&quot;(parent.box.y + rint(x % 1 * parent.edge_blend_size) + .5) / height&quot;}}&#x0A;   addUserKnob {7 maxy}&#x0A;   maxy {{&quot;(parent.box.t + rint(x % 1 * parent.edge_blend_size) - .5) / height&quot;}}&#x0A;  }&#x0A;  Dot {&#x0A;   name Dot3&#x0A;  }&#x0A;set Nda27c800 [stack 0]&#x0A;  Dot {&#x0A;   name Dot13&#x0A;  }&#x0A;push $Nda27c800&#x0A;  Dot {&#x0A;   name Dot8&#x0A;  }&#x0A;  Blur {&#x0A;   channels rgb&#x0A;   size {{pixel_aspect} 1}&#x0A;   name Blur1&#x0A;   label &quot;\[value size]&quot;&#x0A;  }&#x0A;  Difference {&#x0A;   inputs 2&#x0A;   name Difference2&#x0A;  }&#x0A;  Expression {&#x0A;   channel0 {none none none rgba.alpha}&#x0A;   expr0 &quot;a &gt; 1e-9&quot;&#x0A;   channel1 none&#x0A;   channel2 none&#x0A;   channel3 none&#x0A;   name Expression2&#x0A;  }&#x0A;  Shuffle {&#x0A;   red alpha&#x0A;   green alpha&#x0A;   blue alpha&#x0A;   name Shuffle1&#x0A;   label &quot;\[value in]:\[value out]&quot;&#x0A;  }&#x0A;  Dot {&#x0A;   name Dot4&#x0A;  }&#x0A;push $Nda27c800&#x0A;push $Nda2eac00&#x0A;  FrameHold {&#x0A;   firstFrame {{parent.sample_frame}}&#x0A;   name FrameHold1&#x0A;  }&#x0A;  NoTimeBlur {&#x0A;   rounding floor&#x0A;   name NoTimeBlur1&#x0A;  }&#x0A;  STMap {&#x0A;   inputs 2&#x0A;   channels rgb&#x0A;   uv rgb&#x0A;   filter impulse&#x0A;   name STMap1&#x0A;  }&#x0A;set Nda226000 [stack 0]&#x0A;  TimeBlur {&#x0A;   divisions {{&quot;max(Transform1.size == 1 ? 2 : pow2(Transform1.size), 1)&quot;}}&#x0A;   shutter 1&#x0A;   shuttercustomoffset {{&quot;1 / divisions / 2&quot;}}&#x0A;   name TimeBlur1&#x0A;   disable {{&quot;parent.edge_blend_size &lt; 1&quot;}}&#x0A;  }&#x0A;set Nda225c00 [stack 0]&#x0A;push $Nda226000&#x0A;  Dot {&#x0A;   name Dot1&#x0A;  }&#x0A;  Difference {&#x0A;   inputs 2&#x0A;   name Difference1&#x0A;  }&#x0A;  Expression {&#x0A;   channel0 {none none none rgba.alpha}&#x0A;   expr0 &quot;a &gt; 1e-10&quot;&#x0A;   channel1 none&#x0A;   channel2 none&#x0A;   channel3 none&#x0A;   name Expression1&#x0A;  }&#x0A;  Blur {&#x0A;   channels alpha&#x0A;   size {{parent.parent.edge_blend_size}}&#x0A;   name Blur2&#x0A;  }&#x0A;  Grade {&#x0A;   channels alpha&#x0A;   blackpoint 0.5&#x0A;   white_clamp true&#x0A;   name Grade2&#x0A;  }&#x0A;  Dot {&#x0A;   name Dot2&#x0A;  }&#x0A;push $Nda225c00&#x0A;  Grade {&#x0A;   inputs 1+1&#x0A;   white 1.4&#x0A;   black_clamp false&#x0A;   name Grade1&#x0A;   disable {{&quot;parent.edge_blend_size &lt; 1&quot;}}&#x0A;  }&#x0A;  Merge2 {&#x0A;   inputs 2&#x0A;   Achannels rgb&#x0A;   Bchannels rgb&#x0A;   output rgb&#x0A;   name Merge1&#x0A;   disable {{!parent.overlay_pattern}}&#x0A;  }&#x0A;  Assert {&#x0A;   expression {{&quot;Expression3.maxx &gt; Expression3.minx &amp;&amp; Expression3.maxy &gt; Expression3.miny&quot;}}&#x0A;   message &quot;increase sample box size or decrease cell size&quot;&#x0A;   name error&#x0A;  }&#x0A;  Output {&#x0A;   name Output1&#x0A;  }&#x0A; end_group&#x0A; Multiply {&#x0A;  inputs 1+1&#x0A;  channels rgb&#x0A;  value 1.8&#x0A;  maskChannelMask {{{parent.Merge9.maskChannelMask}}}&#x0A;  invert_mask {{!Merge9.invert_mask}}&#x0A;  name Multiply7&#x0A;  disable {{&quot;!maskChannelMask || !\[exists parent.input3.name]&quot;}}&#x0A; }&#x0A; Dot {&#x0A;  name Dot23&#x0A; }&#x0A;push $Nda32a000&#x0A;push $Nda2ebc00&#x0A; Multiply {&#x0A;  inputs 1+1&#x0A;  channels rgb&#x0A;  value 1.8&#x0A;  maskChannelMask {{{parent.Merge9.maskChannelMask}}}&#x0A;  invert_mask {{parent.Merge9.invert_mask}}&#x0A;  name Multiply2&#x0A;  disable {{&quot;!maskChannelMask || (!parent.scatter &amp;&amp; !parent.external_grain)&quot;}}&#x0A; }&#x0A; Merge2 {&#x0A;  inputs 2+1&#x0A;  operation copy&#x0A;  Achannels rgb&#x0A;  Bchannels rgb&#x0A;  output rgb&#x0A;  maskChannelMask -rgba.alpha&#x0A;  name Merge9&#x0A;  disable {{&quot;!(parent.scatter || parent.external_grain)&quot;}}&#x0A; }&#x0A; Dot {&#x0A;  name Dot11&#x0A; }&#x0A;set Nda1c9c00 [stack 0]&#x0A; MergeExpression {&#x0A;  inputs 2&#x0A;  temp_name0 reverse&#x0A;  temp_expr0 &quot;1 / MergeExpression1.temp_expr0&quot;&#x0A;  expr0 &quot;Br * Ar * reverse&quot;&#x0A;  expr1 &quot;Bg * Ag * reverse&quot;&#x0A;  expr2 &quot;Bb * Ab * reverse&quot;&#x0A;  name MergeExpression2&#x0A; }&#x0A; Dot {&#x0A;  name Dot8&#x0A; }&#x0A;push $Nda32b800&#x0A; Merge2 {&#x0A;  inputs 2&#x0A;  operation plus&#x0A;  bbox B&#x0A;  Achannels rgb&#x0A;  Bchannels rgb&#x0A;  output rgb&#x0A;  name Merge3&#x0A; }&#x0A; Dot {&#x0A;  name Dot42&#x0A; }&#x0A;set Nda1c8c00 [stack 0]&#x0A; OCIOColorSpace {&#x0A;  in_colorspace {{OCIOColorSpace1.out_colorspace}}&#x0A;  out_colorspace {{OCIOColorSpace1.in_colorspace}}&#x0A;  name OCIOColorSpace4&#x0A; }&#x0A; Dot {&#x0A;  name Dot19&#x0A; }&#x0A;set Ndf87bc00 [stack 0]&#x0A; Dot {&#x0A;  name Dot41&#x0A; }&#x0A;set Ndf87b800 [stack 0]&#x0A; Dot {&#x0A;  name Dot36&#x0A; }&#x0A; Blur {&#x0A;  channels rgb&#x0A;  size 1&#x0A;  name Blur1&#x0A; }&#x0A;push $Ndf87b800&#x0A; Merge2 {&#x0A;  inputs 2&#x0A;  operation difference&#x0A;  bbox B&#x0A;  Achannels rgb&#x0A;  Bchannels rgb&#x0A;  output rgb&#x0A;  name Merge10&#x0A; }&#x0A; Multiply {&#x0A;  channels rgb&#x0A;  value 50&#x0A;  name Multiply3&#x0A; }&#x0A; Dot {&#x0A;  name Dot43&#x0A; }&#x0A;push $Nda368400&#x0A; Dot {&#x0A;  name Dot45&#x0A; }&#x0A;push $Nda1c8c00&#x0A; Merge2 {&#x0A;  inputs 2&#x0A;  operation from&#x0A;  Achannels rgb&#x0A;  Bchannels rgb&#x0A;  output rgb&#x0A;  name Merge11&#x0A; }&#x0A; Dot {&#x0A;  name Dot46&#x0A; }&#x0A;push $Nda1c9c00&#x0A; Dot {&#x0A;  name Dot14&#x0A; }&#x0A; Dot {&#x0A;  name Dot12&#x0A; }&#x0A;push $Nda4b1000&#x0A; Dot {&#x0A;  name Dot47&#x0A; }&#x0A;push $Nda46e400&#x0A; Merge2 {&#x0A;  inputs 2&#x0A;  operation from&#x0A;  Achannels rgb&#x0A;  Bchannels rgb&#x0A;  output rgb&#x0A;  name Merge12&#x0A; }&#x0A; Dot {&#x0A;  name Dot10&#x0A; }&#x0A;push $Ndf87bc00&#x0A; Switch {&#x0A;  inputs 5&#x0A;  which {{output}}&#x0A;  name Output&#x0A;  addUserKnob {20 User}&#x0A;  addUserKnob {4 output M {&quot;regrained comp&quot; &quot;plate grain&quot; &quot;normalised grain&quot; &quot;adapted grain&quot; &quot;grain QC&quot;}}&#x0A; }&#x0A; CopyMetaData {&#x0A;  inputs 2&#x0A;  mergeMode &quot;Meta only&quot;&#x0A;  name CopyMetaData1&#x0A; }&#x0A; Output {&#x0A;  name Output1&#x0A; }&#x0A;end_group&#x0A;set Nda4c7900 [stack 0]&#x0A;Write {&#x0A; file &quot;\[file dir \[value root.name]]/../4_publish/\[file tail \[file rootname \[value root.name]]]/\[file tail \[file rootname \[value root.name]]]_%04d.exr&quot;&#x0A; file_type exr&#x0A; compression DWAA&#x0A; dw_compression_level 60&#x0A; first_part rgba&#x0A; create_directories true&#x0A; version 2&#x0A; name Write_Pub&#x0A; selected true&#x0A; bookmark true&#x0A;}&#x0A;push $Nda50d400&#x0A;push $Nda4c7900&#x0A;push $Nda50d400&#x0A;Viewer {&#x0A; inputs 3&#x0A; frame_range 1001-1131&#x0A; input_number 2&#x0A; viewerProcess &quot;Rec.709 (ACES)&quot;&#x0A; name Viewer1&#x0A; tile_color 0x323232ff&#x0A; selected true&#x0A;}</SequenceItem>
                        </SequenceItem>
                    </additionalNodesData>
                    <method valuetype="str">None</method>
                    <reformat valuetype="dict">
                        <filter valuetype="str">Cubic</filter>
                        <to_type valuetype="str">Plate Resolution</to_type>
                        <center valuetype="bool">True</center>
                        <resize valuetype="str">width</resize>
                    </reformat>
                    <postProcessScript valuetype="bool">True</postProcessScript>
                    <useRelativePaths valuetype="bool">False</useRelativePaths>
                </root>
            </SequenceItem>
        </SequenceItem>
    </exportTemplate>
    <exportRoot valuetype="str">{projectroot}</exportRoot>
    <cutHandles valuetype="int">12</cutHandles>
    <cutUseHandles valuetype="bool">False</cutUseHandles>
    <cutLength valuetype="bool">True</cutLength>
    <includeRetimes valuetype="bool">False</includeRetimes>
    <startFrameIndex valuetype="int">1001</startFrameIndex>
    <startFrameSource valuetype="str">Custom</startFrameSource>
</root>
